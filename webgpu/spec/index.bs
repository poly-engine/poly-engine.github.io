<pre class=metadata>
Title: WebGPU
Shortname: webgpu
Level: None
Status: w3c/ED
Group: webgpu
ED: https://gpuweb.github.io/gpuweb/
TR: https://www.w3.org/TR/webgpu/
Repository: gpuweb/gpuweb
!Participate: <a href="https://github.com/gpuweb/gpuweb/issues/new">File an issue</a> (<a href="https://github.com/gpuweb/gpuweb/issues">open issues</a>)

Editor: Kai Ninomiya, Google https://www.google.com, kainino@google.com, w3cid 99487
Editor: Brandon Jones, Google https://www.google.com, bajones@google.com, w3cid 87824
Editor: Myles C. Maxfield, Apple Inc. https://www.apple.com, mmaxfield@apple.com, w3cid 77180
Former Editor: Dzmitry Malyshau, Mozilla https://www.mozilla.org, dmalyshau@mozilla.com, w3cid 96977
Former Editor: Justin Fan, Apple Inc. https://www.apple.com, justin_fan@apple.com, w3cid 115633
Abstract: WebGPU API翻译文档。本翻译非官方翻译。（WebGPU 公开了一个 API，用于在图形处理单元上执行操作，例如渲染和计算。）
Markup Shorthands: markdown yes
Markup Shorthands: dfn yes
Markup Shorthands: idl yes
Markup Shorthands: css no
Assume Explicit For: yes
</pre>

<pre class=biblio>
{
    "SourceMap": {
        "authors": [
            "John Lenz",
            "Nick Fitzgerald"
        ],
        "href": "https://sourcemaps.info/spec.html",
        "title": "Source Map Revision 3 Proposal"
    }
}
</pre>

<pre class=link-defaults>
</pre>
<pre class=ignored-specs>
spec:resource-hints;
</pre>
<pre class=anchors>
spec: ECMA-262; urlPrefix: https://tc39.es/ecma262/#
    type: dfn
        text: agent; url: agent
        text: surrounding agent; url: surrounding-agent
        text: agent cluster; url: sec-agent-clusters
        text: ?; url: sec-returnifabrupt-shorthands
        text: !; url: sec-returnifabrupt-shorthands
        text: Data Block; url: sec-data-blocks
    type: abstract-op
        text: DetachArrayBuffer; url: sec-detacharraybuffer
        text: AllocateArrayBuffer; url: sec-allocatearraybuffer
        text: CreateByteDataBlock; url: sec-createbytedatablock
    type: attribute
        for: ArrayBuffer
            text: [[ArrayBufferDetachKey]]; url: sec-properties-of-the-arraybuffer-instances
spec: HTML; urlPrefix: https://html.spec.whatwg.org/multipage/
    type: dfn
        text: origin-clean; url: canvas.html#concept-canvas-origin-clean
        text: check the usability of the image argument; url: canvas.html#check-the-usability-of-the-image-argument
        text: placeholder canvas element; url: canvas.html#offscreencanvas-placeholder
        text: event loop processing model; url: webappapis.html#event-loop-processing-model
        for: video
            text: intrinsic width; url: media.html#concept-video-intrinsic-width
            text: intrinsic height; url: media.html#concept-video-intrinsic-height
spec: WEBGL-1; urlPrefix: https://www.khronos.org/registry/webgl/specs/latest/1.0/#
    type: interface
        text: WebGLRenderingContext; url: WEBGLRENDERINGCONTEXT
    type: attribute; for: WebGLRenderingContext
        text: drawingBufferColorSpace; url: DOM-WebGLRenderingContext-drawingBufferColorSpace
    type: dictionary
        text: WebGLContextAttributes; url: WEBGLCONTEXTATTRIBUTES
spec: WGSL; urlPrefix: https://gpuweb.github.io/gpuweb/wgsl/#
    type: dfn
        text: f16; url: f16
        text: location; url: input-output-locations
        text: interpolation; url: interpolation
        text: pipeline-overridable; url: pipeline-overridable
        text: pipeline-overridable constant identifier string; url: pipeline-overridable-constant-identifier-string
        text: pipeline-overridable constant default value; url: pipeline-overridable-constant-default-value
        text: interface of a shader stage; url: interface-of-a-shader
        text: shader execution end; url: shader-execution-end
        text: shader stage output; url: shader-stage-outputs
        text: shader stage input; url: shader-stage-inputs
        text: builtin; url: built-in-values
        text: channel formats; url: channel-formats
        text: invalid memory reference; url: invalid-memory-reference
        text: shader module creation; url: shader-module-creation
        text: pipeline creation; url: pipeline-creation
        text: program error; url: program-error
        text: roundUp; url: roundup
        text: uncategorized error; url: uncategorized-error
        text: shader-creation error; url: shader-creation-error
        text: pipeline-creation error; url: pipeline-creation-error
        text: store type; url: store-type
        text: language extension; url: language-extension
        text: runtime-sized; url: runtime-sized
        text: WGSL floating point conversion; url: floating-point-conversion
        text: WGSL identifier comparison; url: identifier-comparison
        text: WGSL scalar type; url: scalar-types
        text: @binding; url: attribute-binding
        text: @group; url: attribute-group
        text: line break; url: line-break
        for: address spaces
            text: workgroup; url: address-spaces-workgroup
        for: builtin
            text: sample_mask; url: built-in-values-sample_mask
            text: frag_depth; url: built-in-values-frag_depth
        for: extension
            text: f16; url: extension-f16
    type: abstract-op
        text: SizeOf; url: sizeof
spec: Internationalization Glossary; urlPrefix: https://www.w3.org/TR/i18n-glossary/#
    type: dfn
        text: localizable text; url: def_localizable_text
spec: Strings on the Web; urlPrefix: https://w3c.github.io/string-meta/#
    type: dfn
        text: best practices for language and direction information; url: bp_and-reco
</pre>

<style>
/* Make <dl> blocks more distinct from their surroundings. */
main dl:not(.switch) {
    border-left: thin solid #f3e48c;
    padding-left: .5em;
}

/* Remove unnecessary extra margin on switch bodies */
dl.switch dd {
    margin-left: 0em;
}

/* <p> by default has these margins. Update ul/ol/dl to match,
 * since they are also put in places where paragraphs go. */
p, ul, ol, dl {
    margin: 1em 0;
}

/* Styling for "editorial" issues */
.note.editorial {
    border-color: var(--note-editorial-border);
    background: var(--note-editorial-bg);
}

/* Our SVGs aren't responsive to light/dark mode, so they're opaque with a
 * white or black background. Rounded corners make them a bit less jarring. */
object[type="image/svg+xml"] {
    border-radius: .5em;
}

/* The new spec template doesn't put a box around algorithms anymore. */
/* Add a similar box for Valid Usage requirements. */
div.algorithm, div.validusage {
    margin: .5em 0;
    padding: .5em;
    border-width: thin;
    border-style: solid;
    border-radius: .5em;
}
div.validusage {
    border-color: #88e;
}
div.algorithm {
    border-color: #ddd;
}
/*
 * If the Valid Usage requirements are the first child of a *-timeline block give it a larger top
 * margin to prevent the block labels from overlapping.
 */
.content-timeline>.validusage:first-child,
.device-timeline>.validusage:first-child,
.queue-timeline>.validusage:first-child {
    margin-top: 1.5em;
}

/*
 * Boxes for steps that occur on a particular timeline.
 */
div.content-timeline, div.device-timeline, div.queue-timeline {
    padding: .5em;
    border-radius: .5em;
}
.content-timeline {
    background: rgba(0, 255, 0, 0.05);
    background: var(--tint-green);
}
.device-timeline {
    background: rgba(255, 0, 0, 0.05);
    background: var(--tint-red);
}
.queue-timeline {
    background: rgba(255, 0, 255, 0.05);
    background: var(--tint-purple);
}

span[data-timeline],
dfn[data-timeline],
var[data-timeline],
a[data-timeline],
[href="#content-timeline"],
[href="#device-timeline"],
[href="#queue-timeline"] {
    border-style: solid;
    border-radius: .3em;
    border-width: 0 0 .2em 0;
    text-decoration: none;
}
dl[data-timeline],
div[data-timeline] {
    border-style: solid;
    border-radius: 1em 0 0 1em;
    padding: .5em;
}
dl[data-timeline] {
    border-width: 0 0 0 .25em !important;
}
div[data-timeline] {
    border-width: 1px 0 0 .75em;
}
div.algorithm[data-timeline] {
    border-width: 1px 1px 1px .75em;
}
div.algorithm > div[data-timeline] {
    /* Remove unnecessary padding in this common case. Makes the border of the
     * timeline box line up with the border of the surrounding algorithm box. */
    margin-left: calc(-.5em - 1px);
    margin-right: calc(-.5em - 1px);
}

/*
 * Coloring for steps and other stuff on particular timelines.
 */
[data-timeline="content"],
[href="#content-timeline"] {
    border-color: #00cc00 !important;
}
[data-timeline="device"],
[href="#device-timeline"] {
    border-color: #880000 !important;
}
[data-timeline="queue"],
[href="#queue-timeline"] {
    border-color: #c900f1 !important;
}
[data-timeline="const"] {
    /* 186 is perceptual 50% gray, so works for both light and dark modes. */
    border-color: rgb(186 186 186 / 30%) !important;
}

/*
 * Stylistic labels, for clarity of presentation of these blocks.
 *
 * NOTE: This text is non-accessible and non-selectable; surrounding
 * text must also explain the context.
 */
.validusage,
.content-timeline, .device-timeline, .queue-timeline,
[data-timeline] {
    position: relative;
}
.validusage::before,
.content-timeline::before,
.device-timeline::before,
.queue-timeline::before {
    font-weight: bold;
    font-style: italic;
    font-size: 1.3rem;
    color: rgba(0, 0, 0, 0.15);
    color: var(--watermark-text);
    position: absolute;
    right: .3em;
    top: -.1em;
}
.validusage::before {
    content: "Valid Usage";
}
.content-timeline::before {
    content: "Content Timeline";
}
.device-timeline::before {
    content: "Device Timeline";
}
.queue-timeline::before {
    content: "Queue Timeline";
}

/*
 * Ensure that argumentdef blocks don't overflow algorithm section borders. This is made far harder
 * than it needs to be because the top-level W3C stylesheet has several @media + min-width variants
 * that mark themselves as !important and then proceed to do the wrong thing.
 */
@media screen and (min-width: 78em) {
    body:not(.toc-inline) .algorithm .overlarge {
        margin-right: auto !important;
    }
}
@media screen and (min-width: 90em) {
    body:not(.toc-inline) .algorithm .overlarge {
        margin-right: auto !important;
    }
}
.algorithm .overlarge {
    margin-right: auto !important;
}

/*
 * The default argumentdef style has a caption that doesn't suit this spec's
 * formatting particularly well. Hide it.
 */
.algorithm .argumentdef {
    margin-top: 0;
}
.algorithm .argumentdef > caption {
    display: none;
}

/*
 * Argumentdef is also too wide given our typenames, so make some tweaks.
 */
/* Move border to tr and reduce padding. */
.algorithm .argumentdef td,
.algorithm .argumentdef th {
    padding: .5em;
    border: none;
}
.algorithm .argumentdef > tbody > tr {
    border-top: thin solid var(--datacell-border);
}
/* Compress "Nullable" and "Optional" and remove horizontal padding. */
.algorithm .argumentdef > thead > tr > :nth-child(3),
.algorithm .argumentdef > thead > tr > :nth-child(4) {
    font-family: monospace;
    max-width: 4ch;
    word-wrap: break-word;
}
.algorithm .argumentdef tr > :nth-child(3),
.algorithm .argumentdef tr > :nth-child(4) {
    padding-left: .5em;
    padding-right: 0;
}

/* Wrap Parameter and Type onto separate rows. */
.algorithm .argumentdef > thead > tr > th:nth-child(1),
.algorithm .argumentdef > tbody > tr > td:nth-child(1) {
    padding-right: .5em;
    float: left;
}
.algorithm .argumentdef > thead > tr > th:nth-child(2),
.algorithm .argumentdef > tbody > tr > td:nth-child(2) {
    padding-left: .5em;
    float: right;
}
.algorithm .argumentdef > thead > tr > th {
    vertical-align: top;
}

/*
 * Add vertical lines to demarcate multi-column cells.
 */
table.data td,
table.data th {
    /* Only one side is needed because there are no outer borders on the tables.
     * 186 is perceptual 50% gray, so works for both light and dark modes. */
    border-left: 1px solid rgb(186 186 186 / 30%);
}

table.data.no-colspan-center td[colspan],
table.data.no-colspan-center th[colspan] {
    text-align: unset;
}

table.data tr.row-continuation td,
table.data tr.row-continuation th {
    border-top: none;
}

/*
 * Vertical class for table columns. (Can't use th.vertical because of a Safari bug.)
 */
span.vertical {
    writing-mode: vertical-rl;
    white-space: nowrap;
}

/*
 * Sticky table headers.
 */
.overlarge {
    /* position: sticky doesn't work inside scrollable elements. */
    overflow-x: unset;
}
thead.stickyheader th, th.stickyheader {
    position: sticky;
    top: 0;
    background: #f8f8f8;
    background: var(--stickyheader-background);
}

/*
 * Light-mode and dark-mode colors
 */
:root {
    --watermark-text: rgba(0, 0, 0, 15%);
    --stickyheader-background: #f8f8f8;
    --tint-red: rgba(255, 0, 0, 6%);
    --tint-green: rgba(0, 255, 0, 10%);
    --tint-blue: rgba(0, 0, 255, 5%);
    --tint-purple: rgba(255, 0, 255, 5%);
    --note-editorial-border: #ffa500;
    --note-editorial-bg: #ffeedd;
}
@media (prefers-color-scheme:dark) {
    :root {
        --watermark-text: rgba(255, 255, 255, 25%);
        --stickyheader-background: #181818;
        --tint-red: rgba(255, 0, 0, 20%);
        --tint-green: rgba(0, 255, 0, 18%);
        --tint-blue: rgba(0, 130, 255, 24%);
        --tint-purple: rgba(255, 0, 255, 22%);
        --note-editorial-border: #ffa500;
        --note-editorial-bg: var(--borderedblock-bg);
    }
}
</style>

# 介绍 # {#intro}

*This section is non-normative.*

[图形处理单元](https://en.wikipedia.org/wiki/Graphics_processing_unit)，简称GPU，一直以来都是个人计算中实现丰富渲染和计算应用的关键部件。
WebGPU是一个将GPU硬件功能暴露给Web的API。该API从零开始设计，以便有效地映射到（2014年后的）原生GPU API。
WebGPU与[WebGL](https://www.khronos.org/webgl/)无关，也没有显式地针对OpenGL ES。

WebGPU将物理GPU硬件视为{{GPUAdapter}}s。它通过{{GPUDevice}}提供与适配器的连接，管理资源和设备的{{GPUQueue}}s，执行命令。{{GPUDevice}}可能具有自己的内存，并可高速访问处理单元。{{GPUBuffer}}和{{GPUTexture}}是由GPU内存支持的<dfn dfn>物理资源</dfn>。{{GPUCommandBuffer}}和{{GPURenderBundle}}是用户记录命令的容器。{{GPUShaderModule}}包含[=着色器=]代码。其他资源，如{{GPUSampler}}或{{GPUBindGroup}}，配置了GPU使用[=物理资源=]的方式。

GPU通过将数据通过[=管线=]来执行{{GPUCommandBuffer}}中编码的命令，这是固定功能和可编程阶段的混合。可编程阶段执行<dfn dfn>着色器</dfn>，这些着色器是专为在GPU硬件上运行而设计的特殊程序。 [=pipeline=]的大部分状态由{{GPURenderPipeline}}或{{GPUComputePipeline}}对象定义。这些[=管线=]对象中未包含的状态在编码时通过命令设置，例如{{GPUCommandEncoder/beginRenderPass()}}或{{GPURenderPassEncoder/setBlendConstant()}}。

# 恶意使用注意事项 # {#malicious-use}

*本节内容为非标准的* 本节描述了在 Web 上公开此 API 相关的风险

## 安全 ## {#security-considerations}

WebGPU的安全性要求与Web的要求相同，同样也是不容妥协的。总体方法是在命令到达GPU之前严格验证所有的命令，确保页面只能处理其自己的数据。

### 基于 CPU 的未定义行为 ### {#security-cpu-ub}

WebGPU实现将用户提出的工作负载转换为针对目标平台的特定API命令。原生API为命令指定有效用法（例如，参见vkCreateDescriptorSetLayout(https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/vkCreateDescriptorSetLayout.html))，通常情况下，如果不遵循有效用法规则，则不能保证任何结果。这被称为“未定义行为”，攻击者可能利用这一行为访问他们无权访问的内存，或迫使驱动程序执行任意代码。

为了禁止不安全的使用，定义了允许的WebGPU行为范围。实现必须验证用户的所有输入，并仅在有效工作负载下达到驱动程序。这份文档详细说明了所有错误条件及处理语义。例如，在{{GPUCommandEncoder/copyBufferToBuffer()}}的“源”和“目标”中同时指定具有相交范围的相同缓冲区，将导致{{GPUCommandEncoder}}产生错误，并且不会发生其他操作。

有关错误处理的更多信息，请参阅[[#errors-and-debugging]]。

### 基于 GPU 的未定义行为 ### {#security-gpu-ub}

WebGPU [=着色器=]在GPU硬件内部的计算单元中执行。在原生API中，一些着色器指令可能导致GPU上的未定义行为。为了解决这个问题，WebGPU严格定义了着色器指令集及其定义的行为。当着色器提供给{{GPUDevice/createShaderModule()}}时，WebGPU实现必须在进行任何转换（至特定平台的着色器）或变换过程之前对其进行验证。

### 未初始化的数据 ### {#security-uninitialized}

通常，分配新内存可能暴露其他在系统上运行的应用程序的残留数据。为解决这一问题，WebGPU在概念上将所有资源初始化为零，尽管在实践中，如果实现发现开发者手动初始化内容，则可以跳过此步骤。这包括着色器内的变量和共享工作组内存。


清除工作组内存的确切机制可能因平台而异。如果原生API没有提供清除它的功能，WebGPU实现将计算着色器转换为首先在所有调用中执行清除操作，然后同步它们，并继续执行开发者的代码。

<div class=note>
    注：
    在队列操作中使用的资源的初始化状态只能在操作入队时（例如，不是在编码到命令缓冲区时）获知。因此，一些实现将需要在入队时进行非优化的迟清除操作（例如，清除纹理，而不是将{{GPULoadOp}} {{GPULoadOp/“load”}}更改为{{GPULoadOp/“clear”}}）。

    因此，所有实现**应该**在开发者控制台中发出关于这种潜在性能损失的警告，即使在该实现中没有损失。
</div>

### 着色器中的越界访问 ### {#security-shader}
[=着色器=]可以直接访问[=物理资源=]（例如，作为{{GPUBufferBindingType/“uniform”}} {{GPUBufferBinding}}），或通过<dfn dfn>纹理单元</dfn>访问，纹理单元是固定功能硬件块，负责处理纹理坐标转换。WebGPU API中的验证只能保证提供了着色器的所有输入，并且它们具有正确的用法和类型。如果未涉及[=纹理单元=]，WebGPU API无法保证数据在边界内访问。

为了防止着色器访问应用程序不拥有的GPU内存，WebGPU实现可能会在驱动程序中启用一种特殊模式（称为“稳健缓冲区访问”），以保证访问仅限于缓冲区边界。

或者，实现可以通过插入手动边界检查来转换着色器代码。当采用这种方法时，越界检查仅适用于数组索引。由于主机端的{{GPUBufferBindingLayout/minBindingSize}}验证，不需要对着色器结构的简单字段访问进行额外的边界检查。

如果着色器尝试在[=物理资源=]边界之外加载数据，实现可以执行以下操作：

1. 返回资源边界内的其他位置的值
1. 返回"(0, 0, 0, X)"的值向量，其中X可以是任何值
1. 部分丢弃绘制或调度调用

如果着色器尝试在[=物理资源=]边界之外写入数据，实现可以执行以下操作：

1. 将值写入资源边界内的其他位置
1. 丢弃写入操作
1. 部分丢弃绘制或调度调用

### 无效数据 ### {#security-invalid-data}

在将[浮点数](https://en.wikipedia.org/wiki/IEEE_754)数据从CPU上传至GPU，或在GPU上生成这些数据时，我们可能得到一个并不对应于有效数字的二进制表示，例如无穷大或NaN（非数字）。在这种情况下，GPU的行为取决于GPU硬件对IEEE-754标准的实现准确性。WebGPU保证引入无效浮点数只会影响算术计算的结果，不会产生其他副作用。

### 驱动程序错误 ### {#security-driver-bugs}

GPU驱动程序和其他软件一样，可能会受到错误的影响。如果出现错误，攻击者可能会利用驱动程序的错误行为来获取未授权的数据。为了降低风险，WebGPU工作组将与GPU供应商合作，将WebGPU Conformance Test Suite（CTS）集成到他们的驱动程序测试流程中，就像对WebGL所做的那样。

WebGPU实现预计会针对发现的一些错误进行修复，并在无法修复的已知错误的驱动程序上禁用WebGPU。

### 定时攻击 ### {#security-timing}

WebGPU被设计为通过Web Workers支持多线程使用。因此，它旨在不让用户面临现代高精度定时攻击。一些对象，如{{GPUBuffer}}或{{GPUQueue}}，具有可以同时访问的共享状态。这可能导致类似于从多个Web Workers访问SharedArrayBuffer的竞态条件，从而使线程调度可观察。

WebGPU通过限制只能对[=代理=]内的[=代理集群=]进行反序列化（或共享）对象的能力来解决这个问题，并且只有在启用[cross-origin isolated](https://web.dev/coop-coep/)策略时才有效。这种限制与防止恶意 `SharedArrayBuffer` 使用的[mitigations](https://hacks.mozilla.org/2020/07/safely-reviving-shared-memory/)相匹配。同样，用户代理也可以序列化共享任何句柄的[=代理=]，以完全阻止任何并发。

最后，在WebGPU中共享状态的竞争攻击面将是 `SharedArrayBuffer` 攻击的一个小子集。

WebGPU还指定了{{GPUFeatureName/“timestamp-query”}}功能，该功能可以提供GPU操作的高精度计时。该功能是可选的，WebGPU实现可能仅限于仅将其暴露给受信任的场景。或者，计时查询结果可以由计算着色器处理并与较低精度对齐。

### 行锤攻击 ### {#security-rowhammer}

[Row hammer](https://en.wikipedia.org/wiki/Row_hammer)是一类利用DRAM单元中状态泄漏的攻击。它可以在GPU(https://www.vusec.net/projects/glitch/)上使用。WebGPU没有任何特定的缓解措施，而是依赖于平台级解决方案，例如减少内存刷新间隔。

### 拒绝服务 ### {#security-dos}

WebGPU应用程序可以访问GPU内存和计算单元。WebGPU实现可能会限制应用程序可用的GPU内存，以保持其他应用程序的响应。对于GPU处理时间，WebGPU实现可以设置"看门狗"定时器，确保应用程序不会导致GPU在几秒钟内无响应。这些措施与WebGL中使用的措施类似。

### 工作负载识别 ### {#security-workload-identification}

WebGPU 提供对在同一机器上运行的不同程序（和网页）之间共享的受限全局资源的访问。应用程序可以尝试间接探测这些全局资源的约束程度，以便根据这些共享资源的使用模式推断其他打开的网页所执行的工作负载。这些问题通常类似于Javascript的问题，例如系统内存和CPU执行吞吐量。WebGPU 没有为此提供任何额外的缓解措施。

### 内存资源 ### {#security-memory-resources}

WebGPU公开了来自机器全局内存堆（如显存）的可失败分配。这允许通过尝试分配并观察分配失败来探测系统剩余可用内存的大小（对于给定的堆类型）。

内部的GPU通常具有一个或多个（通常只有两个）供所有运行应用程序共享的内存堆。当堆耗尽时，WebGPU将无法创建资源。这是可观察的，这可能允许恶意应用程序猜测其他应用程序使用哪些堆，以及它们从这些堆中分配了多少内存。

虽然这种信息可能被滥用，但要解决这个问题并不容易。WebGPU实现可能会采用一些策略来降低此问题带来的风险，如限制应用程序可用的内存和计算资源，从而保持其他应用程序的响应性。但是，这种策略并不能完全解决问题，因为恶意应用程序仍然可以通过观察资源分配失败来获取有关系统内存堆的信息。

总之，尽管WebGPU暴露了这种潜在的攻击途径，但开发者和用户仍需要保持警惕，并致力于在应用程序安全和系统资源管理方面进行持续改进。

### 计算资源 ### {#security-computation-resources}

如果一个网站与另一个网站同时使用WebGPU，它可能会注意到处理某些工作所需的时间增加。例如，如果一个网站不断提交计算工作负载并跟踪队列上的工作完成情况，它可能会注意到还有其他内容开始使用GPU。

GPU有许多可以独立测试的部分，如算术单元、纹理采样单元、原子单元等。恶意应用程序可能会感知到其中一些单元所受到的压力，并尝试通过分析压力模式来猜测另一个应用程序的工作负载。这类似于Javascript在CPU执行的现实情况。

要解决此问题并不容易，WebGPU 可能无法提供针对此类信息泄露的特定缓解措施。然而，开发者和用户仍可保持警惕并实施最佳实践，以确保应用程序安全并最大程度地减小潜在风险。这可能包括限制或屏蔽一些具有潜在危险性的GPU功能，或在系统和应用程序之间实施严格的资源隔离。

### 功能滥用 ### {#security-abuse-of-capabilities}

恶意网站可能会滥用WebGPU公开的功能来运行对用户或用户体验没有益处的计算，而仅仅是为了网站自身的利益。例如，隐藏式的加密货币挖矿、密码破解或彩虹表计算。

由于浏览器无法区分有效工作负载和滥用工作负载，因此无法防范这类API使用。这是Web上所有通用计算功能的普遍问题：JavaScript，WebAssembly或WebGL。WebGPU只是使一些工作负载更容易实现或稍微比使用WebGL更高效地运行。

为了缓解这种滥用形式，浏览器可以限制对后台标签页的操作，警告某个标签页使用了大量资源，并限制允许使用WebGPU的上下文。

用户代理可以启发式地向用户发出关于高功耗使用的警告，特别是可能存在恶意使用。如果用户代理实现这种警告，在启发式中应包括WebGPU的使用，以及JavaScript、WebAssembly、WebGL等。

## 隐私 ## {#privacy-considerations}

<p tracking-vector>
WebGPU的隐私考虑与WebGL相似。出于使开发者能有效利用这些功能的必要性，GPU API 需要复杂地暴露设备功能的各个方面。一般的缓解方法包括归一化或将潜在的识别信息分组，并在可能的情况下强制实施统一的行为。

用户代理不得透露超过32个可区分的配置或桶。

### 特定于机器的功能和限制 ### {#privacy-machine-limits}

WebGPU可以揭示底层GPU架构和设备几何的许多细节。这包括可用的物理适配器，GPU和CPU资源可使用的许多限制（如最大纹理尺寸）以及可用的任何可选硬件特定功能。

用户代理没有义务公开真正的硬件限制，他们完全掌控如何公开机器特定信息。减少指纹识别的一种策略是将所有目标平台分为少数几类。总的来说，公开硬件限制对隐私的影响与WebGL相匹配。

[=limit/默认=]限制也故意设定得足够高，以允许大多数应用程序在不请求更高限制的情况下工作。按照所请求的限制对API的所有使用情况进行验证，因此实际的硬件能力不会意外地暴露给用户。

### 特定于机器的工件 ### {#privacy-machine-artifacts}

有些机器特定的光栅化/精度伪像和性能差异可以大致以与WebGL相同的方式观察到。这适用于光栅化覆盖和模式、着色器阶段之间变化的插值精度、计算单元调度以及执行的更多方面。

通常情况下，光栅化和精度指纹在每个供应商的大部分或所有设备之间是相同的。性能差异相对难以解决，但也相对信号较低（就像JS执行性能一样）。

对隐私至关重要的应用程序和用户代理应使用软件实现来消除此类伪像。

### 机器特定性能 ### {#privacy-machine-performance}

另一个区分用户的因素是测量GPU上特定操作的性能。即使在低精度计时下，通过重复执行某个操作也可以显示出用户的设备在特定工作负载上的运行速度。这是一个相当常见的向量（在WebGL和Javascript中都存在），但信号较低，而且实际上很难进行真正的归一化。

WebGPU计算管线能够在不受固定功能硬件限制的情况下访问GPU。这对于唯一设备指纹识别带来了额外的风险。用户代理可以采取措施将逻辑GPU调用与实际计算单元分离，以降低这种风险。

### 用户代理状态 ### {#privacy-user-agent-state}

本规范没有为一个源定义任何额外的用户代理状态。然而，预计用户代理将有编译缓存，用于昂贵的编译结果，如 {{GPUShaderModule}}，{{GPURenderPipeline}} 和 {{GPUComputePipeline}}。这些缓存对于在首次访问后提高WebGPU应用程序的加载时间非常重要。

对于规范来说，这些缓存与非常快速的编译无法区分，但对于应用程序来说，很容易测量 {{GPUDevice/createComputePipelineAsync()}} 所需的解析时间。这可能在源之间泄漏信息（例如 “用户是否访问了具有此特定着色器的站点”），所以用户代理应该遵循[存储分区](https://github.com/privacycg/storage-partitioning)的最佳实践。

系统的GPU驱动程序也可能拥有自己的编译着色器和管线缓存。用户代理可能希望尽可能禁用这些功能，或者以使GPU驱动程序将它们视为不同的方式向着色器中添加每个分区的数据。

### 驱动程序错误 ### {#privacy-driver-bugs}

除了[[#security-driver-bugs|安全]]中概述的问题外，驱动程序错误可能引入行为差异，这可以作为一种区分用户的方法来观察。在这里同样适用于安全性考虑中提到的缓解措施，包括与GPU供应商协调以及在用户代理中针对已知问题实施解决方案。通过这些措施，可以最大限度地降低因驱动程序错误导致的安全风险，确保WebGPU应用及相关用户的安全性。

### 适配器标识符 ### {#privacy-adapter-identifiers}

根据WebGL的过往经验，开发者确实需要能识别其代码运行在哪个GPU上，以便创建和维护稳健的GPU基础内容。例如，识别具有已知驱动程序错误的适配器以解决它们，或避免在给定类别的硬件上性能低于预期的功能。

但是，公开适配器标识符也自然地扩大了可用的指纹信息量，因此有必要限制识别适配器的精度。

可以应用多种缓解措施来在实现稳健内容和保护隐私之间达到平衡。首先，用户代理可以通过识别和解决已知驱动程序问题来减轻开发者的负担，自从浏览器开始使用GPU以来就一直有这样做。

当默认公开适配器标识符时，它们应尽可能宽泛地有用。例如，可能识别适配器的供应商和一般架构，而不识别正在使用的特定适配器。同样，在某些情况下，可能会报告被认为是实际适配器合理代理的适配器标识符。

在完整且详细的适配器信息有用的情况下（例如：提交错误报告时），可以要求用户同意向页面透露有关其硬件的更多信息。

最后，如果用户代理认为适当（如在增强隐私模式下），它将始终有权自行决定是否报告适配器标识符。

# 基本概念 # {#fundamentals}

## 公约 ## {#api-conventions}

### 语法速记 ### {#shorthands}

在本规范中，使用以下语法简写：
: . (“dot”) 语法，在编程语言中很常见。
:: 
    术语 " Foo.Bar "的含义是 “值（或接口）Foo 的 Bar 成员”。
    术语 " Foo.Bar 是 [=map/存在|提供=]" 的含义是 " Bar 成员在 [=map=] 值 Foo 中存在"。

: 从 JavaScript 中采用的 ?. (“可选链”) 语法。
:: 
    术语 " Foo?.Bar "的含义是 “如果 Foo 是 null 或 undefined，或者 Bar 在 Foo 中不存在，那么返回 undefined；否则，返回Foo.Bar”。

    例如，在 buffer 是一个 {{GPUBuffer}} 的情况下，buffer?.\[[device]].\[[adapter]] 的含义是 "如果 buffer 是 null 或 undefined，那么返回 undefined；否则，返回 buffer 的 \[[device]] 内部槽中的 \[[adapter]] 内部槽。

: 从 JavaScript 中采用的 ?? (“空值合并”) 语法。
::
    术语 " x ?? y "的含义是 “如果 x 不是 null/undefined, 则返回 x，否则返回 y”。

: <dfn dfn>槽支持的属性</dfn>
::
    由相同名称的内部槽支持的 WebIDL 属性。它可能是可变的，也可能是不可变的。


### WebGPU 接口 ### {#webgpu-interfaces}

<dfn dfn>WebGPU接口</dfn>定义了一个WebGPU对象。它可以用于：

在它被创建的[=内容时间线=]上，它是一个JavaScript公开的WebIDL接口。
在所有其他时间线上，只能访问[=不可变属性=]。

以下特殊属性类型可以在[=WebGPU接口=]上定义：

: <dfn dfn data-timeline=const>不可变属性</dfn>
::
    一个在对象初始化期间设置的只读槽。它可以从任何时间线访问。

    注：由于槽是不可变的，实现可以在多个时间线上根据需要拥有一个副本。[=不可变属性=] 的定义就是这样，以避免在本规范中描述多个副本。

    如果名为 `[[with brackets]]`, 它就是一个内部槽。
    如果名为 `withoutBrackets`, 它是一个 `只读` [=槽支持的属性=]。

: <dfn dfn data-timeline=content>内容时间线属性</dfn>
::
    一个只能从创建对象的[=内容时间线=]上访问的属性。

    如果名为 `[[with brackets]]`，它就是一个内部槽。
    如果名为 `withoutBrackets`，它是一个 [=槽支持的属性=]。

任何包含<dfn interface>GPUObjectBase</dfn>的接口都是一个[=WebGPU接口=]。

<script type=idl>
interface mixin GPUObjectBase {
    attribute USVString label;
};
</script>

<div algorithm>
    <div data-timeline=content>
        要<dfn abstract-op>创建一个新的WebGPU对象</dfn>({{GPUObjectBase}} |parent|, 接口 |T|, {{GPUObjectDescriptorBase}} |descriptor|)(其中 |T| 继承自 {{GPUObjectBase}}):

        1. 让 |device| 成为 |parent|.{{GPUObjectBase/[[device]]}}。
        1. 让 |object| 成为 |T| 的一个新实例。
        1. 让 |internals| 成为 |T| 类型的 `\[[internals]]`（可能会覆盖 {{GPUObjectBase}}.{{GPUObjectBase/[[internals]]}}）的新（未初始化）实例，且只能从 |device| 的 [=设备时间线=] 上访问。
        1. 设置 |object|.{{GPUObjectBase/[[device]]}} 为 |device|。
        1. 设置 |object|.{{GPUObjectBase/[[internals]]}} 为 |internals|。
        1. 设置 |object|.{{GPUObjectBase/label}} 为 |descriptor|.{{GPUObjectDescriptorBase/label}}。
        1. 返回 [|object|, |internals|]。
    </div>
</div>

{{GPUObjectBase}}具有以下[=不可变属性=]：

<dl dfn-type=attribute dfn-for=GPUObjectBase data-timeline=const>
    : <dfn>\[[internals]]</dfn>, 类型为 [=内部对象=]，只读，可覆盖
    ::
        [=内部对象=]。

        对该对象内容的操作需要[=断言=]他们正运行在 [=设备时间线=] 上，且设备是 [=有效=]的。

        对于每个子类型化 {{GPUObjectBase}} 的接口，它可以使用 [=内部对象=] 的子类型进行覆盖。此槽最初设置为该类型的未初始化对象。

    : <dfn>\[[device]]</dfn>, 类型为 [=设备=]，只读。
    ::
        拥有 [=内部对象=] 的 [=设备=]。

        对此对象内容的操作需要[=断言=]它们正在 [=设备时间线=] 上运行，且设备是 [=有效=]的。
</dl>

{{GPUObjectBase}} 具有以下 [=内容时间线属性=]：

<dl dfn-type=attribute dfn-for=GPUObjectBase data-timeline=content>
    : <dfn>label</dfn>
    ::
        一个由开发者提供的标签，以实现定义的方式使用。它可以被浏览器、操作系统或其他工具用于帮助开发者识别底层的 [=内部对象=]。示例包括在 {{GPUError}} 消息、控制台警告、浏览器开发者工具和平台调试实用程序中显示标签。

        <div class=note>
            注：
            {{GPUObjectBase/label}} 是 {{GPUObjectBase}} 的一个属性。两个 {{GPUObjectBase}} “包装器” 对象具有完全独立的标签状态，即使它们引用相同的底层对象（例如通过 {{GPUPipelineBase/getBindGroupLayout()}} 返回的对象）。{{GPUObjectBase/label}} 属性除了从JavaScript设置之外不会改变。

            这意味着一个底层对象可以与多个标签关联。此规范未定义标签如何传播到 [=设备时间线=] 上。标签的使用完全由实现定义：错误消息可能显示最近设置的标签、所有已知标签或根本不显示标签。

            该属性定义为 {{USVString}}，因为某些用户代理可能会将其提供给底层原生 API 的调试工具。
        </div>
</dl>

<div class=note>
    注：
    理想情况下，[=WebGPU 接口=]不应阻止它们的父对象（例如拥有它们的 {{GPUObjectBase/[[device]]}}）被垃圾收集。然而，这不能得到保证，因为在某些实现中可能需要持有对父对象的强引用。

    因此，开发者应该假设，除非该接口的所有子对象也被垃圾收集，否则 [=WebGPU 接口=] 可能不会被垃圾回收。这可能导致某些资源分配的时间比预期更长。

    如果需要可预测地释放已分配的资源，应优先调用 [=WebGPU 接口=]上的 `destroy` 方法（例如 {{GPUDevice}}.{{GPUDevice/destroy()}} 或 {{GPUBuffer}}.{{GPUBuffer/destroy()}}），而不是依赖垃圾收集。
</div>

### 内部对象 ### {#webgpu-internal-objects}

<dfn dfn>内部对象</dfn> 跟踪可能仅在 [=设备时间线=]上使用的WebGPU对象的状态，在 [=设备时间线插槽=] 中，这些槽可能是可变的。

: <dfn dfn data-timeline=device>设备时间线插槽</dfn>
::
    一个仅从 [=设备时间线=] 可访问的内部插槽。

    所有对 [=内部对象=] 的可变状态的读/写操作都发生在单个严格有序的 [=设备时间线=] 上执行的步骤中。这些步骤可能来自多个 [=代理=] 上的任何一个 [=内容时间线=] 算法。

    注：" [=代理=]" 是指JavaScript的 “线程”（即主线程或Web Worker）。


### 对象描述符 ### {#object-descriptors}

一个<dfn dfn>对象描述符</dfn>包含了创建对象所需的信息，这通常是通过{{GPUDevice}}的 `create*` 方法之一来完成的。

<script type=idl>
dictionary GPUObjectDescriptorBase {
    USVString label;
};
</script>

{{GPUObjectDescriptorBase}} has the following members:

<dl dfn-type=dict-member dfn-for=GPUObjectDescriptorBase>
    : <dfn>label</dfn>
    ::
        {{GPUObjectBase/label|GPUObjectBase.label}}的初始值。
</dl>

## 异步性 ## {#asynchrony}

### 无效的内部对象 &amp; 具有传染性的无效性 ### {#invalidity}

在WebGPU中，对象创建操作不返回promise，但实际上是内部异步的。返回的对象引用的是在[=设备时间线=]上操作的[=内部对象=]。大多数发生在[=设备时间线=]上的错误不会通过异常或拒绝失败，而是通过与相关联的[=设备=]生成的{{GPUError}}进行通信。

[=内部对象=]要么<dfn dfn>有效</dfn>，要么<dfn dfn>无效</dfn>。
一个[=无效=]的对象将永远不会在以后变得[=有效=]，但一些[=有效=]的对象可能会变成[=无效=]。

如果无法创建对象，那么对象将从创建时开始就是[=无效=]的。例如，这可能是因为[=对象描述符=]没有描述一个有效对象，或者没有足够的内存来分配资源。

绝大多数类型的[=内部对象=]在创建后不能变[=无效=]，但仍可能变得不可用，例如，如果拥有的设备变为[=设备丢失|丢失=]或者{{GPUDevice/destroy()|销毁}}，或者对象具有特殊的内部状态，如缓冲区状态"[=buffer内部/状态/销毁=]"。

某些类型的[=内部对象=]在创建后可以变为[=无效=]；具体来说，这些类型包括[=设备=]、[=适配器=]、{{GPUCommandBuffer}}和命令/通道/包编码器。

<div algorithm>
    给定的{{GPUObjectBase}} |对象| 只有在满足以下要求时，才被认为是<dfn abstract-op>可用于</dfn>与 |targetObject| 一起使用的：

    <div class=validusage>
        - |对象| 必须是 [=有效=]的。
        - |对象|.{{GPUObjectBase/[[device]]}} 必须是 [=有效=]的。
        - |对象|.{{GPUObjectBase/[[device]]}} 必须等于 |目标对象|.{{GPUObjectBase/[[device]]}}。
    </div>
</div>

### Promise 排序 ### {#promise-ordering}

在WebGPU中，有几个操作会返回promises。

- {{GPU}}.{{GPU/requestAdapter()}}
- {{GPUAdapter}}.{{GPUAdapter/requestDevice()}}
- {{GPUAdapter}}.{{GPUAdapter/requestAdapterInfo()}}
- {{GPUDevice}}.{{GPUDevice/createComputePipelineAsync()}}
- {{GPUDevice}}.{{GPUDevice/createRenderPipelineAsync()}}
- {{GPUBuffer}}.{{GPUBuffer/mapAsync()}}
- {{GPUShaderModule}}.{{GPUShaderModule/getCompilationInfo()}}
- {{GPUQueue}}.{{GPUQueue/onSubmittedWorkDone()}}
- {{GPUDevice}}.{{GPUDevice/lost}}
- {{GPUDevice}}.{{GPUDevice/popErrorScope()}}

WebGPU不对这些promises的解决顺序（resolve或reject）做任何保证，除了以下情况：

- <div algorithm="mapAsync-onSubmittedWorkDone ordering">
    如果在 |p2| = |q|.{{GPUQueue/onSubmittedWorkDone()}} 被调用之前调用了 |p1| = |b|.{{GPUBuffer/mapAsync()}}，并且 |b| 最后一次是仅在 |q| 上使用的，那么 |p2| 在 |p1| 解析之前不得解析。
    </div>

应用程序不能依赖于其他任何promise解决顺序。

## 坐标系统 ## {#coordinate-systems}

- 在归一化设备坐标（NDC）中，Y轴是向上的：在NDC中，点(-1.0, -1.0)位于NDC的左下角。 此外，NDC中的x和y应在-1.0和1.0（含）之间，而NDC中的z应在0.0和1.0（含）之间。 在NDC范围之外的顶点不会引入任何错误，但它们会被剪裁。
- 在 [=framebuffer=] 坐标、视口坐标和片段/像素坐标中，Y轴是向下的： 在这些坐标系中，原点(0, 0)位于左上角。
- 窗口/呈现坐标与 [=framebuffer=]坐标相匹配。
- 贴图坐标中原点(0, 0)的UV表示贴图内存中的第一个像素(最低字节)。

注：WebGPU 的坐标系在图形管线中与 DirectX 的坐标系相匹配。

## 编程模型 ## {#programming-model}

### 时间线 ### {#programming-model-timelines}

*本节为非规范性内容。*

一个带有用户代理前端和GPU后端的计算机系统中，各组件在不同的时间线上并行工作：

: <dfn dfn>内容时间线</dfn>
::
    与Web脚本的执行相关联。
    它包括调用本规范描述的所有方法。

    要从操作{{GPUDevice}} `device` 中向内容时间线发出步骤，请使用[$为GPUDevice排队全局任务$] `device`与这些步骤。

: <dfn dfn>设备时间线</dfn>
:: 与用户代理发出的GPU设备操作相关联。
    它包括创建适配器、设备和GPU资源以及状态对象，这些通常是从控制GPU的用户代理部分的角度来看同步操作，
    但可以在单独的操作系统进程中运行。

: <dfn dfn>队列时间线</dfn>
:: 与在GPU的计算单元上执行操作相关联。它包括在GPU上运行的实际绘制、复制和计算任务。

<div class=example style="background: var(--bg)">
    以下展示了与每个时间线相关联的步骤和值的样式。这种样式是非规范性的；规范文本始终描述关联。

    <dl data-timeline=const>
        : <dfn>不可变值示例定义</dfn>
        :: 可以在任何时间线上使用。
    </dl>

    <dl data-timeline=content>
        : <dfn>内容时间线示例定义</dfn>
        :: 仅可在内容时间线上使用。
    </dl>

    <dl data-timeline=device>
        : <dfn>设备时间线示例定义</dfn>
        :: 仅可在设备时间线上使用。
    </dl>

    <dl data-timeline=queue>
        : <dfn>队列时间线示例定义</dfn>
        :: 仅可在队列时间线上使用。
    </dl>

    <div class=algorithm>
        <div data-timeline=content>
            在[=内容时间线=]上执行的步骤看起来像这样。

            [=不可变值示例定义=].
            [=内容时间线示例定义=].
        </div>
        <div data-timeline=device>
            在[=设备时间线=]上执行的步骤看起来像这样。

            [=不可变值示例定义=].
            [=设备时间线示例定义=].
        </div>
        <div data-timeline=queue>
            在[=队列时间线=]上执行的步骤看起来像这样。

            [=不可变值示例定义=].
            [=队列时间线示例定义=].
        </div>
    </div>
</div>

在本规范中，当结果值取决于除 [=内容时间线=] 以外的任何时间轴上的工作时，将使用异步操作。它们在JavaScript中由回调和promises表示。

<div class=example>
    {{GPUComputePassEncoder/dispatchWorkgroups()|GPUComputePassEncoder.dispatchWorkgroups()}}:

    1. 用户通过调用{{GPUComputePassEncoder}}的方法在[=内容时间线=]上编码 `dispatchWorkgroups` 命令。
    1. 用户执行{{GPUQueue/submit(commandBuffers)|GPUQueue.submit()}} 将 {{GPUCommandBuffer}} 交给用户代理，用户代理在[=设备时间线=]上通过调用操作系统驱动程序进行底层提交来处理它。
    1. 提交由GPU调用调度器分派到实际计算单元上执行，发生在[=队列时间线=]上。
</div>

<div class=example>
    {{GPUDevice/createBuffer(descriptor)|GPUDevice.createBuffer()}}:

    1. 用户填写{{GPUBufferDescriptor}}，并用它创建一个{{GPUBuffer}}，发生在[=内容时间线=]上。
    1. 用户代理在[=设备时间线=]上创建一个低级别的缓冲区。
</div>

<div class=example>
    {{GPUBuffer/mapAsync()|GPUBuffer.mapAsync()}}:

    1. 用户在[=内容时间线=]上请求映射一个{{GPUBuffer}}，并获得一个 promise 作为返回。
    1. 用户代理检查缓冲区是否当前被GPU使用，并提醒自己在使用结束后检查。
    1. 在[=队列时间线=]上的GPU完成使用缓冲区后，用户代理将其映射到内存并[=解析=] promise。
</div>

### 内存模型 ### {#programming-model-memory}

*本节为非规范性内容。*

在应用程序初始化例程中获取到 {{GPUDevice}} 后，我们可以将 <dfn dfn>WebGPU平台</dfn> 描述为包含以下层：


1. 实现此规范的用户代理。
1. 具有此设备的低级本地API驱动程序的操作系统。
1. 实际的CPU和GPU硬件。

[=WebGPU平台=]的每一层可能有不同的内存类型，用户代理在实现规范时需要考虑：

脚本拥有的内存，例如由脚本创建的 {{ArrayBuffer}}，通常无法被GPU驱动程序访问。
用户代理可能有不同的进程负责运行内容和与GPU驱动程序通信。在这种情况下，它将使用进程间共享内存来传输数据。
独立GPU有高带宽的自己的内存，而集成GPU通常与系统共享内存。

大多数 [=物理资源=] 分配在类型为内存的GPU计算或渲染的效率上。当用户需要向GPU提供新数据时，数据可能首先需要跨越进程边界以到达与GPU驱动程序通信的用户代理部分。然后，可能需要使驱动程序可见，这有时需要将数据复制到驱动程序分配的寄存器内存中。最后，可能需要将其传输到专用GPU内存，可能将内部布局更改为GPU操作最有效的布局。

所有这些转换都由用户代理的WebGPU实现完成。

注：此示例描述了最坏情况，而实际上实现可能不需要跨越进程边界，或者可能能够将驱动程序管理的内存直接暴露给用户在 `ArrayBuffer` 后面，从而避免任何数据副本。


### 资源用途 ### {#programming-model-resource-usages}

一个[=物理资源=]可以在GPU上使用<dfn dfn>内部用途</dfn>：

<dl dfn-type=dfn dfn-for="internal usage">
    : <dfn>input</dfn>
    ::
        用于绘制或调度调用的输入数据缓冲区。保持内容不变。
        允许使用缓冲区 {{GPUBufferUsage/INDEX}}，缓冲区 {{GPUBufferUsage/VERTEX}} 或 缓冲区 {{GPUBufferUsage/INDIRECT}}。
    : <dfn>constant</dfn>
    ::
        从着色器角度来看，资源绑定是不变的。保持内容不变。
        允许使用缓冲区 {{GPUBufferUsage/UNIFORM}} 或纹理 {{GPUTextureUsage/TEXTURE_BINDING}}。
    : <dfn>storage</dfn>
    ::
        可写存储资源绑定。
        允许使用缓冲区 {{GPUBufferUsage/STORAGE}} 或纹理 {{GPUTextureUsage/STORAGE_BINDING}}。
    : <dfn>storage-read</dfn>
    ::
        只读存储资源绑定。保持内容不变。
        允许使用缓冲区 {{GPUBufferUsage/STORAGE}}。
    : <dfn>attachment</dfn>
    ::
        在渲染通道中用作输出附件的纹理。
        允许使用纹理 {{GPUTextureUsage/RENDER_ATTACHMENT}}。
    : <dfn>attachment-read</dfn>
    ::
        在渲染通道中用作只读附件的纹理。 保持内容不变。
        允许使用纹理 {{GPUTextureUsage/RENDER_ATTACHMENT}}。
</dl>

我们定义<dfn dfn>子资源</dfn>可以是整个缓冲区，也可以是一个[=纹理子资源=]。

<div algorithm="compatible usage list">
    一些 [=内部用途=] 是可以互相兼容的。 一个 [=子资源=] 可以处于将多个用途合并在一起的状态。 我们认为列表 |U| 是一个<dfn dfn>兼容用途列表</dfn>，如果（且仅当）它满足以下任意规则：

    - |U| 中的每个用途都是 [=内部用途/输入=]、[=内部用途/常量=]、[=内部用途/存储读=] 或 [=内部用途/附件读=]。
    - |U| 中的每个用途都是 [=内部用途/存储=]。
    - |U| 包含且只包含一个元素：[=内部用途/附件=]。
</div>

规定用途只能组合成[=兼容用途列表=]允许API在处理内存时限制数据竞争发生的时间。具有这种性质的应用程序在针对WebGPU编写时，更有可能在不同平台上无需修改即可运行。

通常，当实现处理一个使用 [=子资源=]的操作，以与其当前用途允许的不同方式时，它会调度资源转换到新状态。在某些情况下，例如在打开的 {{GPURenderPassEncoder}} 内，由于硬件限制，此类转换是不可能的。我们将这些地方定义为 <dfn dfn>用途范围</dfn>。

主要用途规则 是，对于任何一个 [=子资源=]，在一个 [=用途范围=] 中的 [=内部用途=] 列表必须是一个 [=兼容用途列表=]。

例如，在同一个 {{GPURenderPassEncoder}} 中将同一个缓冲区绑定为 [=内部用途/存储=] 和 [=内部用途/输入=]，会使编码器以及拥有的 {{GPUCommandEncoder}} 进入错误状态。这种用途组合不能构成一个 [=兼容用途列表=]。

注：在单个 [=用途范围=] 内多个可写存储缓冲区/纹理的使用之间的竞争条件是允许的。

提供给 {{GPURenderPassColorAttachment/view|GPURenderPassColorAttachment.view}} 和 {{GPURenderPassColorAttachment/resolveTarget|GPURenderPassColorAttachment.resolveTarget}} 的纹理的 [=子资源=] 被视为在此渲染通道的 [=用途范围=] 内作为 [=内部用途/附件=] 使用。

### 同步 ### {#programming-model-synchronization}

对于 [=物理资源=] 的每一个 [=子资源=]，其一组 [=内部使用=] 标志在 [=队列时间线=] 上进行跟踪。

<!-- POSTV1(多队列)：修订此部分 -->

在 [=队列时间线=] 上，有一个有序的 [=用途范围=] 序列。
在每个范围的持续时间内，任何给定的 [=子资源=] 的一组 [=内部用途=] 标志是恒定的。
在 [=用途范围=] 之间的边界处， [=子资源=] 可能会过渡到新的用途。

本规范定义了以下 [=用途范围=]：
- 在通道之外（在 {{GPUCommandEncoder}} 中），每个（非状态设置）命令都是一个使用范围（例如 {{GPUCommandEncoder/copyBufferToTexture()}}）。
- 在计算过程中，每个调度命令（{{GPUComputePassEncoder/dispatchWorkgroups()}} 或 {{GPUComputePassEncoder/dispatchWorkgroupsIndirect()}}) 是一个使用范围。
    如果命令可能访问子资源，则该子资源在使用范围内被“使用”。
    在调度中，对于当前 {{GPUComputePipeline}} 使用的每个绑定组插槽 {{GPUPipelineBase/[[layout]]}}，每个 [=subresource=] 被引用该绑定组在使用范围内被“使用”。
    状态设置计算通道命令，如[=GPUBindingCommandsMixin/setBindGroup()=],不直接对使用范围做出贡献；他们反而改变了在调度命令中检查的状态。
- 一个渲染通道是一个使用范围。
    如果子资源被任何引用，则它在使用范围内被“使用”（状态设置或非状态设置）命令。 例如，在[=GPUBindingCommandsMixin/setBindGroup()=],`bindGroup` 中的每个子资源都在渲染过程的使用范围内“使用”。

问题：上面应该大概讲的是[=GPU命令=]。但是我们没有办法参考特定的 GPU 命令（如分派）。

<div class=note>
注：
     上述规则意味着以下示例资源使用**包含在 [=usage scope validation=] 中：

     - 在渲染过程中，任何 [=GPUBindingCommandsMixin/setBindGroup()=] 调用中使用的子资源，无论当前绑定的管线的着色器或布局实际上是否依赖于这些绑定，或者绑定组是否被另一个“设置”调用隐藏。
     - 在任何 {{GPURenderCommandsMixin/setVertexBuffer()|setVertexBuffer()}} 调用中使用的缓冲区，无论是否有任何绘制调用依赖于此缓冲区，或者此缓冲区是否被另一个“设置”调用遮蔽。
     - 在任何 {{GPURenderCommandsMixin/setIndexBuffer()|setIndexBuffer()}} 调用中使用的缓冲区，无论是否有任何绘图调用依赖于此缓冲区，或者此缓冲区是否被另一个“设置”调用隐藏。
     - 由 {{GPUCommandEncoder/beginRenderPass()|beginRenderPass()}} 在 {{GPURenderPassDescriptor}} 中用作颜色附件、解析附件或深度/模板附件的纹理子资源，无论着色器是否实际依赖于这些附件。
     - 在可见性为 0 的绑定组条目中使用的资源，或者仅对计算阶段可见但在渲染过程中使用的资源（反之亦然）。
</div>

在命令编码期间，子资源的每次使用都记录在命令缓冲区的 [=usage scopes=] 之一中。
对于每个 [=适用范围=]，实现执行 <dfn dfn>适用范围验证</dfn> 通过组成 [=usage scope 中使用的每个 [=subresource=] 的所有 [=internal usage=] 标志的列表 =].
如果这些列表中的任何一个不是[=兼容用法列表=]，{{GPUCommandEncoder/finish()|GPUCommandEncoder.finish()}} 将[$生成验证错误$]。


## 核心内部对象 ## {#core-internal-objects}

### Adapters ### {#adapters}

<dfn dfn>适配器</dfn> 标识系统上 WebGPU 的实现：
既是浏览器底层平台上计算/渲染功能的实例，又是浏览器在该功能之上实现 WebGPU 的实例。

[=适配器=] 不唯一表示底层实现：
多次调用 {{GPU/requestAdapter()}} 每次都会返回不同的 [=adapter=] 对象。

每个 [=适配器=] 对象只能用于创建一个 [=device=]：
在 {{GPUAdapter/requestDevice()}} 成功后，适配器变为 [=无效=]。
此外，[=适配器=] 对象可以随时 [=适配器/过期=]。

注：
这确保应用程序在创建设备时使用最新的系统状态来选择适配器。
它还通过使它们看起来相似来鼓励对更多场景的鲁棒性：首次初始化、由于拔下适配器而重新初始化、由于测试 {{GPUDevice/destroy()|GPUDevice.destroy()}} 调用而重新初始化等。

如果 [=适配器=] 具有重要的性能警告以换取更广泛的兼容性、更可预测的行为或改进的隐私的某种组合，则它可以被视为 <dfn>后备适配器</dfn>。 [=fallback adapter=] 不需要在每个系统上都可用。

[=adapter=] 具有以下内部插槽：

<dl dfn-type=attribute dfn-for=adapter>
     : <dfn>\[[features]]</dfn>，类型为 [=ordered set=]<{{GPUFeatureName}}>，只读
     ::
         [=features=] 可用于在此适配器上创建设备。

     : <dfn>\[[limits]]</dfn>，类型为 [=supported limits=]，只读
     ::
         可用于在此适配器上创建设备的 [=limit/better|best=] 限制。

         每个适配器限制必须与 [=supported limits=] 中的默认值相同或 [=limit/better=]。

     : <dfn>\[[fallback]]</dfn>，布尔类型
     ::
         如果设置为“true”，则表示该适配器是 [=fallback adapter=]。

     : <dfn>\[[unmaskedIdentifiers]]</dfn>，类型为 [=ordered set=]&lt;{{DOMString}}&gt;
     ::
         用户代理已选择为此适配器报告的 {{GPUAdapterInfo}} 字段的名称列表。 最初填充了用户代理在未经用户同意的情况下选择报告的任何 {{GPUAdapterInfo}} 字段的名称。
</dl>

[=Adapters=] 通过 {{GPUAdapter}} 暴露出来。

### 设备 ### {#devices}

<dfn dfn>device</dfn> 是 [=适配器=] 的逻辑实例，通过它创建 [=内部对象=]。
它可以在多个 [=代理=] 之间共享（e.g. dedicated workers）。

[=设备=] 是从它创建的所有 [=内部对象=] 的独占所有者：
当 [=设备=] 变为 [=无效=]（是 [=lose the device|lost=] 或 {{GPUDevice/destroy()|destroyed}}）时，它和在其上创建的所有对象（直接，例如
{{GPUDevice/createTexture()}}，或间接地，例如 {{GPUTexture/createView()}}) 隐式变为 [$valid to use with|unusable$]。

[=device=] 具有以下内部插槽：

<dl dfn-type=attribute dfn-for=device>
     : <dfn>\[[适配器]]</dfn>，类型为 [=适配器=]，只读
     ::
         创建此设备的 [=适配器=]。

     : <dfn>\[[特性]]</dfn>，类型为 [=ordered set=]<{{GPUFeatureName}}>，只读
     ::
         可在此设备上使用的 [=特性=]。
         不能使用附加功能，即使底层 [=适配器=] 可以支持它们。

     : <dfn>\[[限制]]</dfn>，类型为 [=支持的限制=]，只读
     ::
         可在此设备上使用的限制。
         不能使用 [=限制/更好=] 限制，即使基础 [=适配器=] 可以支持它们。
</dl>

<分区算法>
     当<dfn dfn>一个新设备</dfn> |device| 从 [=adapter=] |adapter| 创建 使用 {{GPUDeviceDescriptor}} |描述符|: 

     - 将 |device|.{{device/[[adapter]]}} 设置为 |adapter|。

     - 将 |device|.{{device/[[features]]}} 设置为 [=ordered set|set=] 中的值
         |描述符|.{{GPUDeviceDescriptor/requiredFeatures}}。

     - 让 |device|.{{device/[[limits]]}} 成为具有默认值的 [=supported limits=] 对象。
         对于 |descriptor|.{{GPUDeviceDescriptor/requiredLimits}} 中的每个 (|key|, |value|) 对，设置
         |key|对应的成员 在 |device|.{{device/[[limits]]}} 到 |value| 的 [=limit/better=] 值 或 [=supported limits=] 中的默认值。
</div>

每当用户代理需要撤销对设备的访问权限时，它都会在设备的 [=device timeline=] 上调用 [=lose the device=](`device`, {{GPUDeviceLostReason/"unknown"}})，可能会提前 当前在该时间线上排队的其他操作。

如果操作失败并产生副作用，这些副作用会明显改变设备上对象的状态或可能破坏内部实现/驱动程序状态，则设备**应该**丢失以防止这些更改被观察到。

<div algorithm data-timeline=device>
     要<dfn dfn>丢失设备</dfn>（|设备|，|原因|）：

        1. 制作|设备| [=无效=]。
        1. 让|gpuDevice| 是对应于 |device| 的 [=内容时间线=] {{GPUDevice}}。

            问题：更严格地定义它。
        1. 在 |gpuDevice| 的 [=内容时间线=] 上执行以下步骤：
            <div 数据时间线=内容>
                1. 使用新的 {{GPUDeviceLostInfo}} 解决 |device|.{{GPUDevice/lost}} 并将 {{GPUDeviceLostInfo/reason}} 设置为 |reason| 和 {{GPUDeviceLostInfo/message}} 设置为实现定义的值。

                 注：{{GPUDeviceLostInfo/message}} 不应该泄露不必要的用户/系统信息，也不应该被应用程序解析。
            </div>
        1. 完成任何未完成的 {{GPUBuffer/mapAsync()}} 步骤。
        1. 完成任何未完成的 {{GPUQueue/onSubmittedWorkDone()}} 步骤。

        注：设备丢失后不会产生错误。 参见 [[#errors-and-debugging]]。
</div>

[=Devices=] 通过 {{GPUDevice}} 暴露出来。

## 可选功能 ## {#optional-capabilities}
WebGPU [=适配器=] 和 [=设备=] 具有 <dfn dfn>功能</dfn>，它描述了 WebGPU 功能在不同实现之间的差异，通常是由于硬件或系统软件限制。
[=功能=] 是 [=特性=] 或 [=限制=]。

用户代理不得透露超过 32 个可区分的配置或桶。

[=适配器=] 的能力必须符合 [[#adapter-capability-guarantees]]。

在 {{GPUAdapter/requestDevice()}} 中只能请求支持的功能； 请求不受支持的功能会导致失败。

[=设备=] 的功能正是在 {{GPUAdapter/requestDevice()}} 中请求的功能。 无论 [=适配器=] 的功能如何，这些功能都会被强制执行。

<p 跟踪向量>
有关隐私方面的考虑，请参阅 [[#privacy-machine-limits]]。

### 特性 ### {#features}

<dfn dfn>特性</dfn> 是一组可选的 WebGPU 功能，并非所有实现都支持这些功能，通常是由于硬件或系统软件限制。

只有在创建设备时请求了该功能（在 {{GPUDeviceDescriptor/requiredFeatures}} 中）时，才能使用作为功能一部分的功能。
否则，以新方式使用现有 API 表面**通常**会导致 [$validation error$]，而使用 <dfn dfn>optional API surfaces</dfn> 会导致以下结果：

- 使用新方法或枚举值总是会抛出 {{TypeError}}。
- 使用具有（正确键入的）非默认值的新字典成员**通常**会导致 [$validation error$]。
- 使用新的 WGSL `enable` 指令总是导致 {{GPUDevice/createShaderModule()}} [$validation error$]。

<分区算法>
     {{GPUFeatureName}} |feature| <dfn dfn>启用</dfn> {{GPUObjectBase}} |object| 当且仅当 |object|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}} [=列表/包含=] |feature|。
</div>

请参阅 [[#feature-index|Feature Index]] 了解每个功能启用的功能的描述。

### 限制 ### {#limits}

每个 <dfn dfn>限制</dfn> 都是对设备上 WebGPU 使用的数字限制。

每个限制都有一个 <dfn dfn for=limit>默认</dfn> 值。
每个 [=适配器=] 都保证支持默认值或 [=限制/更好=]。
如果未在 {{GPUDeviceDescriptor/requiredLimits}} 中明确指定值，则使用默认值。

一个极限值可能比另一个<dfn dfn for=limit>更好</dfn>。
[=限制/更好=] 限制值总是放宽验证，使更多的程序严格有效。 对于每个 [=限制类=]，定义了“更好”。

不同的极限有不同的<dfn dfn lt="限制类">极限等级</dfn>：

<dl dfn-type=dfn dfn-for="限制等级">
     : <dfn>最大</dfn>
     ::
         该限制对传递到 API 中的某些值强制执行最大值。

         更高的值是 [=限制/更好=]。

         只能设置为值 &ge; [=限制/默认=]。
         较低的值被限制在 [=限制/默认=]。

     : <dfn>对齐方式</dfn>
     ::
         该限制对传递给 API 的某些值强制执行最小对齐； 那是，
         该值必须是限制的倍数。

         较低的值是 [=限制/更好=]。

         只能设置为 2 的幂，即 &le; [=限制/默认=]。
         不是 2 的幂的值无效。
         2 的更高次幂被限制在 [=限制/默认=]。
</dl>

注：
设置“更好”的限制可能不一定是可取的，因为它们可能会对性能产生影响。
因此，为了提高跨设备和实现的可移植性，应用程序通常应该请求适用于其内容的“最差”限制（理想情况下，默认值）。

<dfn dfn>支持的限制</dfn> 对象对 WebGPU 定义的每个限制都有一个值：

<table class="data no-colspan-center" dfn-type=attribute dfn-for="supported limits">
    <thead>
        <tr><th>限制名称 <th>Type <th>[=Limit class=] <th>[=limit/Default=]
    </thead>

    <tr><td><dfn>maxTextureDimension1D</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>8192
    <tr class=row-continuation><td colspan=4>
        使用 {{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"1d"}} 创建的 [=texture=] 的 {{GPUTextureDescriptor/size}}.[=GPUExtent3D/width=] 的最大允许值。
    
    <tr><td><dfn>maxTextureDimension2D</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>8192
    <tr class=row-continuation><td colspan=4>
        {{GPUTextureDescriptor/size}}.[=GPUExtent3D/width=] 和 {{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"2d"}} 创建的 [=纹理=] 的 {{GPUTextureDescriptor/size}}.[=GPUExtent3D/height=] 所允许的最大值。

    <tr><td><dfn>maxTextureDimension3D</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>2048
    <tr class=row-continuation><td colspan=4>
        使用{{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"3d"}} 创建的 [=纹理=] 的 {{GPUTextureDescriptor/size}}.[=GPUExtent3D/width=], {{GPUTextureDescriptor/size}}.[=GPUExtent3D/height=] 和 {{GPUTextureDescriptor/size}}.[=GPUExtent3D/depthOrArrayLayers=] 最大值

    <tr><td><dfn>maxTextureArrayLayers</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>256
    <tr class=row-continuation><td colspan=4>
        通过 {{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"1d"}} 或 {{GPUTextureDimension/"2d"}} 创建的[=纹理=]，所允许的 {{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] 的最大值。
    <tr><td><dfn>maxBindGroups</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>4
    <tr class=row-continuation><td colspan=4>
        创建 {{GPUPipelineLayout}} 时，{{GPUPipelineLayoutDescriptor/bindGroupLayouts}} 中允许的 {{GPUBindGroupLayout|GPUBindGroupLayouts}} 最大值。

    <tr><td><dfn>maxBindGroupsPlusVertexBuffers</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>24
    <tr class=row-continuation><td colspan=4>
        同时使用的绑定组和顶点缓冲区槽的最大数量，计算最高索引以下的任何空槽。
        在 {{GPUDevice/createRenderPipeline()}} 和 [$valid to draw|in draw calls$] 中验证。

    <tr><td><dfn>maxBindingsPerBindGroup</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>1000
    <tr class=row-continuation><td colspan=4>
        创建 {{GPUBindGroupLayout}} 时可用的绑定索引数。

         注：这个限制是规范的，但是是任意的。
         默认情况下 [=超出绑定插槽限制|binding slot limits=]，不可能在一个绑定组中使用 1000 个绑定，但这允许 {{GPUBindGroupLayoutEntry}}.{{GPUBindGroupLayoutEntry/binding}} 值高达 999。
         此限制允许实现在合理的内存空间内将绑定空间视为数组，而不是稀疏映射结构。
    <tr><td><dfn>maxDynamicUniformBuffersPerPipelineLayout</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>8
    <tr class=row-continuation><td colspan=4>
        {{GPUPipelineLayout}} 中的最大 {{GPUBindGroupLayoutEntry}} 条目数，这些条目是具有动态偏移量的统一缓冲区。
         请参阅 [=超出绑定插槽限制=]。

    <tr><td><dfn>maxDynamicStorageBuffersPerPipelineLayout</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>4
    <tr class=row-continuation><td colspan=4>
        {{GPUPipelineLayout}} 中的最大 {{GPUBindGroupLayoutEntry}} 条目数，这些条目是具有动态偏移量的存储缓冲区。
         请参阅 [=超出绑定插槽限制=]。

    <tr><td><dfn>maxSampledTexturesPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>16
    <tr class=row-continuation><td colspan=4>
        对于每个可能的 {{GPUShaderStage}} `stage`，作为采样纹理的 {{GPUPipelineLayout}} 中的最大 {{GPUBindGroupLayoutEntry}} 条目数。
         请参阅 [=超出绑定插槽限制=]。

    <tr><td><dfn>maxSamplersPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>16
    <tr class=row-continuation><td colspan=4>
        对于每个可能的 {{GPUShaderStage}} `stage`，{{GPUPipelineLayout}} 中作为采样器的 {{GPUBindGroupLayoutEntry}} 条目的最大数量。
         请参阅 [=超出绑定插槽限制=]。

    <tr><td><dfn>maxStorageBuffersPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>8
    <tr class=row-continuation><td colspan=4>
        对于每个可能的 {{GPUShaderStage}} `stage`，{{GPUPipelineLayout}} 中作为存储缓冲区的 {{GPUBindGroupLayoutEntry}} 条目的最大数量。
         请参阅 [=超出绑定插槽限制=]。

    <tr><td><dfn>maxStorageTexturesPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>4
    <tr class=row-continuation><td colspan=4>
        对于每个可能的 {{GPUShaderStage}} `stage`，{{GPUPipelineLayout}} 中作为存储纹理的 {{GPUBindGroupLayoutEntry}} 条目的最大数量。
         请参阅 [=超出绑定插槽限制=]。

    <tr><td><dfn>maxUniformBuffersPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>12
    <tr class=row-continuation><td colspan=4>
       对于每个可能的 {{GPUShaderStage}} `stage`，作为统一缓冲区的 {{GPUPipelineLayout}} 中的最大 {{GPUBindGroupLayoutEntry}} 条目数。
         请参阅 [=超出绑定插槽限制=]。

    <tr><td><dfn>maxUniformBufferBindingSize</dfn>
        <td>{{GPUSize64}} <td>[=limit class/maximum=] <td>65536 bytes
    <tr class=row-continuation><td colspan=4>
        与 {{GPUBindGroupLayoutEntry}} |entry| 绑定的最大 {{GPUBufferBinding}}.{{GPUBufferBinding/size}} |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}} 是 {{GPUBufferBindingType/"uniform"}}。
    <tr><td><dfn>maxStorageBufferBindingSize</dfn>
        <td>{{GPUSize64}} <td>[=limit class/maximum=] <td>134217728 bytes (128 MiB)
    <tr class=row-continuation><td colspan=4>
        与 {{GPUBindGroupLayoutEntry}} |entry| 绑定的最大 {{GPUBufferBinding}}.{{GPUBufferBinding/size}} |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}} 是 {{GPUBufferBindingType/"storage"}} 或 {{GPUBufferBindingType/"read-only-storage"}}。
    <tr><td><dfn>minUniformBufferOffsetAlignment</dfn>
        <td>{{GPUSize32}} <td>[=limit class/alignment=] <td>256 bytes
    <tr class=row-continuation><td colspan=4>
        {{GPUBufferBinding}} 所需的对齐方式。{{GPUBufferBinding/offset}} 和 [=GPUBindingCommandsMixin/setBindGroup()=] 中提供的动态偏移量，用于与 {{GPUBindGroupLayoutEntry}} |entry| 的绑定 |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}} 是 {{GPUBufferBindingType/"uniform"}}。
    <tr><td><dfn>minStorageBufferOffsetAlignment</dfn>
        <td>{{GPUSize32}} <td>[=limit class/alignment=] <td>256 bytes
    <tr class=row-continuation><td colspan=4>
       {{GPUBufferBinding}} 所需的对齐方式。{{GPUBufferBinding/offset}} 和 [=GPUBindingCommandsMixin/setBindGroup()=] 中提供的动态偏移量，用于与 {{GPUBindGroupLayoutEntry}} |entry| 的绑定 |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}} 是 {{GPUBufferBindingType/"storage"}} 或 {{GPUBufferBindingType/"read-only-storage"}}。
    <tr><td><dfn>maxVertexBuffers</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>8
    <tr class=row-continuation><td colspan=4>
        创建 {{GPURenderPipeline}} 时 {{GPUVertexState/buffers}} 的最大数量。
    <tr><td><dfn>maxBufferSize</dfn>
        <td>{{GPUSize64}} <td>[=limit class/maximum=] <td>268435456 bytes (256 MiB)
    <tr class=row-continuation><td colspan=4>
        创建 {{GPUBuffer}} 时 {{GPUBufferDescriptor/size}} 的最大大小。

    <tr><td><dfn>maxVertexAttributes</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>16
    <tr class=row-continuation><td colspan=4>
        创建 {{GPURenderPipeline}} 时，跨越 {{GPUVertexState/buffers}} 的 {{GPUVertexBufferLayout/attributes}} 总数的最大数量。
    <tr><td><dfn>maxVertexBufferArrayStride</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>2048 bytes
    <tr class=row-continuation><td colspan=4>
        创建 {{GPURenderPipeline}} 时允许的最大值 {{GPUVertexBufferLayout/arrayStride}}。
    <tr><td><dfn>maxInterStageShaderComponents</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>60
    <tr class=row-continuation><td colspan=4>
        阶段间通信（如顶点输出或片段输入）的输入或输出变量组件的最大允许数量。
    <tr><td><dfn>maxInterStageShaderVariables</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>16
    <tr class=row-continuation><td colspan=4>
        阶段间通信（如顶点输出或片段输入）的最大允许输入或输出变量数。
    <tr><td><dfn>maxColorAttachments</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>8
    <tr class=row-continuation><td colspan=4>
        {{GPURenderPipelineDescriptor}}.{{GPURenderPipelineDescriptor/fragment}}.{{GPUFragmentState/targets}}、{{GPURenderPassDescriptor}}.{{GPURenderPassDescriptor/colorAttachments}}和{{GPURenderPassLayout}}.{{GPURenderPassLayout/colorFormats}} 中允许的最大颜色附件数。
    <tr><td><dfn>maxColorAttachmentBytesPerSample</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>32
    <tr class=row-continuation><td colspan=4>
        在所有颜色附件中保存渲染管线输出数据的一个样本（像素或子像素）所需的最大字节数。
    <tr><td><dfn>maxComputeWorkgroupStorageSize</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>16384 bytes
    <tr class=row-continuation><td colspan=4>
        用于计算阶段 {{GPUShaderModule}} 入口点的 [=address spaces/workgroup=] 存储的最大字节数。
    <tr><td><dfn>maxComputeInvocationsPerWorkgroup</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>256
    <tr class=row-continuation><td colspan=4>
       计算阶段 {{GPUShaderModule}} 入口点的“workgroup_size”维度乘积的最大值。
    <tr><td><dfn>maxComputeWorkgroupSizeX</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>256
    <tr class=row-continuation><td colspan=4>
       计算阶段 {{GPUShaderModule}} 入口点的 `workgroup_size` X 维度的最大值。
    <tr><td><dfn>maxComputeWorkgroupSizeY</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>256
    <tr class=row-continuation><td colspan=4>
        计算阶段 {{GPUShaderModule}} 入口点的“workgroup_size”Y 维度的最大值。
    <tr><td><dfn>maxComputeWorkgroupSizeZ</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>64
    <tr class=row-continuation><td colspan=4>
        计算阶段 {{GPUShaderModule}} 入口点的“workgroup_size”Z 维度的最大值。
    <tr><td><dfn>maxComputeWorkgroupsPerDimension</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>65535
    <tr class=row-continuation><td colspan=4>
        {{GPUComputePassEncoder/dispatchWorkgroups(workgroupCountX, workgroupCountY, workgroupCountZ)}} 参数的最大值。
</table>

<h5 id=gpusupportedlimits data-dfn-type=interface>`GPUSupportedLimits`
<span id=gpu-supportedlimits></span>
</h5>

{{GPUSupportedLimits}} 公开适配器或设备支持的 [=limits=]。
请参见 {{GPUAdapter/limits|GPUAdapter.limits}} 和 {{GPUDevice/limits|GPUDevice.limits}}。

<!-- When adding limits here, add them to the Correspondence Reference as well. -->

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUSupportedLimits {
    readonly attribute unsigned long maxTextureDimension1D;
    readonly attribute unsigned long maxTextureDimension2D;
    readonly attribute unsigned long maxTextureDimension3D;
    readonly attribute unsigned long maxTextureArrayLayers;
    readonly attribute unsigned long maxBindGroups;
    readonly attribute unsigned long maxBindGroupsPlusVertexBuffers;
    readonly attribute unsigned long maxBindingsPerBindGroup;
    readonly attribute unsigned long maxDynamicUniformBuffersPerPipelineLayout;
    readonly attribute unsigned long maxDynamicStorageBuffersPerPipelineLayout;
    readonly attribute unsigned long maxSampledTexturesPerShaderStage;
    readonly attribute unsigned long maxSamplersPerShaderStage;
    readonly attribute unsigned long maxStorageBuffersPerShaderStage;
    readonly attribute unsigned long maxStorageTexturesPerShaderStage;
    readonly attribute unsigned long maxUniformBuffersPerShaderStage;
    readonly attribute unsigned long long maxUniformBufferBindingSize;
    readonly attribute unsigned long long maxStorageBufferBindingSize;
    readonly attribute unsigned long minUniformBufferOffsetAlignment;
    readonly attribute unsigned long minStorageBufferOffsetAlignment;
    readonly attribute unsigned long maxVertexBuffers;
    readonly attribute unsigned long long maxBufferSize;
    readonly attribute unsigned long maxVertexAttributes;
    readonly attribute unsigned long maxVertexBufferArrayStride;
    readonly attribute unsigned long maxInterStageShaderComponents;
    readonly attribute unsigned long maxInterStageShaderVariables;
    readonly attribute unsigned long maxColorAttachments;
    readonly attribute unsigned long maxColorAttachmentBytesPerSample;
    readonly attribute unsigned long maxComputeWorkgroupStorageSize;
    readonly attribute unsigned long maxComputeInvocationsPerWorkgroup;
    readonly attribute unsigned long maxComputeWorkgroupSizeX;
    readonly attribute unsigned long maxComputeWorkgroupSizeY;
    readonly attribute unsigned long maxComputeWorkgroupSizeZ;
    readonly attribute unsigned long maxComputeWorkgroupsPerDimension;
};
</script>

<h5 id=gpusupportedfeatures data-dfn-type=interface>`GPUSupportedFeatures`
<span id=gpu-supportedfeatures></span>
</h5>

{{GPUSupportedFeatures}} 是一个 [=setlike=] 界面。 它的 [=set entries=] 是适配器或设备支持的 [=features=] 的 {{GPUFeatureName}} 值。 它必须只包含来自 {{GPUFeatureName}} 枚举的字符串。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUSupportedFeatures {
    readonly setlike<DOMString>;
};
</script>

<div class=note>
    注：
    {{GPUSupportedFeatures}} [=set entries=] 的类型是 {{DOMString}} 以允许用户代理优雅地处理有效的 {{GPUFeatureName}}s，这些是在规范的后续修订中添加的，但用户代理尚未更新以识别。 如果 [=set entries=] 类型是 {{GPUFeatureName}}，则以下代码将抛出 {{TypeError}} 而不是报告 `false`：

    <div class=example>
        Check for support of an unrecognized feature:

        <pre highlight=js>
            if (adapter.features.has('unknown-feature')) {
                // Use unknown-feature
            } else {
                console.warn('unknown-feature is not supported by this adapter.');
            }
        </pre>
    </div>
</div>

<h5 id=gpuwgsllanguagefeatures data-dfn-type=interface>`WGSLLanguageFeatures`
</h5>

{{WGSLLanguageFeatures}} 是一个 [=setlike=] 接口。
它的 [=set entries=] 是 WGSL [=language extensions=] 支持所有适配器的字符串名称。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface WGSLLanguageFeatures {
    readonly setlike<DOMString>;
};
</script>

<h5 id=gpuadapterinfo data-dfn-type=interface>`GPUAdapterInfo`
<span id=gpu-adapterinfo></span>
</h5>

{{GPUAdapterInfo}} 公开有关适配器的各种标识信息。

{{GPUAdapterInfo}} 中的任何成员都不能保证被填充。用户代理可以自行决定显示哪些值，并且在某些设备上很可能不会填充任何值。因此，应用程序**必须**能够处理任何可能的 {{GPUAdapterInfo}} 值，包括这些值的缺失。

<p tracking-vector>
有关隐私方面的考虑，请参阅 [[#privacy-adapter-identifiers]]。
</p>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUAdapterInfo {
    readonly attribute DOMString vendor;
    readonly attribute DOMString architecture;
    readonly attribute DOMString device;
    readonly attribute DOMString description;
};
</script>

{{GPUAdapterInfo}} 具有以下属性：

<dl dfn-type=attribute dfn-for=GPUAdapterInfo>
    : <dfn>vendor</dfn>
    ::
        [=适配器=] 供应商的名称，如果可用的话。否则为空字符串。

    : <dfn>architecture</dfn>
    ::
        [=适配器=] 所属的 GPU 系列或类别的名称（如果可用）。否则为空字符串。

    : <dfn>device</dfn>
    ::
        [=适配器=] 的供应商特定标识符（如果可用）。否则为空字符串。

         注：这是一个表示适配器类型的值。 例如，它可能是 [PCI 设备 ID](https://pcisig.com/)。 它不像序列号那样唯一地标识给定的硬件。

    : <dfn>description</dfn>
    ::
        描述驱动程序报告的 [=适配器=] 的人类可读字符串（如果可用）。
         否则为空字符串。

         注：因为没有格式应用于 {{GPUAdapterInfo/description}} ，所以不建议尝试解析此值。 根据 {{GPUAdapterInfo}} 更改其行为的应用程序，例如对已知驱动程序问题应用解决方法，应尽可能依赖其他字段。
</dl>

<div algorithm>
    要为给定的 [=适配器=] |adapter| 创建一个 <dfn abstract-op>new adapter info</dfn>，运行
     以下步骤：

     1. 让 |adapterInfo| 成为一个新的 {{GPUAdapterInfo}}。
     1. 让 |unmaskedValues| 成为 |adapter|.{{适配器/[[unmaskedIdentifiers]]}}
     1. 如果 |unmaskedValues| [=set/contains=] `"vendor"` 并且供应商是已知的：
         1. 将 |adapterInfo|.{{GPUAdapterInfo/vendor}} 设置为 |adapter| 供应商的名称作为 [=规范化标识符字符串=]。

         否则：

         1. 将 |adapterInfo|.{{GPUAdapterInfo/vendor}} 设置为空字符串或供应商的合理近似值 [=标准化标识符字符串=]。

     1. 如果 |unmaskedValues| [=set/contains=] `"architecture"` 架构是已知的：
         1. 将 |adapterInfo|.{{GPUAdapterInfo/architecture}} 设置为 [=normalized identifier string=] 表示 |adapter| 所属的适配器系列或类别 属于。

         否则：

         1. 将 |adapterInfo|.{{GPUAdapterInfo/architecture}} 设置为空字符串或架构的合理近似值 [=规范化标识符字符串=]。

     1. 如果 |unmaskedValues| [=set/contains=] `"device"` 并且设备是已知的：
         1. 将 |adapterInfo|.{{GPUAdapterInfo/device}} 设置为 [=normalized identifier string=] 表示 |adapter| 的供应商特定标识符。

         否则：

         1. 将 |adapterInfo|.{{GPUAdapterInfo/device}} 设置为空字符串或供应商特定标识符的合理近似值 [=标准化标识符字符串=]。

     1. 如果 |unmaskedValues| [=set/contains=] `"description"` 并且描述是已知的：
         1. 将 |adapterInfo|.{{GPUAdapterInfo/description}} 设置为 |adapter| 的描述 据司机报告。

         否则：

         1. 将 |adapterInfo|.{{GPUAdapterInfo/description}} 设置为空字符串或描述的合理近似值。

     1. 返回 |adapterInfo|。
</div>

<div algorithm>
    <dfn>normalized identifier string</dfn>遵循以下模式:

    `[a-z0-9]+(-[a-z0-9]+)*`
    <!-- TODO(tabatkins/bikeshed#2319): Railroad diagrams are broken right now.
    <pre class=railroad>
        OneOrMore:
            OneOrMore:
                T: a-z 0-9
            T: -
    </pre>
    -->

    <div class=example>
        有效的规范化标识符字符串的示例包括：

        - `gpu`
        - `3d`
        - `0x3b2f`
        - `next-gen`
        - `series-x20-ultra`
    </div>
</div>

## 扩展文档 ## {#extension-documents}

“扩展文档”是描述新功能的附加文档，这些新功能是非规范的并且**不是 WebGPU/WGSL 规范的一部分**。
它们描述了基于这些规范构建的功能，通常包括一个或多个新的 API [=特性=] 标志和/或 WGSL `enable` 指令，或与其他网络规范草案的交互。

WebGPU 实现**不得**暴露扩展功能； 这样做是违反规范的。
在将新功能集成到 WebGPU 规范（本文档）和/或 WGSL 规范中之前，它不会成为 WebGPU 标准的一部分。

## 源限制 ## {#origin-restrictions}

WebGPU 允许访问存储在图像、视频和画布中的图像数据。
跨域媒体的使用受到限制，因为着色器可用于间接推断已上传到 GPU 的纹理内容。

WebGPU 不允许上传<l spec=html>[=is not origin-clean=]</l> 的图像源。

这也意味着使用 WebGPU 渲染的画布的 [=origin-clean=] 标志永远不会设置为“false”。

有关为图像和视频元素发出 CORS 请求的更多信息，请参阅：

- [[html#cors-settings-attributes]]
- [[html#the-img-element]] <{img}>
- [[html#media-elements]] {{HTMLMediaElement}}

## 任务源 ## {#task-sources}

### WebGPU 任务源 ### {#-webgpu-task-source}

WebGPU 定义了一个新的 [=任务源=] 称为 <dfn dfn>WebGPU 任务源</dfn>。
它用于 {{GPUDevice/uncapturederror}} 事件和 {{GPUDevice}}.{{GPUDevice/lost}}。

<div algorithm>
    <dfn abstract-op>为 {{GPUDevice}}</dfn> |device| 排队全局任务，
     通过一系列步骤|步骤|: 

     1. [=Queue a global task=] 在 [=WebGPU task source=] 上，使用用于创建 |device| 的全局对象，以及步骤 |steps|。
</div>

<h4 id=automatic-expiry-task-source data-dfn-type=dfn>自动过期任务源
</h4>

WebGPU 定义了一个名为 [=自动过期任务源=] 的新 [=任务源=]。
它用于某些对象的自动、定时到期（销毁）：

- {{GPUTexture}} 由 {{GPUCanvasContext/getCurrentTexture()}} 返回
- 从 {{HTMLVideoElement}} 创建的 {{GPUExternalTexture}}

<div algorithm>
    使用 {{GPUDevice}} |device| <dfn abstract-op>排队自动到期任务</dfn> 和一系列步骤|步骤|：

     1. 在 [=自动过期任务源=] 上 [=进队一个全局任务=]，使用用于创建 |device| 的全局对象，以及步骤 |steps|。
</div>

来自[=自动过期任务源=]的任务**应该**被高优先级处理； 特别是，一旦排队，它们**应该**在用户定义的（JavaScript）任务之前运行。

<div class=note>
     注：
     这种行为更可预测，并且这种严格性有助于开发人员通过急切地检测可能难以检测的关于隐式生命周期的错误假设来编写更具可移植性的应用程序。
     仍然强烈鼓励开发人员在多个实现中进行测试。

     实施注：
     通过在 [=event loop processing model=] 内的固定点插入额外步骤而不是运行实际任务来实现高优先级到期“任务”是有效的。
</div>

## 颜色空间和编码 ## {#color-spaces}

WebGPU 不提供颜色管理。 WebGPU 中的所有值（例如纹理元素）都是原始数值，而不是颜色管理颜色值。

WebGPU *确实*与颜色管理输出（通过 {{GPUCanvasConfiguration}}）和输入（通过 {{GPUQueue/copyExternalImageToTexture()}} 和 {{GPUDevice/importExternalTexture()}}）进行交互。
因此，必须在 WebGPU 数值和外部颜色值之间进行颜色转换。
每个此类接口点都在本地定义一种编码（颜色空间、传递函数和 alpha 预乘），WebGPU 数值将在其中进行解释。

WebGPU 允许 {{PredefinedColorSpace}} 枚举中的所有颜色空间。
请注意，每个颜色空间都定义在扩展范围内，如引用的 CSS 定义所定义，以表示其空间之外的颜色值（色度和亮度）。

问题（gpuweb/gpuweb#1715）：
考虑将 srgb 编码图像上传到线性编码纹理的路径。

<dfn dfn>色域外预乘 RGBA 值</dfn> 是任何 R/G/B 通道值超过 alpha 通道值的值。 例如，预乘 sRGB RGBA 值 [1.0, 0, 0, 0.5] 表示具有 50% alpha 的（未预乘）颜色 [2, 0, 0]，在 CSS 中写为 `rgb(srgb 2 0 0 / 50%)` .
就像 sRGB 色域之外的任何颜色值一样，这是扩展颜色空间中定义明确的点（除非 alpha 为 0，在这种情况下没有颜色）。
但是，当这些值输出到可见画布时，结果是不确定的（参见 {{GPUCanvasAlphaMode}} {{GPUCanvasAlphaMode/"premultiplied"}}）。

### Color Space Conversions ### {#color-space-conversions}

根据上面的定义，通过将颜色在一个空间中的表示转换为另一个空间中的表示，颜色在空间之间进行转换。

如果源值的 RGBA 通道少于 4 个，则在转换颜色空间/编码和 alpha 预乘之前，将缺少的绿色/蓝色/alpha 通道分别设置为“0、0、1”。
转换后，如果目标需要少于 4 个通道，则忽略额外的通道。

注：
灰度图像通常在其颜色空间中表示 RGB 值“(V, V, V)”或 RGBA 值“(V, V, V, A)”。

颜色在转换期间不会被有损限制：如果源颜色值在目标颜色空间的色域范围之外，则从一个颜色空间转换到另一个颜色空间将导致值超出 [0, 1] 范围。 例如，对于 sRGB 目标，如果源是 rgba16float，在更宽的色彩空间（如 Display-P3）中，或者预乘并包含 [=色域外预乘 RGBA 值|色域外值 = ].

类似地，如果源值具有高位深度（例如 PNG，每个组件 16 位）或扩展范围（例如，具有“float16”存储的画布），这些颜色将通过颜色空间转换保留，中间计算至少具有精度 的来源。

### 色彩空间转换省略 ### {#color-space-conversion-elision}

如果颜色空间/编码转换的源和目标相同，则不需要转换。 一般来说，如果转换的任何给定步骤是恒等函数（无操作），实现**应该**将其省略，以提高性能。

为了获得最佳性能，应用程序**应该**设置它们的颜色空间和编码选项，以便在整个过程中最大限度地减少必要的转换次数。
对于 {{GPUImageCopyExternalImage}} 的各种图像源：

- {{ImageBitmap}}:
     - 预乘通过 {{ImageBitmapOptions/premultiplyAlpha}} 控制。
     - 色彩空间通过 {{ImageBitmapOptions/colorSpaceConversion}} 控制。
- 二维画布：
     - [[html#premultiplied-alpha-and-the-2d-rendering-context|Always premultiplied]]。
     - 颜色空间通过 {{CanvasRenderingContext2DSettings/colorSpace}} 上下文创建属性控制。
- WebGL 画布：
     - 预乘通过 {{WebGLContextAttributes}} 中的 `premultipliedAlpha` 选项控制。
     - 通过 {{WebGLRenderingContext}} 的 {{WebGLRenderingContext/drawingBufferColorSpace}} 状态控制颜色空间。

注：在依赖这些功能之前，检查浏览器实现是否支持这些功能。

## 从 JavaScript 到 WGSL 的数字转换 ## {#conversions-to-wgsl}

WebGPU API 的几个部分（[=pipeline-overridable=] {{GPUProgrammableStage/constants}} 和 render pass clear values）从 WebIDL（{{double}} 或 {{float}}）获取数值并将它们转换为 WGSL 值（`bool`、`i32`、`u32`、`f32`、`f16`）。

<div algorithm data-timeline=device>
转换 IDL 值 |idlValue| {{double}} 或 {{float}} 类型 <dfn abstract-op> 到 WGSL 类型</dfn> |T|，可能抛出 {{TypeError}}：

     注：此 {{TypeError}} 是在 [=device timeline=] 中生成的，从未出现在 JavaScript 中。

     1.[=断言=] |idlValue| 是一个有限值，因为它不是 {{unrestricted double}} 或 {{unrestricted float}}。

     1.使|v| 是 [=!=] 转换 |idlValue| 为 [=converted to an ECMAScript value|ECMAScript value=]产生的 ECMAScript 数字。
     <!-- This back-conversion is just here so we can call back into the ES->IDL conversion definitions from WebIDL. -->

    1. <dl class=switch>
             : 如果|T| 是“布尔”
             ::
                 返回 [=!=] 转换 |v| 到 [=converted to an IDL value|一个 IDL value=] 的结果对应的 WGSL `bool` 值，{{boolean}} 类型。

                 注：
                 在从 ECMAScript 值转换为 IDL {{double}} 或 {{float}} 值后调用此算法。如果原始 ECMAScript 值是非数字、非布尔值，如“[]”或“{}”，则 WGSL 的“bool”结果可能与 ECMAScript 值已直接转换为 IDL {{boolean}}。

             : 如果|T| 是 `i32`
             ::
                 返回[=?=] 将 |v| [=转换为 IDL 值|一个 IDL 值=] 的结果对应的WGSL `i32`值，[{{EnforceRange}}] {{long}} 类型。

             : 如果|T| 是 `u32`
             :: 返回 [=?=] 将 |v| [=转换为 IDL 值|一个 IDL 值=] 的结果对应的 WGSL `u32` 值，[{{EnforceRange}}] {{unsigned long}} 类型。

             : 如果|T| 是 `f32`
             :: 返回[=?=] 将 |v| [=转换为一个 IDL value|一个 IDL value=] 结果对应的WGSL `f32`值，{{float}} 类型。

             : 如果|T| 是 `f16`
             ::
                 1.让|wgslF32| 是 [=?=] 转换 |v| 到 [=converted to an IDL value|一个 IDL value=] 的结果对应的 WGSL `f32` 值，{{float}} 类型。
                 1.返回 <code>f16(|wgslF32|)</code>，[=!=] 将 WGSL `f32` 值转换为 `f16` 的结果，如 [=WGSL 浮点转换=] 中所定义。

                 注：只要该值在 `f32` 的范围内，就不会抛出错误，即使该值超出 `f16` 的范围。
        </dl>
</div>

<div algorithm data-timeline=device>
    转换 {{GPUColor}} |color| <dfn abstract-op>到纹理格式的纹素值</dfn> |format|，可能会抛出一个{{TypeError}}：

     注：此 {{TypeError}} 是在 [=设备时间线=] 中生成的，从未出现在 JavaScript 中。

     1. 如果 |format| 的组件 （[=assert=] 它们都具有相同的类型）是：

         <dl 类=开关>
             ：浮点类型或规范化类型
             :: 让|T| 是 `f32`。
             : 有符号整数类型
             :: 让|T| 是 `i32`。
             : 无符号整数类型
             :: 让|T| 是 `u32`。
         </dl>

     1.让|wgslColor| 是 <code>vec4<|T|></code> 类型的 WGSL 值，其中 4 个分量是 |color| 的 RGBA 通道，每个 [=?=] 转换为 [$to WGSL type$] |T |。

    1.转换|wgslColor| 到|格式化| 使用与 [[#output-merging]] 步骤相同的转换规则，并返回结果。

         注：
         对于非整数类型，值的确切选择是实现定义的。
         对于规范化类型，值被限制在类型的范围内。

     注：
     换句话说，写入的值就好像是由 WGSL 着色器写入的，该着色器输出表示为 `f32`、`i32` 或 `u32` 的 `vec4` 的值。</div>


# 初始化 # {#initialization}

## navigator.gpu ## {#navigator-gpu}

{{GPU}} 对象分别通过 {{Navigator}} 和 {{WorkerNavigator}} 接口在 {{Window}} 和 {{DedicatedWorkerGlobalScope}} 上下文中可用，并通过 `navigator.gpu` 暴露出来：
<script type=idl>
interface mixin NavigatorGPU {
    [SameObject, SecureContext] readonly attribute GPU gpu;
};
Navigator includes NavigatorGPU;
WorkerNavigator includes NavigatorGPU;
</script>

## GPU ## {#gpu-interface}

<dfn interface>GPU</dfn> 是 WebGPU 的入口。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPU {
    Promise<GPUAdapter?> requestAdapter(optional GPURequestAdapterOptions options = {});
    GPUTextureFormat getPreferredCanvasFormat();
    [SameObject] readonly attribute WGSLLanguageFeatures wgslLanguageFeatures;
};
</script>

{{GPU}} 具有以下方法和属性：

<dl dfn-type=method dfn-for=GPU>
    : <dfn>requestAdapter(options)</dfn>
    ::
        从用户代理请求 [=适配器=]。
         用户代理选择是否返回适配器，如果是，则根据提供的选项进行选择。
         
        <div algorithm=GPU.requestAdapter>
            <div data-timeline=content>
                **Called on:** {{GPU}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPU/requestAdapter(options)">
                    |options|: 选择适配器的标准。
                </pre>

                **Returns:** {{Promise}}&lt;{{GPUAdapter}}?&gt;

                [=Content timeline=] steps:

                1.让 <var data-timeline=content>contentTimeline</var> 成为当前 [=内容时间线=]。
                1.让 |promise| 成为 [=a new promise=]。
                1.在 |this| 的 [=设备时间线=] 上发出|initialization steps|。
                1. 返回|promise|。
            </div>
            <div data-timeline=device>
                [=Device timeline=] |initialization steps|:

                1. 让 |adapter| 为 `null`.
                1. 如果用户代理选择返回一个适配器，它应该：
                    1. 设置 |adapter| 为一个 [=有效=] [=适配器=]，根据 [[#adapter-selection]] 中的规则和 |options| 中的标准选择，遵守 [[#adapter-capability-guarantees]]。

                         适配器的 [=支持的限制=] 必须符合 [[#limits]] 中定义的要求。

                    1. 如果|适配器| 满足 [=fallback adapter=] 的标准，设置 |adapter|.{{adapter/[[fallback]]}} 为 true。

                1. 在 <var data-timeline=content>内容时间线</var> 上发布后续步骤.
            </div>
            <div data-timeline=content>
                [=Content timeline=] steps:

                1. 如果 |adapter| 不为 `null`:
                    1. 使用一个新的 {{GPUAdapter}} 去封装 |adapter|[=解析=] |promise|。

                1. 否则, [=解析=] |promise| 为 `null`.
            </div>
            <!-- If we add ways to make invalid adapter requests (aside from those
                that violate IDL rules), specify that they reject the promise. -->
        </div>

    : <dfn>getPreferredCanvasFormat()</dfn>
    ::
        返回用于在此系统上显示 8 位深度、标准动态范围内容的最佳 {{GPUTextureFormat}}。 只能返回 {{GPUTextureFormat/"rgba8unorm"}} 或 {{GPUTextureFormat/"bgra8unorm"}}。

         返回值可以作为 {{GPUCanvasConfiguration/format}} 传递给 {{GPUCanvasContext/configure()}} 调用 {{GPUCanvasContext}} 以确保关联的画布能够有效地显示其内容。

         注：未显示在屏幕上的画布可能会或可能不会从使用此格式中受益。

        <div algorithm=GPU.getPreferredCanvasFormat>
            <div data-timeline=content>
                **Called on:** {{GPU}} this.

                **Returns:** {{GPUTextureFormat}}

                [=内容时间线=] 步骤:

                1. 返回 {{GPUTextureFormat/"rgba8unorm"}} 或 {{GPUTextureFormat/"bgra8unorm"}}，具体取决于哪种格式最适合在此系统上显示 WebGPU 画布。        </div>

    : <dfn dfn-type=attribute>wgslLanguageFeatures</dfn>
    ::
        受支持的 WGSL [=language extensions=] 的名称。
        支持的语言扩展会自动启用。
</dl>

[=适配器=] **可能** 随时变为 [=无效=] ("<dfn dfn for=adapter>expire</dfn>")。
在系统状态发生任何可能影响任何 {{GPU/requestAdapter()}} 调用结果的变化时，用户代理**应该**使所有先前返回的适配器过期。 例如：

- 添加/移除物理适配器（通过插入/拔出、驱动程序更新、挂起恢复等）
- 系统的电源配置已更改（笔记本电脑已拔出、电源设置已更改等）

注：
用户代理可能会经常选择 [=adapter/expire=] 适配器，即使没有系统状态更改（例如，创建适配器后的几秒或几分钟）。
这有助于混淆真实的系统状态变化，并让开发人员更加意识到在调用 {{GPUAdapter/requestDevice()}} 之前再次调用 {{GPU/requestAdapter()}} 总是必要的。
如果应用程序确实遇到这种情况，标准的设备丢失恢复处理应该允许它恢复。

<div class=example>
    请求一个没有提示的 {{GPUAdapter}}:

    <pre highlight=js>
        const gpuAdapter = await navigator.gpu.requestAdapter();
    </pre>
</div>

### Adapter Capability Guarantees ### {#adapter-capability-guarantees}

{{GPU/requestAdapter()}} 返回的任何 {{GPUAdapter}} 必须提供以下保证：

- 以下至少一项必须为真：
     - 支持 {{GPUFeatureName/"texture-compression-bc"}}。
     - 支持 {{GPUFeatureName/"texture-compression-etc2"}} 和 {{GPUFeatureName/"texture-compression-astc"}}。
- 所有支持的限制必须是 [=限制/默认=] 值或 [=限制/更好=]。
- 所有 [=limit class/alignment|alignment-class=] 限制必须是 2 的幂。
- {{supported limits/maxBindingsPerBindGroup}} 必须是 &ge;
     （[=每个着色器阶段的最大绑定=] &times; [=每个管线的最大着色器阶段=]），其中：

     - <dfn dfn for="">每个着色器阶段的最大绑定数</dfn> 是
         （{{supported limits/maxSampledTexturesPerShaderStage}} +
         {{supported limits/maxSamplersPerShaderStage}} +
         {{supported limits/maxStorageBuffersPerShaderStage}} +
         {{supported limits/maxStorageTexturesPerShaderStage}} +
         {{supported limits/maxUniformBuffersPerShaderStage}}）。
     - <dfn dfn for="">max shader stages per pipeline</dfn> 是 `2`，因为
         {{GPURenderPipeline}} 支持顶点和片段着色器。

     注：{{supported limits/maxBindingsPerBindGroup}} 不反映基本限制；
     实现应该提高它以符合这个要求，而不是降低
     其他限制。

- {{supported limits/maxBindGroups}} 必须是 &le; {{supported limits/maxBindGroupsPlusVertexBuffers}}。
- {{supported limits/maxVertexBuffers}} 必须是 &le; {{supported limits/maxBindGroupsPlusVertexBuffers}}。
- {{supported limits/minUniformBufferOffsetAlignment}} 和
     {{supported limits/minStorageBufferOffsetAlignment}} 必须都是 &ge; 32 字节。

         注：32 字节将是 `vec4<f64>` 的对齐方式。 参见 [[WGSL#alignment-and-size]]。
- {{supported limits/maxUniformBufferBindingSize}} 必须 &le; {{supported limits/maxBufferSize}}。
- {{supported limits/maxStorageBufferBindingSize}} 必须 &le; {{supported limits/maxBufferSize}}。
- {{supported limits/maxStorageBufferBindingSize}} 必须是 4 字节的倍数。
- {{supported limits/maxVertexBufferArrayStride}} 必须是 4 字节的倍数。
- {{supported limits/maxComputeWorkgroupSizeX}} 必须 &le; {{supported limits/maxComputeInvocationsPerWorkgroup}}。
- {{supported limits/maxComputeWorkgroupSizeY}} 必须 &le; {{supported limits/maxComputeInvocationsPerWorkgroup}}。
- {{supported limits/maxComputeWorkgroupSizeZ}} 必须 &le; {{supported limits/maxComputeInvocationsPerWorkgroup}}。
- {{supported limits/maxComputeInvocationsPerWorkgroup}} 必须 &le; {{supported limits/maxComputeWorkgroupSizeX}}
     &times; {{支持的限制/maxComputeWorkgroupSizeY}} &times; {{supported limits/maxComputeWorkgroupSizeZ}}。

### 适配器选择 ### {#adapter-selection}

<dfn dictionary>GPURequestAdapterOptions</dfn>
向用户代理提供提示，指示哪种配置适合该应用程序。

<script type=idl>
dictionary GPURequestAdapterOptions {
    GPUPowerPreference powerPreference;
    boolean forceFallbackAdapter = false;
};
</script>

<script type=idl>
enum GPUPowerPreference {
    "low-power",
    "high-performance"
};
</script>

{{GPURequestAdapterOptions}} 拥有以下成员:

<dl dfn-type=dict-member dfn-for=GPURequestAdapterOptions>
    : <dfn>powerPreference</dfn>
    ::
        可选地提供提示，指示应从系统的可用适配器中选择 [=适配器=] 的类别。

         此提示的值可能会影响选择哪个适配器，但不得影响是否返回适配器。

         注：
         此提示的主要用途是影响在多 GPU 系统中使用哪个 GPU。
         例如，一些笔记本电脑具有低功耗集成 GPU 和高性能独立 GPU。 此提示还可能会影响所选 GPU 的电源配置，以匹配请求的电源首选项。

         注：
         根据具体的硬件配置，例如电池状态和连接的显示器或可拆卸的 GPU，用户代理可以选择不同的 [=适配器=] 给定相同的电源偏好。
         通常，给定相同的硬件配置和状态以及“powerPreference”，用户代理很可能会选择相同的适配器。

         它必须是以下值之一：

        <dl dfn-type=enum-value dfn-for=GPUPowerPreference>
            : `undefined` (or not present)
            ::
                没有对于用户代理的提示。

            : <dfn>"low-power"</dfn>
            ::
                指将节能优先于性能的请求。

                 注：
                 通常，如果内容不太可能受到绘图性能的限制，则应该使用它； 例如，如果它每秒只渲染一帧，只使用简单的着色器绘制相对简单的几何图形，或者使用一个小的 HTML canvas 元素。
                 如果内容允许，鼓励开发人员使用此值，因为它可以显着延长便携式设备的电池寿命。
            : <dfn>"high-performance"</dfn>
            ::
                指将性能优先于功耗的请求。

                 注：
                 通过选择这个值，开发人员应该意识到，对于在生成的适配器上创建的 [=设备=]，用户代理更有可能强制设备丢失，以便通过切换到低功率适配器来节省功率。
                 鼓励开发人员仅在他们认为绝对必要时才指定此值，因为它可能会显着缩短便携式设备的电池寿命。
        </dl>

    : <dfn>forceFallbackAdapter</dfn>
    ::
        当设置为 true 时，表示可能只返回 [=备用适配器=]。 如果用户代理不支持 [=备用适配器=]，将导致 {{GPU/requestAdapter()}} 解析为“null”。

         注：
         如果 {{GPURequestAdapterOptions/forceFallbackAdapter}} 设置为“false”并且没有其他合适的 [=适配器=] 可用或用户代理选择，返回一个 [=备用适配器=]。
         希望阻止其应用程序在 [=备用适配器=] 上运行的开发人员应在请求 {{GPUDevice}} 之前检查 {{GPUAdapter}}.{{GPUAdapter/isFallbackAdapter}} 属性。
</dl>

<div class=example>
    请求一个 {{GPUPowerPreference/"high-performance"}} {{GPUAdapter}}:

    <pre highlight=js>
        const gpuAdapter = await navigator.gpu.requestAdapter({
            powerPreference: 'high-performance'
        });
    </pre>
</div>

<h3 id=gpuadapter data-dfn-type=interface>`GPUAdapter`
<span id=gpu-adapter></span>
</h3>

{{GPUAdapter}} 封装了一个 [=adapter=]，并描述了它的功能（[=特性=] 和 [=限制=]）。

要获得 {{GPUAdapter}}，请使用 {{GPU/requestAdapter()}}。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUAdapter {
    [SameObject] readonly attribute GPUSupportedFeatures features;
    [SameObject] readonly attribute GPUSupportedLimits limits;
    readonly attribute boolean isFallbackAdapter;

    Promise<GPUDevice> requestDevice(optional GPUDeviceDescriptor descriptor = {});
    Promise<GPUAdapterInfo> requestAdapterInfo(optional sequence<DOMString> unmaskHints = []);
};
</script>

{{GPUAdapter}} 拥有以下属性:

<dl dfn-type=attribute dfn-for=GPUAdapter>
    : <dfn>features</dfn>
    ::
        `this`.{{GPUAdapter/[[adapter]]}}.{{adapter/[[features]]}}中的值的集合。

    : <dfn>limits</dfn>
    ::
        `this`.{{GPUAdapter/[[adapter]]}}.{{adapter/[[limits]]}}中的限制。

    : <dfn>isFallbackAdapter</dfn>
    ::
        返回{{GPUAdapter/[[adapter]]}}.{{adapter/[[fallback]]}}的值。
</dl>

{{GPUAdapter}} has the following internal slots:

<dl dfn-type=attribute dfn-for=GPUAdapter>
    : <dfn>\[[adapter]]</dfn>, 类型为 [=适配器=], 只读
    ::
        {{GPUAdapter}} 指向的 [= 适配器 =]。
</dl>

{{GPUAdapter}} 拥有以下方法：

<dl dfn-type=method dfn-for=GPUAdapter>
    : <dfn>requestDevice(descriptor)</dfn>
    ::
        从 [=适配器=] 请求 [=设备=]。

         这是一次性操作：如果成功返回设备，则适配器变为 [=无效=]。

        <div algorithm=GPUAdapter.requestDevice>
            <div data-timeline=content>
                **Called on:** {{GPUAdapter}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUAdapter/requestDevice(descriptor)">
                    |descriptor|: Description of the {{GPUDevice}} to request.
                </pre>

                **Returns:** {{Promise}}&lt;{{GPUDevice}}&gt;

                [=Content timeline=] steps:

                1. 使 <var data-timeline=content>contentTimeline</var> 为当前 [=内容时间线=].
                1. 使 |promise| 为 [=a new promise=].
                1. 使 |adapter| 为 |this|.{{GPUAdapter/[[adapter]]}}.
                1. 在 |this| 的 [=Device timeline=] 发起 |initialization steps|.
                1. 返回 |promise|.
            </div>
            <div data-timeline=device>
                [=Device timeline=] |initialization steps|:

                1. 如果以下任何条件没有满足：

                    <div class=validusage>
                        - |descriptor|.{{GPUDeviceDescriptor/requiredFeatures}} 中的值集必须是 |adapter|.{{adapter/[[features]]}} 中值的子集。
                    </div>

                    然后在 <var data-timeline=content>contentTimeline</var> 上执行以下步骤并返回：

                        <div data-timeline=content>
                            [=内容时间线=] 步骤:

                            1. 以一个 {{TypeError}} [=拒绝=] |promise|。
                        </div>

                    注：这与浏览器根本不知道功能名称（在其 {{GPUFeatureName}} 定义中）时产生的错误相同。
                     这将浏览器不支持某项功能时的行为与特定适配器不支持某项功能时的行为融合在一起。

                1. 如果未满足以下任何要求：

                    <div class=validusage>
                        - |descriptor| 中的每个键。{{GPUDeviceDescriptor/requiredLimits}} 必须是 [=supported limits=] 成员的名称。

                         - 对于每个限制名称 |key| 在 [=supported limits=] 的键中：
                             让|value| 是 |descriptor|.{{GPUDeviceDescriptor/requiredLimits}}[|key|]。
                             - |value| 必须不 [=限制/更好=] |adapter| 中的限制值。{{adapter/[[limits]]}}。
                             - 如果限制的 [=limit class|class=] 是 [=limit class/alignment=], |value| 必须是 2 的幂。
                    </div>

                    然后在 <var data-timeline=content>contentTimeline</var> 上执行以下步骤并返回：

                    <div data-timeline=content>
                        [=Content timeline=] 步骤：

                        1. 以一个 {{OperationError}} [=拒绝=] |promise|
                    </div>

                    1.如果|adapter| [=无效=]，否则用户代理无法满足请求：

                     1.让|device| 成为一个新的 [=shebei1=]。
                     1. [=丢失设备=](|device|, {{GPUDeviceLostReason/"unknown"}})。

                         注：
                         这使得 |adapter| [=invalid=]，如果还没有的话。

                         注：
                         当这种情况发生时，用户代理应该考虑在大多数或所有情况下发出开发人员可见的警告。 应用程序应从 {{GPU/requestAdapter()}} 开始执行重新初始化逻辑。

                     否则：

                     1.让|device| 成为具有 |descriptor| 描述的功能的[=新设备=]。
                     1.制作|adapter|.{{GPUAdapter/[[adapter]]}} [=无效=]。

                 1. 在 <var data-timeline=content>contentTimeline</var> 上发布后续步骤。
            </div>
            <div data-timeline=content>
                [=内容时间线=] 步骤：

                1. 使用新的 {{GPUDevice}} 对象 |device| [=解析=] |promise| 。

                     注：
                     如果设备已经丢失，因为适配器无法满足请求，|device|.{{GPUDevice/lost}} 已经在 |promise| 解析之前被解析。
            </div>
        </div>

    : <dfn>requestAdapterInfo()</dfn>
    ::
        请求此 {{GPUAdapter}} 的 {{GPUAdapterInfo}}。

         注：适配器信息值与 Promise 一起返回，使用户代理有机会在请求未屏蔽的值时执行可能长时间运行的检查，例如在返回前征求用户同意。 但是，如果未指定 `unmaskHints`，则不应向用户显示任何对话框。
        <div algorithm=GPUAdapter.requestAdapterInfo>
            <div data-timeline=content>
                **Called on:** {{GPUAdapter}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUAdapter/requestAdapterInfo()">
                    |unmaskHints|: {{GPUAdapterInfo}} 属性名称列表，如果可用，需要未屏蔽值。
                </pre>

                **Returns:** {{Promise}}&lt;{{GPUAdapterInfo}}&gt;

                [=内容时间线=] 步骤：

                1. 使 |promise| 为 [=a new promise=].
                1. 使 |adapter| 为 |this|.{{GPUAdapter/[[adapter]]}}.
                1. 如果 |this| 的 [=relevant global object=] 具有 [=transient activation=]，使 |hasActivation| 为 `true`, 否则为 `false`。
                1. 在 [=in parallel=] 上运行以下步骤：
                    1. 如果 |unmaskHints|.length &gt; `0`:
                        1. 如果 |hasActivation| 为 `false` 以一个 {{NotAllowedError}} [=拒绝=] |promise| 并停止此步骤。
                        1. 让 |unmaskedKeys| 是 |unmaskHints| 中指定的用户代理决定取消屏蔽的字段的 [=list=]，如果有的话。

                             注：用户代理可以自由使用它认为合适的任何方法来决定要取消屏蔽哪些字段。
                        1. [=set/Append=] |unmaskedKeys| 为 |adapter|.{{adapter/[[unmaskedIdentifiers]]}}。
                    1. 以一个 [$new adapter info$] 对 |adapter| [=解析=] |promise|。

                1. 返回 |promise|.
            </div>
        </div>
</dl>

<div class=example>
    请求具有默认特性和限制的 {{GPUDevice}}：

    <pre highlight=js>
        const gpuAdapter = await navigator.gpu.requestAdapter();
        const gpuDevice = await gpuAdapter.requestDevice();
    </pre>
</div>

<h4 id=gpudevicedescriptor data-dfn-type=dictionary>`GPUDeviceDescriptor`
<span id=dictdef-gpudevicedescriptor></span>
</h4>

{{GPUDeviceDescriptor}} describes a device request.

<script type=idl>
dictionary GPUDeviceDescriptor
         : GPUObjectDescriptorBase {
    sequence<GPUFeatureName> requiredFeatures = [];
    record<DOMString, GPUSize64> requiredLimits = {};
    GPUQueueDescriptor defaultQueue = {};
};
</script>

{{GPUDeviceDescriptor}} has the following members:

<dl dfn-type=dict-member dfn-for=GPUDeviceDescriptor>
    : <dfn>requiredFeatures</dfn>
    ::
        指定设备请求所需的 [=特性=]。
         如果适配器不能提供这些功能，请求将失败。

         在生成的设备上验证 API 调用时，将允许完全指定的一组功能，不多也不少。

    : <dfn>requiredLimits</dfn>
    ::
        指定设备请求所需的 [=限制=]。
         如果适配器不能提供这些限制，请求将失败。

         每个键必须是 [=支持的限制=] 成员的名称。
         在生成的设备上验证 API 调用时，将允许完全指定的限制，并且不允许 [=限制/更好=] 或更糟。

        <!-- If we ever need limit types other than GPUSize32/GPUSize64, we can change the value
        type to `double` or `any` in the future and write out the type conversion explicitly (by
        reference to WebIDL spec). Or change the entire type to `any` and add back a `dictionary
        GPULimits` and define the conversion of the whole object by reference to WebIDL. -->

    : <dfn>defaultQueue</dfn>
    ::
        默认 {{GPUQueue}} 的描述符。
</dl>

<div class=example>
    Requesting a {{GPUDevice}} with the {{GPUFeatureName/"texture-compression-astc"}} feature if supported:

    <pre highlight=js>
        const gpuAdapter = await navigator.gpu.requestAdapter();

        const requiredFeatures = [];
        if (gpuAdapter.features.has('texture-compression-astc')) {
            requiredFeatures.push('texture-compression-astc')
        }

        const gpuDevice = await gpuAdapter.requestDevice({
            requiredFeatures
        });
    </pre>
</div>

<h5 id=gpufeaturename data-dfn-type=enum>`GPUFeatureName`
<span id=enumdef-gpufeaturename></span>
</h5>

每个 {{GPUFeatureName}} 标识一组功能，如果可用，则允许 WebGPU 的其他使用，否则这些功能将无效。

<script type=idl>
enum GPUFeatureName {
    "depth-clip-control",
    "depth32float-stencil8",
    "texture-compression-bc",
    "texture-compression-etc2",
    "texture-compression-astc",
    "timestamp-query",
    "indirect-first-instance",
    "shader-f16",
    "rg11b10ufloat-renderable",
    "bgra8unorm-storage",
    "float32-filterable"
};
</script>

<h3 id=gpudevice data-dfn-type=interface>`GPUDevice`
<span id=gpu-device></span>
</h3>

{{GPUDevice}} 封装了 [=device=] 并公开了该设备的功能。

{{GPUDevice}} 是创建 [=WebGPU interfaces=] 的顶级接口。

要获取 {{GPUDevice}}，请使用 {{GPUAdapter/requestDevice()}}。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUDevice : EventTarget {
    [SameObject] readonly attribute GPUSupportedFeatures features;
    [SameObject] readonly attribute GPUSupportedLimits limits;

    [SameObject] readonly attribute GPUQueue queue;

    undefined destroy();

    GPUBuffer createBuffer(GPUBufferDescriptor descriptor);
    GPUTexture createTexture(GPUTextureDescriptor descriptor);
    GPUSampler createSampler(optional GPUSamplerDescriptor descriptor = {});
    GPUExternalTexture importExternalTexture(GPUExternalTextureDescriptor descriptor);

    GPUBindGroupLayout createBindGroupLayout(GPUBindGroupLayoutDescriptor descriptor);
    GPUPipelineLayout createPipelineLayout(GPUPipelineLayoutDescriptor descriptor);
    GPUBindGroup createBindGroup(GPUBindGroupDescriptor descriptor);

    GPUShaderModule createShaderModule(GPUShaderModuleDescriptor descriptor);
    GPUComputePipeline createComputePipeline(GPUComputePipelineDescriptor descriptor);
    GPURenderPipeline createRenderPipeline(GPURenderPipelineDescriptor descriptor);
    Promise<GPUComputePipeline> createComputePipelineAsync(GPUComputePipelineDescriptor descriptor);
    Promise<GPURenderPipeline> createRenderPipelineAsync(GPURenderPipelineDescriptor descriptor);

    GPUCommandEncoder createCommandEncoder(optional GPUCommandEncoderDescriptor descriptor = {});
    GPURenderBundleEncoder createRenderBundleEncoder(GPURenderBundleEncoderDescriptor descriptor);

    GPUQuerySet createQuerySet(GPUQuerySetDescriptor descriptor);
};
GPUDevice includes GPUObjectBase;
</script>

{{GPUDevice}} has the following attributes:

<dl dfn-type=attribute dfn-for=GPUDevice>
    : <dfn>features</dfn>
    ::
        包含设备支持的功能（即创建它的功能）的 {{GPUFeatureName}} 值的集合。

    : <dfn>limits</dfn>
    ::
        公开设备支持的限制（这正是创建它时所用的限制）。

    : <dfn>queue</dfn>
    ::
        此设备的主要 {{GPUQueue}}。
</dl>

{{GPUDevice}} 的 {{GPUObjectBase/[[device]]}} 是 {{GPUDevice}} 引用的 [=设备=]。

{{GPUDevice}} 具有上面的 WebIDL 定义中列出的方法。
此处未定义的那些在本文档的其他地方定义。

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>destroy()</dfn>
    ::
        销毁 [=设备=]，防止对其进行进一步操作。
         未完成的异步操作将失败。

       注：多次销毁设备有效。

        <div algorithm=GPUDevice.destroy()>
            <div data-timeline=content>
                **Called on:** {{GPUDevice}} |this|.

                [=内容时间线=] 步骤：

                1. {{GPUBuffer/unmap()}} 所有此设备中的 {{GPUBuffer}}。

                    <!-- POSTV1(multithreading) tentative text:
                    ... which are mapped in this [=agent=] (thread).

                    Note: Any buffers which are mapped in a different thread are not unmapped.
                    They can be unmapped only from the thread on which they are mapped, either by
                    another call to {{GPUDevice/destroy()|GPUDevice.destroy()}}, or by
                    {{GPUBuffer/destroy()|GPUBuffer.destroy()}} or {{GPUBuffer/unmap()|GPUBuffer.unmap()}}.
                    -->
                1. 在 |this| 的 [=设备时间线=] 上发起后续步骤。
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. 一旦所有<span data-timeline=queue>当前在此设备上的任何队列上排队的操作</span>完成后，在<span data-timeline=device>当前时间线</span>上发出后续步骤。
            </div>
            <div data-timeline=device>
                1. [=Lose the device=](|this|.{{GPUObjectBase/[[device]]}},
                    {{GPUDeviceLostReason/"destroyed"}}).
            </div>
        </div>

        注：由于没有进一步的操作可以在此设备上排队，实现可以立即中止未完成的异步操作并释放资源分配，包括刚刚取消映射的映射内存。
</dl>

<div algorithm>
    A {{GPUDevice}}'s <dfn dfn>allowed buffer usages</dfn> are:

    - Always allowed:
        {{GPUBufferUsage/MAP_READ}},
        {{GPUBufferUsage/MAP_WRITE}},
        {{GPUBufferUsage/COPY_SRC}},
        {{GPUBufferUsage/COPY_DST}},
        {{GPUBufferUsage/INDEX}},
        {{GPUBufferUsage/VERTEX}},
        {{GPUBufferUsage/UNIFORM}},
        {{GPUBufferUsage/STORAGE}},
        {{GPUBufferUsage/INDIRECT}},
        {{GPUBufferUsage/QUERY_RESOLVE}}

    <!-- As needed, compute more allowed usages based on the features enabled on the device. -->
</div>

<div algorithm>
    A {{GPUDevice}}'s <dfn dfn>allowed texture usages</dfn> are:

    - Always allowed:
        {{GPUTextureUsage/COPY_SRC}},
        {{GPUTextureUsage/COPY_DST}},
        {{GPUTextureUsage/TEXTURE_BINDING}},
        {{GPUTextureUsage/STORAGE_BINDING}},
        {{GPUTextureUsage/RENDER_ATTACHMENT}}

    <!-- As needed, compute more allowed usages based on the features enabled on the device. -->
</div>

## 示例 ## {#initialization-examples}

<div class=example>
    请求带有错误处理的 {{GPUAdapter}} 和 {{GPUDevice}} 的更强大示例：

    <pre highlight=js>
        let gpuDevice = null;

        async function initializeWebGPU() {
            // Check to ensure the user agent supports WebGPU.
            if (!('gpu' in navigator)) {
                console.error("User agent doesn't support WebGPU.");
                return false;
            }

            // Request an adapter.
            const gpuAdapter = await navigator.gpu.requestAdapter();

            // requestAdapter may resolve with null if no suitable adapters are found.
            if (!gpuAdapter) {
                console.error('No WebGPU adapters found.');
                return false;
            }

            // Request a device.
            // Note that the promise will reject if invalid options are passed to the optional
            // dictionary. To avoid the promise rejecting always check any features and limits
            // against the adapters features and limits prior to calling requestDevice().
            gpuDevice = await gpuAdapter.requestDevice();

            // requestDevice will never return null, but if a valid device request can't be
            // fulfilled for some reason it may resolve to a device which has already been lost.
            // Additionally, devices can be lost at any time after creation for a variety of reasons
            // (ie: browser resource management, driver updates), so it's a good idea to always
            // handle lost devices gracefully.
            gpuDevice.lost.then((info) => {
                console.error(\`WebGPU device was lost: ${info.message}\`);

                gpuDevice = null;

                // Many causes for lost devices are transient, so applications should try getting a
                // new device once a previous one has been lost unless the loss was caused by the
                // application intentionally destroying the device. Note that any WebGPU resources
                // created with the previous device (buffers, textures, etc) will need to be
                // re-created with the new one.
                if (info.reason != 'destroyed') {
                    initializeWebGPU();
                }
            });

            onWebGPUInitialized();

            return true;
        }

        function onWebGPUInitialized() {
            // Begin creating WebGPU resources here...
        }

        initializeWebGPU();
    </pre>
</div>

# Buffers # {#buffers}

<h3 id=gpubuffer data-dfn-type=interface>`GPUBuffer`
<span id=buffer-interface></span>
</h3>

{{GPUBuffer}} 表示可用于 GPU 操作的内存块。
数据以线性布局存储，这意味着分配的每个字节都可以通过它从 {{GPUBuffer}} 开始的偏移量来寻址，取决于操作的对齐限制。 一些 {{GPUBuffer|GPUBuffers}} 可以被映射，这使得内存块可以通过称为其映射的 {{ArrayBuffer}} 访问。

{{GPUBuffer}} 通过 {{GPUDevice/createBuffer()}} 创建。
缓冲区可能是 {{GPUBufferDescriptor/mappedAtCreation}}。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUBuffer {
    readonly attribute GPUSize64 size;
    readonly attribute GPUBufferUsageFlags usage;

    readonly attribute GPUBufferMapState mapState;

    Promise<undefined> mapAsync(GPUMapModeFlags mode, optional GPUSize64 offset = 0, optional GPUSize64 size);
    ArrayBuffer getMappedRange(optional GPUSize64 offset = 0, optional GPUSize64 size);
    undefined unmap();

    undefined destroy();
};
GPUBuffer includes GPUObjectBase;

enum GPUBufferMapState {
    "unmapped",
    "pending",
    "mapped"
};
</script>

{{GPUBuffer}} 拥有以下 [=不可变属性=]:

<dl dfn-type=attribute dfn-for=GPUBuffer data-timeline=const>
    : <dfn>size</dfn>
    ::
        {{GPUBuffer}} 分配的字节长度。

    : <dfn>usage</dfn>
    ::
        此 {{GPUBuffer}} 的允许用途。

    : <dfn>\[[internals]]</dfn>, 类型为 [=buffer internals=], 只读, {{GPUObjectBase/[[internals]]|override}}
    ::
</dl>

{{GPUBuffer}} 拥有以下 [=内容时间线属性=]:

<dl dfn-type=attribute dfn-for=GPUBuffer data-timeline=content>
    : <dfn>mapState</dfn>
    ::
        缓冲区的当前 <dfn enum for="">GPUBufferMapState</dfn>：

        <dl dfn-type=enum-value dfn-for=GPUBufferMapState>
            : <dfn>"unmapped"</dfn>
            ::
                缓冲区未映射供“this”使用。{{GPUBuffer/getMappedRange()}}。

            : <dfn>"pending"</dfn>
            ::
                已请求缓冲区的映射，但尚未完成。
                它可能会在 {{GPUBuffer/mapAsync()}} 中验证成功或失败。

            : <dfn>"mapped"</dfn>
            ::
                缓冲区已映射，并且可以使用 `this`.{{GPUBuffer/getMappedRange()}} 。
        </dl>

        The [=getter steps=] are:

        <div algorithm=mapState>
            <div data-timeline=content>
                [=Content timeline=] 步骤：

                1. 如果 |this|.{{GPUBuffer/[[mapping]]}} 不是 `null`，
                     返回 {{GPUBufferMapState/"mapped"}}。
                 1. 如果 |this|.{{GPUBuffer/[[pending_map]]}} 不是 `null`，
                     返回 {{GPUBufferMapState/"pending"}}。
                 1. 返回{{GPUBufferMapState/"unmapped"}}。
            </div>
        </div>

    : <dfn>\[[pending_map]]</dfn>, 类型为 {{Promise}}&lt;void&gt; 或 `null`, 初始为 `null`
    ::
        当前未决的 {{GPUBuffer/mapAsync()}} 调用返回的 {{Promise}}。

         挂起的映射永远不会超过一个，因为如果请求已经在进行中，{{GPUBuffer/mapAsync()}} 将立即拒绝。

    : <dfn>\[[mapping]]</dfn>, 类型为 [=active buffer mapping=] 或 `null`, 初始为 `null`
    ::
        当且仅当缓冲区当前被映射以供 {{GPUBuffer/getMappedRange()}} 使用时设置。
         否则为空（即使有 {{GPUBuffer/[[pending_map]]}}）。

         <dfn dfn for="">active buffer mapping</dfn> 是一个包含以下字段的结构：

        <dl dfn-type=dfn dfn-for="active buffer mapping">
            : <dfn>data</dfn>, of type [=Data Block=]
            ::
                此 {{GPUBuffer}} 的映射。 此数据通过 {{ArrayBuffer}} 访问，{{ArrayBuffer}} 是此数据的视图，由 {{GPUBuffer/getMappedRange()}} 返回并存储在 [=active buffer mapping/views=] 中。
            
            : <dfn>mode</dfn>, of type {{GPUMapModeFlags}}
            ::
                地图的 {{GPUMapModeFlags}}，在对 {{GPUBuffer/mapAsync()}} 或 {{GPUDevice/createBuffer()}} 的相应调用中指定。
            
            : <dfn>range</dfn>, of type tuple [{{unsigned long long}}, {{unsigned long long}}]
            ::
                此 {{GPUBuffer}} 映射的范围。

            : <dfn>views</dfn>, of type [=list=]&lt;{{ArrayBuffer}}&gt;
            ::
                {{ArrayBuffer}} 通过 {{GPUBuffer/getMappedRange()}} 返回给应用程序。
                 它们被跟踪，因此可以在调用 {{GPUBuffer/unmap()}} 时分离它们。
        </dl>

        <div algorithm>
        使用模式 |mode| 和范围 |range| 来 <dfn abstract-op for="">初始化一个活动缓冲区映射</dfn> ：

             1. 让 |size| 为 |range|[1] - |range|[0]。
             1. 让 |data| 为 [=?=] [$CreateByteDataBlock$](|size|)。

                <div class=note>
                    注：
                    这可能会导致抛出 {{RangeError}}。
                     为了一致性和可预测性：

                     - 对于 `new ArrayBuffer()` 在给定时刻成功的任何大小，此分配**应该**在那一刻成功。
                     - 对于 `new ArrayBuffer()` *确定性* 抛出 {{RangeError}} 的任何大小，此分配也**应该**。
                </div>

            1. 返回一个 [=active buffer mapping=] 且:
                - [=active buffer mapping/data=] 设置为 |data|.
                - [=active buffer mapping/mode=] 设置为 |mode|.
                - [=active buffer mapping/range=] 设置为 |range|.
                - [=active buffer mapping/views=] 设置为 `[]`.
        </div>
</dl>

{{GPUBuffer}} 的 [=internal object=] 是 <dfn dfn>buffer internals</dfn>，它使用以下 [=device timeline slots=] 扩展 [=internal object=]：

<dl dfn-type=dfn dfn-for="buffer internals" data-timeline=device>
    : <dfn>state</dfn>
    ::
        缓冲区的当前内部状态：

        <dl dfn-type=dfn dfn-for="buffer internals/state">
            : "<dfn>available</dfn>"
            ::
                缓冲区可用于队列操作（除非它是 [=无效=]的）。

            : "<dfn>unavailable</dfn>"
            ::
                由于被映射，缓冲区可能无法用于队列操作。

            : "<dfn>destroyed</dfn>"
            ::
                由于被 {{GPUBuffer/destroy()}}ed，缓冲区可能无法用于任何操作。
        </dl>
</dl>

<div class=example>
    <figure>
        <figcaption>Mapping and unmapping a buffer.</figcaption>

        <object type="image/svg+xml" data="img/buffer-map-unmap.mmd.svg"></object>
    </figure>

    <figure>
        <figcaption>Failing to map a buffer.</figcaption>

        <object type="image/svg+xml" data="img/buffer-map-failure.mmd.svg"></object>
    </figure>
</div>

<h4 id=gpubufferdescriptor data-dfn-type=dictionary>`GPUBufferDescriptor`
<span id=GPUBufferDescriptor></span>
<span id=dictdef-gpubufferdescriptor></span>
</h4>

<script type=idl>
dictionary GPUBufferDescriptor
         : GPUObjectDescriptorBase {
    required GPUSize64 size;
    required GPUBufferUsageFlags usage;
    boolean mappedAtCreation = false;
};
</script>

{{GPUBufferDescriptor}} 拥有以下成员：

<dl dfn-type=dict-member dfn-for=GPUBufferDescriptor>
    : <dfn>size</dfn>
    ::
        缓冲大小，以字节为单位。

    : <dfn>usage</dfn>
    ::
        缓冲的可用用途。

    : <dfn>mappedAtCreation</dfn>
    ::
        如果 true 以已映射状态创建缓冲区，则允许立即调用 {{GPUBuffer/getMappedRange()}}。
        即使 {{GPUBufferDescriptor/usage}} 不包含 {{GPUBufferUsage/MAP_READ}} 或 {{GPUBufferUsage/MAP_WRITE}}，将 {{GPUBufferDescriptor/mappedAtCreation}} 设置为“true”也是有效的。
        这可用于设置缓冲区的初始数据。

         保证即使缓冲区创建最终失败，在取消映射之前，它仍然会显示为可以写入/读取映射范围。
</dl>

### 缓冲区使用 ### {#buffer-usage}

<script type=idl>
typedef [EnforceRange] unsigned long GPUBufferUsageFlags;
[Exposed=(Window, DedicatedWorker), SecureContext]
namespace GPUBufferUsage {
    const GPUFlagsConstant MAP_READ      = 0x0001;
    const GPUFlagsConstant MAP_WRITE     = 0x0002;
    const GPUFlagsConstant COPY_SRC      = 0x0004;
    const GPUFlagsConstant COPY_DST      = 0x0008;
    const GPUFlagsConstant INDEX         = 0x0010;
    const GPUFlagsConstant VERTEX        = 0x0020;
    const GPUFlagsConstant UNIFORM       = 0x0040;
    const GPUFlagsConstant STORAGE       = 0x0080;
    const GPUFlagsConstant INDIRECT      = 0x0100;
    const GPUFlagsConstant QUERY_RESOLVE = 0x0200;
};
</script>

{{GPUBufferUsage}} 标志决定了 {{GPUBuffer}} 在创建后如何使用：

<dl dfn-type=const dfn-for=GPUBufferUsage>
    : <dfn>MAP_READ</dfn>
    ::
        可以映射缓冲区以供读取。（示例：使用 {{GPUMapMode/READ|GPUMapMode.READ}} 调用 {{GPUBuffer/mapAsync()}}）

         只能与 {{GPUBufferUsage/COPY_DST}} 结合使用。

    : <dfn>MAP_WRITE</dfn>
    ::
        可以映射缓冲区以进行写入。（示例：使用 {{GPUMapMode/WRITE|GPUMapMode.WRITE}} 调用 {{GPUBuffer/mapAsync()}}）

         只能与 {{GPUBufferUsage/COPY_SRC}} 结合使用。

    : <dfn>COPY_SRC</dfn>
    ::
        缓冲区可以用作复制操作的源。（示例：作为 {{GPUCommandEncoder/copyBufferToBuffer()}} 或 {{GPUCommandEncoder/copyBufferToTexture()}} 调用的 `source` 参数。）
    
    : <dfn>COPY_DST</dfn>
    ::
        缓冲区可用作复制或写入操作的目标。（示例：作为 {{GPUCommandEncoder/copyBufferToBuffer()}} 或 {{GPUCommandEncoder/copyTextureToBuffer()}} 调用的“目标”参数，或作为 {{GPUQueue/writeBuffer()}} 调用的目标。）
    
    : <dfn>INDEX</dfn>
    ::
        该缓冲区可用作索引缓冲区。（示例：传递给 {{GPURenderCommandsMixin/setIndexBuffer()}}。）

    : <dfn>VERTEX</dfn>
    ::
        该缓冲区可用作顶点缓冲区。（示例：传递给 {{GPURenderCommandsMixin/setVertexBuffer()}}。）

    : <dfn>UNIFORM</dfn>
    ::
        该缓冲区可以用作统一缓冲区。（示例：作为 {{GPUBufferBindingLayout}} 的绑定组条目，其 {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/type}} 为 {{GPUBufferBindingType/"uniform"}}。）
    : <dfn>STORAGE</dfn>
    ::
        缓冲区可以用作存储缓冲区。（示例：作为具有 {{GPUBindGroupLayoutEntry/buffer}} 的 {{GPUBufferBindingLayout}} 的绑定组条目。{{GPUBufferBindingLayout/type}} 为 {{GPUBufferBindingType/"storage"}} 或 {{GPUBufferBindingType/"read- 仅存储“}}。）
    : <dfn>INDIRECT</dfn>
    ::
        缓冲区可用于存储间接命令参数。（示例：作为 {{GPURenderCommandsMixin/drawIndirect()}} 或 {{GPUComputePassEncoder/dispatchWorkgroupsIndirect()}} 调用的 `indirectBuffer` 参数。）
    : <dfn>QUERY_RESOLVE</dfn>
    ::
        缓冲区可用于捕获查询结果。（示例：作为 {{GPUCommandEncoder/resolveQuerySet()}} 调用的“目标”参数。）
</dl>

### 缓冲区创建 ### {#buffer-creation}

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createBuffer(descriptor)</dfn>
    ::
        创建一个 {{GPUBuffer}}.

        <div algorithm=GPUDevice.createBuffer>
            <div data-timeline=content>
                **Called on:** {{GPUDevice}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUDevice/createBuffer(descriptor)">
                    |descriptor|: 要创建的 {{GPUBuffer}} 的描述。
                </pre>

                **Returns:** {{GPUBuffer}}

                [=Content timeline=] steps:

                1. 使 [|b|, |bi|] 为 [=!=] [$create a new WebGPU object$](|this|, {{GPUBuffer}}, |descriptor|).
                1. 设置 |b|.{{GPUBuffer/size}} 为 |descriptor|.{{GPUBufferDescriptor/size}}.
                1. 设置 |b|.{{GPUBuffer/usage}} 为 |descriptor|.{{GPUBufferDescriptor/usage}}.
                1. 如果 |descriptor|.{{GPUBufferDescriptor/mappedAtCreation}} 为 `true`:
                    1. 设置 |b|.{{GPUBuffer/[[mapping]]}} 为
                        [=?=] [$initialize an active buffer mapping$]，模式为 {{GPUMapMode/WRITE}}
                        范围为 <code>[0, |descriptor|.{{GPUBufferDescriptor/size}}]</code>.
                1. 在 |this| 的 [=设备时间线=]上发起|initialization steps|
                1. 返回 |b|。
            </div>
            <div data-timeline=device>
                [=Device timeline=] |initialization steps|:

                1. 如果以下任何条件没有满足，
                    [$generate a validation error$], 使 |bi| [=无效=], 并停止。

                    <div class=validusage>
                        - |device| 必须 [=有效=]。
                        - |descriptor|.{{GPUBufferDescriptor/usage}} 必须不为 0.
                        - |descriptor|.{{GPUBufferDescriptor/usage}} 必须为 |device|'s
                            [=allowed buffer usages=] 的一个子集。
                        - 如果 |descriptor|.{{GPUBufferDescriptor/usage}} 包含 {{GPUBufferUsage/MAP_READ}}:
                            - |descriptor|.{{GPUBufferDescriptor/usage}} 不得包含除 {{GPUBufferUsage/COPY_DST}} 之外的其他标志。
                        - 如果 |descriptor|.{{GPUBufferDescriptor/usage}} 包含 {{GPUBufferUsage/MAP_WRITE}}:
                            - |descriptor|.{{GPUBufferDescriptor/usage}} 不得包含除 {{GPUBufferUsage/COPY_SRC}} 之外的其他标志。
                        - 如果 |descriptor|.{{GPUBufferDescriptor/size}} 必须 &le;
                            |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxBufferSize}}.
                        - 如果 |descriptor|.{{GPUBufferDescriptor/mappedAtCreation}} 为 `true`:
                            - |descriptor|.{{GPUBufferDescriptor/size}} 必须为 4 的倍数。
                    </div>

                注：如果缓冲区创建失败，并且 |descriptor|.{{GPUBufferDescriptor/mappedAtCreation}} 为“false”，则对 {{GPUBuffer/mapAsync()}} 的任何调用都将被拒绝，因此分配用于启用映射的任何资源都可以而且可能是丢弃或回收。

                 1. 如果 |descriptor|.{{GPUBufferDescriptor/mappedAtCreation}} 为“真”：
                     1. 将 |bi|.[=buffer internals/state=] 设置为“[=buffer internals/state/unavailable=]”。

                     另外：

                     1. 将 |bi|.[=buffer internals/state=] 设置为“[=buffer internals/state/available=]”。

                 1. 为 |bi| 创建设备分配 每个字节都为零。

                     如果分配失败且没有副作用，[$生成内存不足错误$]，生成 |bi| [=无效=]，然后返回。
            </div>
        </div>
</dl>

<div class=example>
    创建一个 128 字节的统一缓冲区，可以写入：

    <pre highlight=js>
        const buffer = gpuDevice.createBuffer({
            size: 128,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });
    </pre>
</div>

### 缓冲区销毁 ### {#buffer-destruction}

不再需要 {{GPUBuffer}} 的应用程序可以通过调用 {{GPUBuffer/destroy()}} 选择在垃圾收集之前失去对它的访问。 销毁缓冲区也会取消映射，释放为映射分配的所有内存。

注：这允许用户代理在所有先前使用它提交的操作完成后回收与 {{GPUBuffer}} 关联的 GPU 内存。

<dl dfn-type=method dfn-for=GPUBuffer>
    : <dfn>destroy()</dfn>
    ::
        销毁 {{GPUBuffer}}.

       注：多次销毁缓冲区是有效的。

        <div algorithm=GPUBuffer.destroy>
            <div data-timeline=content>
                **Called on:** {{GPUBuffer}} |this|.

                **Returns:** {{undefined}}

                [=内容时间线=] 步骤：

                1. 调用 |this|.{{GPUBuffer/unmap()}}.

                <!-- POSTV1(multithreading) tentative text:
                    Note: If the buffer is mapped in a different thread, it is not unmapped.
                    It can be unmapped only from the thread on which it is mapped, either by
                    another call to {{GPUBuffer/destroy()|GPUBuffer.destroy()}},
                    or by {{GPUBuffer/unmap()|GPUBuffer.unmap()}}.
                -->

                1. 在 |this|.{{GPUObjectBase/[[device]]}} 的 [=Device timeline=] 上发布后续步骤。
            </div>
            <div data-timeline=device>
                [=Device timeline=] steps:

                1. 将 |this|.{{GPUBuffer/[[internals]]}}.[=buffer internals/state=] 设置为“[=buffer internals/state/destroyed=]”。
            </div>
        </div>

        注：由于没有进一步的操作可以使用此缓冲区排队，因此实现可以释放资源分配，包括刚刚取消映射的映射内存。
</dl>

## 缓冲区映射 ## {#buffer-mapping}

应用程序可以请求映射 {{GPUBuffer}}，以便它们可以通过代表 {{GPUBuffer}} 分配部分的 {{ArrayBuffer}} 访问其内容。异步请求映射 {{GPUBuffer}}
{{GPUBuffer/mapAsync()}} 以便用户代理可以确保 GPU 在应用程序可以访问其内容之前完成使用 {{GPUBuffer}}。
映射的 {{GPUBuffer}} 不能被 GPU 使用，必须使用 {{GPUBuffer/unmap()}} 取消映射，然后才能将使用它的工作提交到 [=队列时间线=]。

一旦 {{GPUBuffer}} 被映射，应用程序可以使用 {{GPUBuffer/getMappedRange()}} 同步请求访问其内容范围。
返回的 {{ArrayBuffer}} 只能通过 {{GPUBuffer/unmap()}} [=ArrayBuffer/detach|detached=]（直接，或通过 {{GPUBuffer}}.{{GPUBuffer/destroy()}} 或 {{GPUDevice}}.{{GPUDevice/destroy()}})，并且不能是[=ArrayBuffer/transfer|transferred=]。
{{TypeError}} 被试图这样做的任何其他操作抛出。

<!-- POSTV1(multithreading):
Add client-side validation that a mapped buffer can
only be unmapped and destroyed on the worker on which it was mapped. Likewise
{{GPUBuffer/getMappedRange()}} can only be called on that worker.
-->

<script type=idl>
typedef [EnforceRange] unsigned long GPUMapModeFlags;
[Exposed=(Window, DedicatedWorker), SecureContext]
namespace GPUMapMode {
    const GPUFlagsConstant READ  = 0x0001;
    const GPUFlagsConstant WRITE = 0x0002;
};
</script>

{{GPUMapMode}} 标志确定调用 {{GPUBuffer/mapAsync()}} 时如何映射 {{GPUBuffer}}：

<dl dfn-type=const dfn-for=GPUMapMode>
    : <dfn>READ</dfn>
    ::
        仅对使用 {{GPUBufferUsage/MAP_READ}} 用法创建的缓冲区有效。

         映射缓冲区后，调用 {{GPUBuffer/getMappedRange()}} 将返回包含缓冲区当前值的 {{ArrayBuffer}}。 在调用 {{GPUBuffer/unmap()}} 后，将丢弃对返回的 {{ArrayBuffer}} 的更改。

    : <dfn>WRITE</dfn>
    ::
        仅对使用 {{GPUBufferUsage/MAP_WRITE}} 用法创建的缓冲区有效。

         映射缓冲区后，调用 {{GPUBuffer/getMappedRange()}} 将返回包含缓冲区当前值的 {{ArrayBuffer}}。 在调用 {{GPUBuffer/unmap()}} 后，对返回的 {{ArrayBuffer}} 的更改将存储在 {{GPUBuffer}} 中。

         注：由于 {{GPUBufferUsage/MAP_WRITE}} 缓冲区使用只能与 {{GPUBufferUsage/COPY_SRC}} 缓冲区使用相结合，写入映射永远不会返回 GPU 生成的值，返回的 {{ArrayBuffer}} 将 仅包含默认初始化数据（零）或网页在先前映射期间写入的数据。
</dl>

<dl dfn-type=method dfn-for=GPUBuffer>
    : <dfn>mapAsync(mode, offset, size)</dfn>
    ::
        映射 {{GPUBuffer}} 的给定范围，并在 {{GPUBuffer}} 的内容准备好使用 {{GPUBuffer/getMappedRange()}} 访问时解析返回的 {{Promise}}。

         返回的 {{Promise}} 的决议**仅**表示缓冲区已被映射。
         它不保证 [=content timeline=] 可见的任何其他操作的完成，尤其不暗示从 {{GPUQueue/onSubmittedWorkDone()}} 或 {{GPUBuffer/ 其他 {{GPUBuffer}} 上的 mapAsync()}} 已解决。

         从 {{GPUQueue/onSubmittedWorkDone()}} 返回的 {{Promise}} 的决议**确实**意味着在 {{GPUBuffer}} 上完成该调用之前进行的 {{GPUBuffer/mapAsync()}} 用于该队列的最后专门调用。
        
        <div algorithm=GPUBuffer.mapAsync>
            <div data-timeline=content>
                **Called on:** {{GPUBuffer}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUBuffer/mapAsync(mode, offset, size)">
                     |mode|: 缓冲区是否应该映射为读取或写入。
                     |offset|: 以字节为单位的偏移量到缓冲区到要映射的范围的开始。
                     |size|: 要映射的范围的大小（以字节为单位）。
                </pre>

                **Returns:** {{Promise}}&lt;{{undefined}}&gt;

                [=内容时间线=] 步骤：

                1. 让 <var data-timeline=content>contentTimeline</var> 成为当前 [=内容时间线=]。
                 1. 如果 |this|.{{GPUBuffer/[[pending_map]]}} 不是 `null`：
                     1. 返回 [=a promise rejected with=] {{OperationError}}。
                 1. 让|p| 成为新的{{Promise}}。
                 1. 将 |this|.{{GPUBuffer/[[pending_map]]}} 设置为 |p|。
                 1. 发布|验证步骤| 在 |this| 的 [=Device timeline=] 上。{{GPUObjectBase/[[device]]}}。
                 1. 返回 |p|。
            </div>
            <div data-timeline=device>
                [=设备时间线=] |validation steps|:

                1. 如果 |size| 为 `undefined`:
                    1. 使 |rangeSize| 为 max(0, |this|.{{GPUBuffer/size}} - |offset|).

                    否则：

                    1. 使 |rangeSize| 为 |size|.

                1. 如果以下任何条件未满足：

                    <div class=validusage>
                        - |this| 是一个 [=有效=] {{GPUBuffer}}。
                        - |this|.{{GPUBuffer/[[internals]]}}.[=buffer internals/state=] 是 "[=buffer internals/state/available=]"。
                        - |offset| 是8的倍数。
                        - |rangeSize| 是4的倍数。
                        - |offset| + |rangeSize| &le; |this|.{{GPUBuffer/size}}
                        - |mode| 仅包含 {{GPUMapMode}} 定义的位。
                        - |mode| 包含 {{GPUMapMode/READ}} 或 {{GPUMapMode/WRITE}} 之一。
                        - 如果 |mode| 包含 {{GPUMapMode/READ}} 那么 |this|.{{GPUBuffer/usage}} 必须包含 {{GPUBufferUsage/MAP_READ}}.
                        - 如果 |mode| 包含 {{GPUMapMode/WRITE}} 那么 |this|.{{GPUBuffer/usage}} 必须包含 {{GPUBufferUsage/MAP_WRITE}}.
                    </div>

                    Then:

                    1. 在 <var data-timeline=content>contentTimeline</var> 上发起 <var data-timeline=content>map failure steps</var>
                    1. [$Generate a validation error$].
                    1. 返回。

                1. 设置 |this|.{{GPUBuffer/[[internals]]}}.[=buffer internals/state=] 为 "[=buffer internals/state/unavailable=]".

                    注：由于缓冲区已映射，因此其内容不能在此完成和 {{GPUBuffer/unmap()}} 之间更改。
                1. 如果 |this|.{{GPUObjectBase/[[device]]}} 丢失，或者当它 [=lose the device|becomes lost=] 时：

                     1. 在<var data-timeline=content>内容时间线</var>上运行<var data-timeline=content>地图失败步骤</var>。

                     否则，在未指定的点：

                     - 在完成<span data-timeline=queue>当前使用|this|的排队操作</span>后，
                     - 并且不晚于 [=device timeline=] 收到 <span data-timeline=queue>all currently-enqueued operations</span> 完成通知后的下一个 [=device timeline=] 操作（无论它们是否 使用 |这个|),

                     运行以下步骤：

                     1. 让 |internalStateAtCompletion| 是 |this|.{{GPUBuffer/[[internals]]}}.[=buffer internals/state=]。

                         注：当且仅当此时缓冲区由于 {{GPUBuffer/unmap()}} 调用再次变为“[=buffer internals/state/available=]”，则 {{GPUBuffer/[[pending_map ]]}} != |p| 下面，所以映射将不会在下面的步骤中成功。
                     1. 让 |dataForMappedRegion| 是|this|的内容 从偏移量 |offset| 开始，对于 |rangeSize| 字节。
                     1. 在 <var data-timeline=content>contentTimeline</var> 上运行<var data-timeline=content>map success steps</var>。

                    <!-- POSTV1(multi-queue): this may be better described using queue-transfer language. -->
            </div>
            <div data-timeline=content>
                [=内容时间线=] <var data-timeline=content>map success steps</var>:

                1. 如果 |this|.{{GPUBuffer/[[pending_map]]}} != |p|:

                    注：映射已被 {{GPUBuffer/unmap()}} 取消。

                    1. [=断言=] |p| 被拒绝。
                    1. 返回。
                1. [=断言=] |p| 被挂起。
                1. [=断言=] |internalStateAtCompletion| 为 "[=buffer internals/state/unavailable=]".
                1. 使 |mapping| 为 [$initialize an active buffer mapping$]，模式为 |mode| 且范围为 <code>[|offset|, |offset| + |rangeSize|]</code>.

                    如果分配失败：

                    1. 设置 |this|.{{GPUBuffer/[[pending_map]]}} 为 `null`,
                        且以一个 {{RangeError}} [=reject=] |p|。
                    1. 返回。
                1. 设置 |mapping|.[=active buffer mapping/data=] 的内容为 |dataForMappedRegion|.
                1. 设置 |this|.{{GPUBuffer/[[mapping]]}} 为 |mapping|.
                1. 设置 |this|.{{GPUBuffer/[[pending_map]]}} 为 `null`,且 [=resolve=] |p|.
            </div>
            <div data-timeline=content>
                [=Content timeline=] <var data-timeline=content>map failure steps</var>:

                1. 如果 |this|.{{GPUBuffer/[[pending_map]]}} != |p|:

                    注：映射已被 {{GPUBuffer/unmap()}} 取消。

                    1. [=断言=] |p| 已被拒绝。
                    1. 返回。
                1. [=断言=] |p| 仍被挂起。
                1. 设置 |this|.{{GPUBuffer/[[pending_map]]}} 为 `null`,并且以一个 {{OperationError}} [=拒绝=] |p|
            </div>
        </div>

    : <dfn>getMappedRange(offset, size)</dfn>
    ::
        返回一个 {{ArrayBuffer}}，其中包含给定映射范围内 {{GPUBuffer}} 的内容。

        <div algorithm=GPUBuffer.getMappedRange>
            <div data-timeline=content>
                **Called on:** {{GPUBuffer}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUBuffer/getMappedRange(offset, size)">
                     |offset|: 缓冲区中以字节为单位的偏移量，以从中返回缓冲区内容。
                     |size|: 要返回的 {{ArrayBuffer}} 的字节大小。
                </pre>

                **Returns:** {{ArrayBuffer}}

                [=内容时间线=] 步骤：

                 1.如果|size| 缺失：
                     1. 让 |rangeSize| 为最大值（0，|this|.{{GPUBuffer/size}} - |offset|）。

                     否则，让 |rangeSize| 为 |size|。

                 1. 如果不满足以下任何条件，则抛出 {{OperationError}} 并停止。

                    <div class=validusage>
                        - |this|.{{GPUBuffer/[[mapping]]}} 不为 `null`.
                        - |offset| 是8的倍数。
                        - |rangeSize| 是4的倍数。
                        - |offset| &ge; |this|.{{GPUBuffer/[[mapping]]}}.[=active buffer mapping/range=][0].
                        - |offset| + |rangeSize| &le; |this|.{{GPUBuffer/[[mapping]]}}.[=active buffer mapping/range=][1].
                        - [|offset|, |offset| + |rangeSize|) 不与 |this|.{{GPUBuffer/[[mapping]]}}.[=active buffer mapping/views=] 中的范围重合。

                        注：获取 {{GPUBuffer}} 的映射范围始终有效，即 {{GPUBufferDescriptor/mappedAtCreation}}，即使它是 [=无效=]的，因为 [=内容时间线=] 可能不知道它是无效的。                    </div>

                1. 使 |data| 为 |this|.{{GPUBuffer/[[mapping]]}}.[=active buffer mapping/data=].

                1. 使 |view| 为 [=!=] [=ArrayBuffer/create|create an ArrayBuffer=]，大小为 |rangeSize|,
                    但是它的指针在偏移处（|offset| - {{GPUBuffer/[[mapping]]}}.[=active buffer mapping/range=][0]）可变地引用了 |data| 的内容。

                    注：这里可能不会抛出 {{RangeError}}，因为 |data| 已经在 {{GPUBuffer/mapAsync()}} 或 {{GPUDevice/createBuffer()}} 期间分配。

                1. 设置 |view|.{{ArrayBuffer/[[ArrayBufferDetachKey]]}} 为 "WebGPUBufferMapping".

                    注：如果尝试 [$DetachArrayBuffer$]，这会导致抛出 {{TypeError}}，{{GPUBuffer/unmap()}} 除外。

                1. [=list/Append=] |view| 至 |this|.{{GPUBuffer/[[mapping]]}}.[=active buffer mapping/views=].

                1. 返回 |view|.

               注：如果 {{GPUBuffer/getMappedRange()}} 在没有检查地图状态的情况下成功，用户代理应考虑发出开发人员可见的警告，方法是等待 {{GPUBuffer/mapAsync()}} 成功，查询 {{GPUBufferMapState/"mapped"}} 的 {{GPUBuffer/mapState}}，或等待稍后的 {{GPUQueue/onSubmittedWorkDone()}} 调用成功。
            </div>
        </div>

    : <dfn>unmap()</dfn>
    ::
        取消 {{GPUBuffer}} 的映射范围并使其内容再次可供 GPU 使用。

        <div algorithm=GPUBuffer.unmap>
            <div data-timeline=content>
                **Called on:** {{GPUBuffer}} |this|.

                **Returns:** {{undefined}}

                [=内容时间线=] 步骤：

                1. 如果 |this|.{{GPUBuffer/[[pending_map]]}} 不为 `null`:
                    1. 以一个 {{AbortError}} [=拒绝=] |this|.{{GPUBuffer/[[pending_map]]}}
                    1. 设置 |this|.{{GPUBuffer/[[pending_map]]}} 为 `null`.

                1. 如果 |this|.{{GPUBuffer/[[mapping]]}} 为 `null`:
                    1. 返回。

                1. 对每个 |this|.{{GPUBuffer/[[mapping]]}}.[=active buffer mapping/views=] 中的 {{ArrayBuffer}} |ab|
                    1. 执行 [$DetachArrayBuffer$](|ab|, "WebGPUBufferMapping").

                1. 使 |bufferUpdate| 为 `null`.

                1. 如果 |this|.{{GPUBuffer/[[mapping]]}}.[=active buffer mapping/mode=] 包含 {{GPUMapMode/WRITE}}:
                    1. 设置 |bufferUpdate| 为 {
                        `data`: |this|.{{GPUBuffer/[[mapping]]}}.[=active buffer mapping/data=],
                        `offset`: |this|.{{GPUBuffer/[[mapping]]}}.[=active buffer mapping/range=][0]
                        }.

                    注：当缓冲区在没有 {{GPUMapMode/WRITE}} 模式的情况下映射，然后取消映射时，应用程序对映射范围 {{ArrayBuffer}} 所做的任何本地修改都将被丢弃，并且不会影响以后映射的内容。

                1. 设置 |this|.{{GPUBuffer/[[mapping]]}} 为 `null`.

                1. 在 |this|.{{GPUObjectBase/[[device]]}} 的 [=Device timeline=] 上运行后续步骤。
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. 如果|this|.{{GPUObjectBase/[[device]]}}是[=无效=]的，返回。
                 1. 如果 |bufferUpdate| 不为 `null`：

                     1. 在 |this|.{{GPUObjectBase/[[device]]}}.{{GPUDevice/queue}} 的 [=队列时间线=] 上执行以下步骤：

                         <div data-timeline=queue>
                             [=队列时间线=] 步骤：

                             1.更新|this|的内容 在偏移 |bufferUpdate|.`offset` 与数据 |bufferUpdate|.`data` 处。
                         </div>
                 1. 将 |this|.{{GPUBuffer/[[internals]]}}.[=buffer internals/state=] 设置为 "[=buffer internals/state/available=]"。
            </div>
        </div>
</dl>


# 纹理与纹理视图 # {#textures}

<h3 id=gputexture data-dfn-type=interface>`GPUTexture`
<span id=texture-interface></span>
</h3>

问题：删除此定义：<dfn dfn>texture</dfn>

一张纹理由一个或多个<dfn dfn>纹理子资源</dfn>组成，每个纹理子资源由 [=mipmap level=] 唯一标识，并且仅对于 {{GPUTextureDimension/2d}} 纹理，[=array layer=] 和 [ =方面=]。

一个 [=texture subresource=] 是一个 [=subresource=]：每个都可以在一个 [=usage scope=] 中用于不同的 [=internal usages=]。

<dfn dfn>mipmap level</dfn> 中的每个子资源在每个空间维度上大约是较低级别中相应资源大小的一半（参见 [=logical miplevel-specific texture extent=]）。 级别 0 中的子资源具有纹理本身的尺寸。
这些通常用于表示纹理的细节级别。 {{GPUSampler}} 和 WGSL 提供了在细节层次之间选择和插值的工具，明确地或自动地。

{{GPUTextureDimension/"2d"}} 纹理可以是<dfn dfn>array layer</dfn>的数组。
层中的每个子资源与其他层中的相应资源大小相同。
对于非二维纹理，所有子资源的数组层索引均为 0。

每个子资源都有一个<dfn dfn>方面</dfn>。
颜色纹理只有一个方面：<dfn dfn for=aspect>color</dfn>。
[=深度或模板格式=] 纹理可能有多个方面：
<dfn dfn for=aspect>depth</dfn> 方面，<dfn dfn for=aspect>stencil</dfn> 方面，或两者兼而有之，并且可以以特殊方式使用，例如 {{GPURenderPassDescriptor/depthStencilAttachment} } 和 {{GPUTextureSampleType/"depth"}} 绑定。

{{GPUTextureDimension/"3d"}} 纹理可能有多个 <dfn dfn>切片</dfn>，每个都是纹理中特定 `z` 值处的二维图像。
切片不是单独的子资源。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUTexture {
    GPUTextureView createView(optional GPUTextureViewDescriptor descriptor = {});

    undefined destroy();

    readonly attribute GPUIntegerCoordinate width;
    readonly attribute GPUIntegerCoordinate height;
    readonly attribute GPUIntegerCoordinate depthOrArrayLayers;
    readonly attribute GPUIntegerCoordinate mipLevelCount;
    readonly attribute GPUSize32 sampleCount;
    readonly attribute GPUTextureDimension dimension;
    readonly attribute GPUTextureFormat format;
    readonly attribute GPUTextureUsageFlags usage;
};
GPUTexture includes GPUObjectBase;
</script>

{{GPUTexture}} 具有以下属性

<dl dfn-type=attribute dfn-for=GPUTexture>
    : <dfn>width</dfn>
    ::
        此 {{GPUTexture}} 的宽度。

    : <dfn>height</dfn>
    ::
        此 {{GPUTexture}} 的高度。

    : <dfn>depthOrArrayLayers</dfn>
    ::
        此 {{GPUTexture}} 的深度或层数。

    : <dfn>mipLevelCount</dfn>
    ::
        此 {{GPUTexture}} 的 mip 级别数。

    : <dfn>sampleCount</dfn>
    ::
        {{GPUTexture}} 的采样数。

    : <dfn>dimension</dfn>
    ::
        此 {{GPUTexture}} 的每个子资源的纹素集的维度。

    : <dfn>format</dfn>
    ::
        此 {{GPUTexture}} 的格式。

    : <dfn>usage</dfn>
    ::
        此 {{GPUTexture}} 的允许用法。
</dl>

{{GPUTexture}} 有以下内部插槽：

<dl dfn-type=attribute dfn-for=GPUTexture>
    : <dfn>\[[size]]</dfn>, 类型为 {{GPUExtent3D}}
    ::
        纹理的大小（与 {{GPUTexture/width}}、{{GPUTexture/height}} 和 {{GPUTexture/depthOrArrayLayers}} 属性相同）。

    : <dfn>\[[viewFormats]]</dfn>, 类型为 [=sequence=]&lt;{{GPUTextureFormat}}&gt;
    ::
        在这个 {{GPUTexture}} 上创建视图时可以使用 {{GPUTextureViewDescriptor}}.{{GPUTextureViewDescriptor/format}} 的一组 {{GPUTextureFormat}}。

    : <dfn>\[[destroyed]]</dfn>, 类型为 `boolean`, 初始值为 false
    ::
        如果纹理被销毁，它就不能再用于任何操作，并且它的底层内存可以被释放。
</dl>

<div algorithm>
    <dfn abstract-op>compute render extent</dfn>(baseSize, mipLevel)

    **Arguments:**

    - {{GPUExtent3D}} |baseSize|
    - {{GPUSize32}} |mipLevel|

    **Returns:** {{GPUExtent3DDict}}

    1. 使 |extent| 为一个新的 {{GPUExtent3DDict}} 对象。
    1. 设置 |extent|.{{GPUExtent3DDict/width}} 为 max(1, |baseSize|.[=GPUExtent3D/width=] &Gt; |mipLevel|).
    1. 设置 |extent|.{{GPUExtent3DDict/height}} 为 max(1, |baseSize|.[=GPUExtent3D/height=] &Gt; |mipLevel|).
    1. 设置 |extent|.{{GPUExtent3DDict/depthOrArrayLayers}} 为 1.
    1. 返回 |extent|.
</div>

[=texture=] 的 <dfn dfn>logical miplevel-specific texture extent</dfn> 是 [=texture=] 在特定 miplevel 的纹素大小。
它是通过以下过程计算的：

<div algorithm>
    <dfn abstract-op>Logical miplevel-specific texture extent</dfn>(descriptor, mipLevel)

    **Arguments:**

    - {{GPUTextureDescriptor}} |descriptor|
    - {{GPUSize32}} |mipLevel|

    **Returns:** {{GPUExtent3DDict}}

    1. 使 |extent| 为一个新的 {{GPUExtent3DDict}} 对象.
    1. 如果 |descriptor|.{{GPUTextureDescriptor/dimension}} 为:

        <dl class=switch>
            : {{GPUTextureDimension/"1d"}}
            ::
                - 设置 |extent|.{{GPUExtent3DDict/width}} 为 max(1, |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/width=] &Gt; |mipLevel|).
                - 设置 |extent|.{{GPUExtent3DDict/height}} 为 1.
                - 设置 |extent|.{{GPUExtent3DDict/depthOrArrayLayers}} 为 1.

            : {{GPUTextureDimension/"2d"}}
            ::
                - 设置 |extent|.{{GPUExtent3DDict/width}} 为 max(1, |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/width=] &Gt; |mipLevel|).
                - 设置 |extent|.{{GPUExtent3DDict/height}} 为 max(1, |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/height=] &Gt; |mipLevel|).
                - 设置 |extent|.{{GPUExtent3DDict/depthOrArrayLayers}} 为 |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/depthOrArrayLayers=].

            : {{GPUTextureDimension/"3d"}}
            ::
                - 设置 |extent|.{{GPUExtent3DDict/width}} 为 max(1, |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/width=] &Gt; |mipLevel|).
                - 设置 |extent|.{{GPUExtent3DDict/height}} 为 max(1, |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/height=] &Gt; |mipLevel|).
                - 设置 |extent|.{{GPUExtent3DDict/depthOrArrayLayers}} 为 max(1, |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/depthOrArrayLayers=] &Gt; |mipLevel|).
        </dl>
    1. 返回 |extent|.
</div>

<dfn dfn>特定miplevel物理纹理尺寸</dfn>是指在特定mip级别的纹理大小（以像素为单位），包括可能的额外填充以形成纹理中的完整 [ =像素块= ]。
它通过以下步骤计算得出：

<div algorithm>
    <dfn abstract-op>Physical miplevel-specific texture extent</dfn>(descriptor, mipLevel)

    **Arguments:**

    - {{GPUTextureDescriptor}} |descriptor|
    - {{GPUSize32}} |mipLevel|

    **Returns:** {{GPUExtent3DDict}}

    1. 使 |extent| 为一个新的 {{GPUExtent3DDict}} 对象。
    1. 使 |logicalExtent| 为 [=logical miplevel-specific texture extent=](|descriptor|, |mipLevel|).
    1. 如果 |descriptor|.{{GPUTextureDescriptor/dimension}} 为：

        <dl class=switch>
            : {{GPUTextureDimension/"1d"}}
            ::
                - 设置 |extent|.{{GPUExtent3DDict/width}} 为 |logicalExtent|.[=GPUExtent3D/width=] rounded up to the nearest multiple of |descriptor|'s [=texel block width=].
                - 设置 |extent|.{{GPUExtent3DDict/height}} 为 1.
                - 设置 |extent|.{{GPUExtent3DDict/depthOrArrayLayers}} 为 1.

            : {{GPUTextureDimension/"2d"}}
            ::
                - 设置 |extent|.{{GPUExtent3DDict/width}} 为 |logicalExtent|.[=GPUExtent3D/width=] rounded up to the nearest multiple of |descriptor|'s [=texel block width=].
                - 设置 |extent|.{{GPUExtent3DDict/height}} 为 |logicalExtent|.[=GPUExtent3D/height=] rounded up to the nearest multiple of |descriptor|'s [=texel block height=].
                - 设置 |extent|.{{GPUExtent3DDict/depthOrArrayLayers}} 为 |logicalExtent|.[=GPUExtent3D/depthOrArrayLayers=].

            : {{GPUTextureDimension/"3d"}}
            ::
                - 设置 |extent|.{{GPUExtent3DDict/width}} 为 |logicalExtent|.[=GPUExtent3D/width=] rounded up to the nearest multiple of |descriptor|'s [=texel block width=].
                - 设置 |extent|.{{GPUExtent3DDict/height}} 为 |logicalExtent|.[=GPUExtent3D/height=] rounded up to the nearest multiple of |descriptor|'s [=texel block height=].
                - 设置 |extent|.{{GPUExtent3DDict/depthOrArrayLayers}} 为 |logicalExtent|.[=GPUExtent3D/depthOrArrayLayers=].
        </dl>
    1. 返回 |extent|.
</div>

<h4 id=gputexturedescriptor data-dfn-type=dictionary>`GPUTextureDescriptor`
<span id=GPUTextureDescriptor></span>
<span id=dictdef-gputexturedescriptor></span>
</h4>

<script type=idl>
dictionary GPUTextureDescriptor
         : GPUObjectDescriptorBase {
    required GPUExtent3D size;
    GPUIntegerCoordinate mipLevelCount = 1;
    GPUSize32 sampleCount = 1;
    GPUTextureDimension dimension = "2d";
    required GPUTextureFormat format;
    required GPUTextureUsageFlags usage;
    sequence<GPUTextureFormat> viewFormats = [];
};
</script>

{{GPUTextureDescriptor}} 具有以下成员：

<dl dfn-type=dict-member dfn-for=GPUTextureDescriptor>
    : <dfn>size</dfn>
    ::
        纹理的宽度、高度和深度或层数。

    : <dfn>mipLevelCount</dfn>
    ::
        纹理将包含的 mip 级别数。

    : <dfn>sampleCount</dfn>
    ::
        纹理的样本数量。{{GPUTextureDescriptor/sampleCount}} &gt; `1` 表示多重采样纹理。

    : <dfn>dimension</dfn>
    ::
        纹理是一维的、二维层的数组还是三维的。

    : <dfn>format</dfn>
    ::
        纹理的格式。

    : <dfn>usage</dfn>
    ::
        纹理的允许用途。

    : <dfn>viewFormats</dfn>
    ::
        指定在调用 {{GPUTexture/createView()}} 时允许的 {{GPUTextureViewDescriptor/format}} 值（除实际的 {{GPUTextureDescriptor/format}} 之外）。

        <div class=note>
        注：
            向该列表添加格式可能会对性能产生显著影响，因此最好避免不必要地添加格式。

            实际性能影响高度依赖于目标系统；开发者必须测试各种系统，以了解其对特定应用的影响。
            例如，在某些系统上，任何具有 {{GPUTextureDescriptor/format}} 或
            {{GPUTextureDescriptor/viewFormats}} 条目（包括
            {{GPUTextureFormat/"rgba8unorm-srgb"}}）的纹理性能都会比一个没有该项的
            {{GPUTextureFormat/"rgba8unorm"}} 纹理低一些。
            在其他系统上，针对其他格式和格式组合也存在类似的注意事项。
        </div>

        此列表中的格式必须与纹理格式[=纹理视图格式兼容=]。

        <div algorithm>
            如果两个{{GPUTextureFormat}}s |format| 和 |viewFormat| 是<dfn dfn for=“”>纹理视图格式兼容的</dfn>：

            - |format| 等于 |viewFormat|, 或
            - |format| 和 |viewFormat| 区别仅在于它们是否为 `srgb` 格式（具有 `-srgb` 后缀）。

            问题(gpuweb/gpuweb#168): 定义更大的兼容类。
        </div>
</dl>

<script type=idl>
enum GPUTextureDimension {
    "1d",
    "2d",
    "3d"
};
</script>

<dl dfn-type=enum-value dfn-for=GPUTextureDimension>
    : <dfn>"1d"</dfn>
    ::
        指定具有一维宽度的纹理。

    : <dfn>"2d"</dfn>
    ::
        指定具有宽度和高度并且可能具有层的纹理。 只有 {{GPUTextureDimension/"2d"}} 纹理可以有 mipmaps、多重采样、使用压缩或深度/模板格式，并用作渲染附件。

    : <dfn>"3d"</dfn>
    ::
        指定具有宽度、高度和深度的纹理。
</dl>

### 纹理使用 ### {#texture-usage}

<script type=idl>
typedef [EnforceRange] unsigned long GPUTextureUsageFlags;
[Exposed=(Window, DedicatedWorker), SecureContext]
namespace GPUTextureUsage {
    const GPUFlagsConstant COPY_SRC          = 0x01;
    const GPUFlagsConstant COPY_DST          = 0x02;
    const GPUFlagsConstant TEXTURE_BINDING   = 0x04;
    const GPUFlagsConstant STORAGE_BINDING   = 0x08;
    const GPUFlagsConstant RENDER_ATTACHMENT = 0x10;
};
</script>

{{GPUTextureUsage}} 标志决定了 {{GPUTexture}} 在创建后如何使用：

<dl dfn-type=const dfn-for=GPUTextureUsage>
    : <dfn>COPY_SRC</dfn>
    ::
        纹理可以用作复制操作的来源。 （示例：作为 {{GPUCommandEncoder/copyTextureToTexture()}} 或 {{GPUCommandEncoder/copyTextureToBuffer()}} 调用的 `source` 参数。）
    : <dfn>COPY_DST</dfn>
    ::
        纹理可用作复制或写入操作的目标。 （示例：作为 {{GPUCommandEncoder/copyTextureToTexture()}} 或 {{GPUCommandEncoder/copyBufferToTexture()}} 调用的“目标”参数，或作为 {{GPUQueue/writeTexture()}} 调用的目标。）
    
    : <dfn>TEXTURE_BINDING</dfn>
    ::
        纹理可以绑定用作着色器中的采样纹理（示例：作为绑定组 {{GPUTextureBindingLayout}} 的条目。）

    : <dfn>STORAGE_BINDING</dfn>
    ::
        纹理可以绑定用作着色器中的存储纹理（示例：作为 {{GPUStorageTextureBindingLayout}} 的绑定组条目。）

    : <dfn>RENDER_ATTACHMENT</dfn>
    ::
        纹理可以用作渲染过程中的颜色或深度/模板附件。 （示例：作为 {{GPURenderPassColorAttachment}}.{{GPURenderPassColorAttachment/view}} 或 {{GPURenderPassDepthStencilAttachment}}.{{GPURenderPassDepthStencilAttachment/view}}。）
</dl>

<div algorithm>
    <dfn abstract-op>maximum mipLevel count</dfn>(dimension, size)

    **Arguments:**

    - {{GPUTextureDescriptor/dimension}} |dimension|
    - {{GPUTextureDescriptor/size}} |size|

    1. 计算最大维度值 |m|：
        - 如果 |dimension| 为：

            <dl class=switch>
                : {{GPUTextureDimension/"1d"}}
                :: 返回 1.

                : {{GPUTextureDimension/"2d"}}
                :: 使 |m| = max(|size|.[=GPUExtent3D/width=], |size|.[=GPUExtent3D/height=]).

                : {{GPUTextureDimension/"3d"}}
                :: 使 |m| = max(max(|size|.[=GPUExtent3D/width=], |size|.[=GPUExtent3D/height=]), |size|.[=GPUExtent3D/depthOrArrayLayer=]).
            </dl>
    1. 返回 floor(log<sub>2</sub>(|m|)) + 1.
</div>

### 纹理创建 ### {#texture-creation}

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createTexture(descriptor)</dfn>
    ::
        创建一个 {{GPUTexture}}.

        <div algorithm=GPUDevice.createTexture>
            <div data-timeline=content>
                **Called on:** {{GPUDevice}} this.

                **Arguments:**

                <pre class=argumentdef for="GPUDevice/createTexture(descriptor)">
                    |descriptor|: 要创建的 {{GPUTexture}} 的描述。
                </pre>

                **Returns:** {{GPUTexture}}

                [=内容时间线=] 步骤：

                1. [=?=] [$validate GPUExtent3D shape$](|descriptor|.{{GPUTextureDescriptor/size}}).
                1. [=?=] 使用 |this|.{{GPUObjectBase/[[device]]}} 验证|descriptor|.{{GPUTextureDescriptor/format}} 所需的纹理格式特性。
                1. 验证|descriptor|.{{GPUTextureDescriptor/viewFormats}}中每个元素所需的 [=?=] [$纹理格式所需特性$] 与 |this|.{{GPUObjectBase/[[device]]}}。
                1. 使 |t| 为一个新的 {{GPUTexture}} 对象。
                1. 设置 |t|.{{GPUTexture/width}} 为 |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/width=].
                1. 设置 |t|.{{GPUTexture/height}} 为 |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/height=].
                1. 设置 |t|.{{GPUTexture/depthOrArrayLayers}} 为 |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/depthOrArrayLayers=].
                1. 设置 |t|.{{GPUTexture/mipLevelCount}} 为 |descriptor|.{{GPUTextureDescriptor/mipLevelCount}}.
                1. 设置 |t|.{{GPUTexture/sampleCount}} 为 |descriptor|.{{GPUTextureDescriptor/sampleCount}}.
                1. 设置 |t|.{{GPUTexture/dimension}} 为 |descriptor|.{{GPUTextureDescriptor/dimension}}.
                1. 设置 |t|.{{GPUTexture/format}} 为 |descriptor|.{{GPUTextureDescriptor/format}}.
                1. 设置 |t|.{{GPUTexture/usage}} 为 |descriptor|.{{GPUTextureDescriptor/usage}}.
                1. 在 |this| 的 [=设备时间线=] 上发起 |initialization steps|。
                1. 返回 |t|。
            </div>
            <div data-timeline=device>
                [=设备时间线=] |initialization steps|:

                1. 如果以下任何条件不满足，产生验证错误，使得 |t| 为 [=无效=]，并停止。

                    <div class=validusage>
                        - 验证 GPUTextureDescriptor (|this|, |descriptor|) 返回 `true`.
                    </div>

                1. 设置 |t|.{{GPUTexture/[[size]]}} 为 |descriptor|.{{GPUTextureDescriptor/size}}.
                1. 设置 |t|.{{GPUTexture/[[viewFormats]]}} 为 |descriptor|.{{GPUTextureDescriptor/viewFormats}}.
            </div>
        </div>
</dl>

<div algorithm class=validusage>
    <dfn abstract-op>验证 GPUTextureDescriptor</dfn>({{GPUDevice}} |this|, {{GPUTextureDescriptor}} |descriptor|):

    如果满足以下所有要求，则返回“true”，否则返回“false”：

    - |this| 必须为一个 [=有效=] {{GPUDevice}}.
    - |descriptor|.{{GPUTextureDescriptor/usage}} 必须不为 0.
    - |descriptor|.{{GPUTextureDescriptor/usage}} 必须只包含在 |this| 的 [=允许的纹理用途=] 中出现的位。
    - |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/width=],
        |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/height=],
        和 |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/depthOrArrayLayers=] 必须 &gt; 零。
    - |descriptor|.{{GPUTextureDescriptor/mipLevelCount}} 必须 &gt; zero。
    - |descriptor|.{{GPUTextureDescriptor/sampleCount}} 必须为 1 或 4。
    - 如果 |descriptor|.{{GPUTextureDescriptor/dimension}} 为:

        <dl class=switch>
            : {{GPUTextureDimension/"1d"}}
            ::
                - |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/width=] 必须 &le;
                    |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension1D}}.
                - |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/height=] 必须为 1.
                - |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/depthOrArrayLayers=] 必须为 1.
                - |descriptor|.{{GPUTextureDescriptor/sampleCount}} 必须为 1.
                - |descriptor|.{{GPUTextureDescriptor/format}} 必须不为 [=compressed format=] 或 [=depth-or-stencil format=].

            : {{GPUTextureDimension/"2d"}}
            ::
                - |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/width=] 必须 &le;
                    |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension2D}}.
                - |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/height=] 必须 &le;
                    |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension2D}}.
                - |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/depthOrArrayLayers=] 必须 &le;
                    |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureArrayLayers}}.

            : {{GPUTextureDimension/"3d"}}
            ::
                - |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/width=] 必须 &le;
                    |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension3D}}。
                - |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/height=] 必须 &le;
                    |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension3D}}。
                - |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/depthOrArrayLayers=] 必须 &le;
                    |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension3D}}。
                - |descriptor|.{{GPUTextureDescriptor/sampleCount}} 必须 1。
                - |descriptor|.{{GPUTextureDescriptor/format}} 必须不为 [=compressed format=] or [=depth-or-stencil format=]。
        </dl>
    - |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/width=] 必须为 [=texel block width=] 的倍数。
    - |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/height=] 必须为 [=texel block height=] 的倍数。
    - 如果 |descriptor|.{{GPUTextureDescriptor/sampleCount}} > 1:
        - |descriptor|.{{GPUTextureDescriptor/mipLevelCount}} 必须为 1。
        - |descriptor|.{{GPUTextureDescriptor/size}}.[=GPUExtent3D/depthOrArrayLayers=] 必须为 1。
        - |descriptor|.{{GPUTextureDescriptor/usage}} 不能包含 {{GPUTextureUsage/STORAGE_BINDING}} 位。
        - |descriptor|.{{GPUTextureDescriptor/usage}} 必须包含 {{GPUTextureUsage/RENDER_ATTACHMENT}} 位。
        - |descriptor|.{{GPUTextureDescriptor/format}} 必须根据 [[#texture-format-caps]] 支持多重采样。
    - |descriptor|.{{GPUTextureDescriptor/mipLevelCount}} 必须 &le;
        [$maximum mipLevel count$](|descriptor|.{{GPUTextureDescriptor/dimension}}, |descriptor|.{{GPUTextureDescriptor/size}})。
    - 如果 |descriptor|.{{GPUTextureDescriptor/usage}} 包含 {{GPUTextureUsage/RENDER_ATTACHMENT}} 位：
        - |descriptor|.{{GPUTextureDescriptor/format}} 必须为 [=renderable format=].
        - |descriptor|.{{GPUTextureDescriptor/dimension}} 必须为 {{GPUTextureDimension/"2d"}}.
    - 如果 |descriptor|.{{GPUTextureDescriptor/usage}} 包含 {{GPUTextureUsage/STORAGE_BINDING}} 位：
        - 必须在 [[#plain-color-formats]] 表中列出具有 {{GPUTextureUsage/STORAGE_BINDING}} 能力。
    - 对每个 |descriptor|.{{GPUTextureDescriptor/viewFormats}} 中的 |viewFormat|：
        |descriptor|.{{GPUTextureDescriptor/format}} 和 |viewFormat| 必须为
        [=texture view format compatible=].
</div>


<div class=example>
    创建一个具有一个数组层和一个mip等级的16x16、RGBA格式的2D纹理：

    <pre highlight=js>
        const texture = gpuDevice.createTexture({
            size: { width: 16, height: 16 },
            format: 'rgba8unorm',
            usage: GPUTextureUsage.TEXTURE_BINDING,
        });
    </pre>
</div>

### 纹理销毁 ### {#texture-destruction}

一个不再需要{{GPUTexture}}的应用可以在垃圾收集之前选择通过调用{{GPUTexture/destroy()}}来丢失对其的访问。


注：这允许用户代理在使用它完成所有先前提交的操作后回收与{{GPUTexture}}关联的GPU内存。

<dl dfn-type=method dfn-for=GPUTexture>
    : <dfn>destroy()</dfn>
    ::
        销毁 {{GPUTexture}}.

        <div algorithm=GPUTexture.destroy>
            <div data-timeline=content>
                **Called on:** {{GPUTexture}} |this|.

                **Returns:** {{undefined}}

                [=内容时间线=] 步骤：

                1. 设置 |this|.{{GPUTexture/[[destroyed]]}} 为 true.
            </div>
        </div>
</dl>

<h3 id=gputextureview data-dfn-type=interface>`GPUTextureView`
<span id=gpu-textureview></span>
</h3>

一个 {{GPUTextureView}} 是对某个 {{GPUTexture}} 定义的一部分 [=纹理子资源=] 的视图。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUTextureView {
};
GPUTextureView includes GPUObjectBase;
</script>

{{GPUTextureView}} 局有以下内部插槽：

<dl dfn-type=attribute dfn-for=GPUTextureView>
    : <dfn>\[[texture]]</dfn>
    ::
        该视图所对应的{{GPUTexture}}。

    : <dfn>\[[descriptor]]</dfn>
    ::
        {{GPUTextureViewDescriptor}} 描述这个纹理视图。

        {{GPUTextureViewDescriptor}} 的所有可选字段均已定义。

    : <dfn>\[[renderExtent]]</dfn>
    ::
        对于可渲染视图，这是用于渲染的有效 {{GPUExtent3DDict}}。

         注：这个范围取决于 {{GPUTextureViewDescriptor/baseMipLevel}}。
</dl>

<div algorithm="texture view subresources">
一组纹理视图 |view| 的<dfn dfn for=GPUTextureView>子资源</dfn>，具有 {{GPUTextureView/[[descriptor]]}} |desc|，是 |view|.{{GPUTextureView/[[texture]]}} 的子资源的子集，其中的每个子资源 |s| 都满足以下条件：

    - |s| 的 [=mipmap level=] &ge;
        |desc|.{{GPUTextureViewDescriptor/baseMipLevel}} 且 &lt;
        |desc|.{{GPUTextureViewDescriptor/baseMipLevel}} +
        |desc|.{{GPUTextureViewDescriptor/mipLevelCount}}.
    - |s| 的 [=array layer=] &ge;
        |desc|.{{GPUTextureViewDescriptor/baseArrayLayer}} and &lt;
        |desc|.{{GPUTextureViewDescriptor/baseArrayLayer}} +
        |desc|.{{GPUTextureViewDescriptor/arrayLayerCount}}.
    - |s| 的 [=aspect=] 在 |desc|.{{GPUTextureViewDescriptor/aspect}} 的 [=GPUTextureAspect/set of aspects=] 中。

两个 {{GPUTextureView}} 对象之间的<dfn dfn>纹理视图别名</dfn>仅当它们的子资源集合相交时才成立。
</div>

### 纹理视图创建 ### {#texture-view-creation}

<script type=idl>
dictionary GPUTextureViewDescriptor
         : GPUObjectDescriptorBase {
    GPUTextureFormat format;
    GPUTextureViewDimension dimension;
    GPUTextureAspect aspect = "all";
    GPUIntegerCoordinate baseMipLevel = 0;
    GPUIntegerCoordinate mipLevelCount;
    GPUIntegerCoordinate baseArrayLayer = 0;
    GPUIntegerCoordinate arrayLayerCount;
};
</script>

{{GPUTextureViewDescriptor}} 具有以下成员：

<dl dfn-type=dict-member dfn-for=GPUTextureViewDescriptor>
    : <dfn>format</dfn>
    ::
        纹理视图的格式。必须是纹理的 {{GPUTextureDescriptor/format}} 或在其创建过程中指定的 {{GPUTextureDescriptor/viewFormats}} 之一。

    : <dfn>dimension</dfn>
    ::
        纹理视图的维度。

    : <dfn>aspect</dfn>
    ::
        纹理视图可以访问纹理的哪些 {{GPUTextureAspect|aspect(s)}}。

    : <dfn>baseMipLevel</dfn>
    ::
        纹理视图可访问的第一个（最详细的）mipmap 级别。

    : <dfn>mipLevelCount</dfn>
    ::
        纹理视图可以访问多少个 mipmap 级别，以 {{GPUTextureViewDescriptor/baseMipLevel}} 开头。

    : <dfn>baseArrayLayer</dfn>
    ::
        纹理视图可访问的第一个数组层的索引。

    : <dfn>arrayLayerCount</dfn>
    ::
        纹理视图可以访问多少个数组层，以 {{GPUTextureViewDescriptor/baseArrayLayer}} 开头。
</dl>

<script type=idl>
enum GPUTextureViewDimension {
    "1d",
    "2d",
    "2d-array",
    "cube",
    "cube-array",
    "3d"
};
</script>

<dl dfn-type=enum-value dfn-for=GPUTextureViewDimension>
    : <dfn>"1d"</dfn>
    ::
        纹理被视为一维图像。

         对应的WGSL类型：

        - `texture_1d`
        - `texture_storage_1d`

    : <dfn>"2d"</dfn>
    ::
        纹理被视为单个二维图像。

         对应的WGSL类型：

        - `texture_2d`
        - `texture_storage_2d`
        - `texture_multisampled_2d`
        - `texture_depth_2d`
        - `texture_depth_multisampled_2d`

    : <dfn>"2d-array"</dfn>
    ::
        纹理视图被视为二维图像的数组。

         对应的WGSL类型：

        - `texture_2d_array`
        - `texture_storage_2d_array`
        - `texture_depth_2d_array`

    : <dfn>"cube"</dfn>
    ::
        纹理被视为立方体贴图。
         该视图有 6 个数组层，对应于立方体的 [+X, -X, +Y, -Y, +Z, -Z] 面。
         采样是在立方体贴图的各个面上无缝完成的。

         对应的WGSL类型：

        - `texture_cube`
        - `texture_depth_cube`

    : <dfn>"cube-array"</dfn>
    ::
        纹理被视为 n 个立方体贴图的打包数组，
         每个都有 6 个数组层，对应于立方体的 [+X, -X, +Y, -Y, +Z, -Z] 面。
         采样是在立方体贴图的各个面上无缝完成的。

         对应的WGSL类型：

        - `texture_cube_array`
        - `texture_depth_cube_array`

    : <dfn>"3d"</dfn>
    ::
        纹理被视为 3 维图像。

         对应的WGSL类型：

        - `texture_3d`
        - `texture_storage_3d`
</dl>

每个 <dfn enum>GPUTextureAspect</dfn> 值对应一组 [=aspects=]。
<dfn dfn for=GPUTextureAspect>方面集</dfn> 是为下面的每个值定义的。

<script type=idl>
enum GPUTextureAspect {
    "all",
    "stencil-only",
    "depth-only"
};
</script>

<dl dfn-type=enum-value dfn-for=GPUTextureAspect>
    : <dfn>"all"</dfn>
    ::
        所有纹理格式的可用方面都将对纹理视图可访问。对于颜色格式，颜色方面将是可访问的。对于 [=combined depth-stencil format=]，深度和模板方面都将是可访问的。只有一个方面的 [=Depth-or-stencil format=] 将只使该方面可访问。


        [=GPUTextureAspect/set of aspects=] 是 [[=aspect/color=], [=aspect/depth=], [=aspect/stencil=]]。

    : <dfn>"stencil-only"</dfn>
    ::
        仅深度或模板格式的模板方面可以访问纹理视图。


        [=GPUTextureAspect/方面集=]是[[=aspect/stencil=]]。

    : <dfn>"depth-only"</dfn>
    ::
        仅深度方面的 [=depth-or-stencil format=] 格式将可以在纹理视图中访问。


        [=GPUTextureAspect/set of aspects=] 是[=aspect/depth=]。
</dl>

<dl dfn-type=method dfn-for=GPUTexture>
    : <dfn>createView(descriptor)</dfn>
    ::
        创建一个 {{GPUTextureView}}.

        <div class=note>
            注：
            默认情况下，{{GPUTexture/createView()}} 将创建一个可以表示整个纹理的维度视图。例如，在一个具有多个图层的 {{GPUTextureDimension/“2d”}} 纹理上调用 {{GPUTexture/createView()}} 而不指定 {{GPUTextureViewDescriptor/dimension}} 会创建一个 {{GPUTextureViewDimension/“2d-array”}} {{GPUTextureView}}，即使指定了 {{GPUTextureViewDescriptor/arrayLayerCount}} 为 1。


            对于在开发时图层计数未知的源创建的纹理，建议向 {{GPUTexture/createView()}} 提供一个明确的 {{GPUTextureViewDescriptor/dimension}}，以确保着色器兼容性。
        </div>

        <div algorithm=GPUTexture.createView>
            <div data-timeline=content>
                **Called on:** {{GPUTexture}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUTexture/createView(descriptor)">
                    |descriptor|: Description of the {{GPUTextureView}} to create.
                </pre>

                **Returns:** |view|, 类型为 {{GPUTextureView}}.

                [=内容时间线=] 步骤：

                1. 验证 |descriptor|.{{GPUTextureViewDescriptor/format}}与|this|.{{GPUObjectBase/[[device]]}}所需的纹理格式功能。
                1. 使 |view| 为一个新的 {{GPUTextureView}} 对象。
                1. 在 |this| 的 [=设备时间线=] 上发起 |initialization steps|。
                1. 返回 |view|.
            </div>
            <div data-timeline=device>
                [=设备时间线=] |initialization steps|：

                1. 将 |descriptor| 设置为用 |descriptor| 对 |this| 进行[$解析 GPUTextureViewDescriptor 默认值$]的结果。
                1. 如果以下任何条件不满足，生成验证错误，使 |view| [无效]，并停止。

                    <div class=validusage>
                        - |this| 为 [=有效=] 的。
                        - |descriptor|.{{GPUTextureViewDescriptor/aspect}} 必须出现在 |this|.{{GPUTexture/format}} 中。
                        - 如果 |descriptor|.{{GPUTextureViewDescriptor/aspect}} 是 {{GPUTextureAspect/“all”}}：

                            - |descriptor|.{{GPUTextureViewDescriptor/format}} 必须等于 |this|.{{GPUTexture/format}} 或 |this|.{{GPUTexture/[[viewFormats]]}} 中的某个格式。
                            
                            否则：

                            - |descriptor|.{{GPUTextureViewDescriptor/format}} 必须等于 [$解析 GPUTextureAspect$]( |this|.{{GPUTexture/format}}, |descriptor|.{{GPUTextureViewDescriptor/aspect}}) 的结果。

                        - |descriptor|.{{GPUTextureViewDescriptor/mipLevelCount}} 必须 &gt; 0。
                        - |descriptor|.{{GPUTextureViewDescriptor/baseMipLevel}} +
                            |descriptor|.{{GPUTextureViewDescriptor/mipLevelCount}} 必须 &le;
                            |this|.{{GPUTexture/mipLevelCount}}。
                        - |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须 &gt; 0。
                        - |descriptor|.{{GPUTextureViewDescriptor/baseArrayLayer}} +
                            |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须 &le;
                            |this| 的 [$array layer count$]。
                        - 如果 |this|.{{GPUTexture/sampleCount}} &gt; 1,
                            |descriptor|.{{GPUTextureViewDescriptor/dimension}} 必须 {{GPUTextureViewDimension/"2d"}}。
                        - 如果 |descriptor|.{{GPUTextureViewDescriptor/dimension}} 为：

                            <dl class=switch>
                                : {{GPUTextureViewDimension/"1d"}}
                                ::
                                    - |this|.{{GPUTexture/dimension}} 必须为 {{GPUTextureDimension/"1d"}}。
                                    - |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须为 `1`。

                                : {{GPUTextureViewDimension/"2d"}}
                                ::

                                    - |this|.{{GPUTexture/dimension}} 必须为 {{GPUTextureDimension/"2d"}}。
                                    - |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须为 `1`。

                                : {{GPUTextureViewDimension/"2d-array"}}
                                ::
                                    - |this|.{{GPUTexture/dimension}} 必须为 {{GPUTextureDimension/"2d"}}。

                                : {{GPUTextureViewDimension/"cube"}}
                                ::
                                    - |this|.{{GPUTexture/dimension}} 必须为 {{GPUTextureDimension/"2d"}}。
                                    - |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须为 `6`。
                                    - |this|.{{GPUTexture/width}} 必须等于 |this|.{{GPUTexture/height}}。

                                : {{GPUTextureViewDimension/"cube-array"}}
                                ::
                                    - |this|.{{GPUTexture/dimension}} 必须为 {{GPUTextureDimension/"2d"}}。
                                    - |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须为 `6` 的倍数。
                                    - |this|.{{GPUTexture/width}} 必须等于 |this|.{{GPUTexture/height}}。

                                : {{GPUTextureViewDimension/"3d"}}
                                ::
                                    - |this|.{{GPUTexture/dimension}} 必须为 {{GPUTextureDimension/"3d"}}。
                                    - |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须为 `1`。
                            </dl>
                    </div>

                1. 使 |view| 为一个新的 {{GPUTextureView}} 对象。
                1. 设置 |view|.{{GPUTextureView/[[texture]]}} 为 |this|。
                1. 设置 |view|.{{GPUTextureView/[[descriptor]]}} 为 |descriptor|。
                1. 如果 |this|.{{GPUTexture/usage}} 包含 {{GPUTextureUsage/RENDER_ATTACHMENT}}：
                    1. 使 |renderExtent| 为 [$compute render extent$](|this|.{{GPUTexture/[[size]]}}, |descriptor|.{{GPUTextureViewDescriptor/baseMipLevel}})。
                    1. 设置 |view|.{{GPUTextureView/[[renderExtent]]}} 为 |renderExtent|。
            </div>
        </div>
</dl>

<div algorithm>
    当为{{GPUTextureView}}中的|texture| <dfn abstract-op>解析 {{GPUTextureViewDescriptor}} 默认值</dfn>时，执行以下步骤:

    1. 使 |resolved| 为 |descriptor| 的拷贝。
    1. 如果 |resolved|.{{GPUTextureViewDescriptor/format}} 不为 [=map/exist|provided=]：

        1. 令 |format| 为返回的结果 [$解析GPUTextureAspect$]( {{GPUTexture/format}}, |descriptor|.{{GPUTextureViewDescriptor/aspect}}). 
        1. 如果 |format| 是 null:

            - 将 |resolved|.{{GPUTextureViewDescriptor/format}} 设置为 |texture|.{{GPUTexture/format}}。

            否则：

            - 将 |resolved|.{{GPUTextureViewDescriptor/format}} 设置为 |format|。
    1. 如果 |resolved|.{{GPUTextureViewDescriptor/mipLevelCount}} 没有 [=map/exist|provided=]： 
        将 |resolved|.{{GPUTextureViewDescriptor/mipLevelCount}} 设置为 |texture|.{{GPUTexture/mipLevelCount}} &minus; |resolved|.{{GPUTextureViewDescriptor/baseMipLevel}}。
    1. 如果 |resolved|.{{GPUTextureViewDescriptor/dimension}} 没有 [=map/exist|provided=] 且 |texture|.{{GPUTexture/dimension}} 是：

        <dl class=switch>
            : {{GPUTextureDimension/"1d"}}
            :: 设置 |resolved|.{{GPUTextureViewDescriptor/dimension}} 为 {{GPUTextureViewDimension/“1d”}}。

            : {{GPUTextureDimension/"2d"}}
            :: 
                如果 |texture| 的 [$array layer count$] 为 1：

                - 设置 |resolved|.{{GPUTextureViewDescriptor/dimension}} 为 {{GPUTextureViewDimension/"2d"}}。

                否则：

                - 设置 |resolved|.{{GPUTextureViewDescriptor/dimension}} 为 {{GPUTextureViewDimension/"2d-array"}}。

            : {{GPUTextureDimension/"3d"}}
            :: 设置 |resolved|.{{GPUTextureViewDescriptor/dimension}} 为 {{GPUTextureViewDimension/"3d"}}。
        </dl>
    1. 如果 |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} 没有 [=map/exist|provided=] 且 |resolved|.{{GPUTextureViewDescriptor/dimension}} 是：

        <dl class=switch>
            : {{GPUTextureViewDimension/"1d"}}, {{GPUTextureViewDimension/"2d"}}, or
                {{GPUTextureViewDimension/"3d"}}
            :: 设置 |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} 为 `1`。

            : {{GPUTextureViewDimension/"cube"}}
            :: 设置 |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} 为 `6`。

            : {{GPUTextureViewDimension/"2d-array"}} or {{GPUTextureViewDimension/"cube-array"}}
            :: 设置 |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} 为 |texture| 的 [$array layer count$]
                &minus; |resolved|.{{GPUTextureViewDescriptor/baseArrayLayer}}。
        </dl>

    1. Return |resolved|.
</div>

<div algorithm>
    要确定{{GPUTexture}} |texture|的<dfn abstract-op>数组层级计数</dfn>，执行以下步骤：

        1. 如果 |texture|.{{GPUTexture/dimension}} 为：

            <dl class=switch>
                : {{GPUTextureDimension/"1d"}} or {{GPUTextureDimension/"3d"}}
                :: 返回 `1`.

                : {{GPUTextureDimension/"2d"}}
                :: 返回 |texture|.{{GPUTexture/depthOrArrayLayers}}.
            </dl>
</div>

## 纹理格式 ## {#texture-formats}

格式的名称指定组件的顺序、每个组件的位数和组件的数据类型。

- `r`, `g`, `b`, `a` = red, green, blue, alpha
- `unorm` = unsigned normalized
- `snorm` = signed normalized
- `uint` = unsigned int
- `sint` = signed int
- `float` = floating point

如果格式具有-srgb后缀，则在着色器中读取和写入颜色值时将应用从伽玛到线性以及相反的sRGB转换。压缩纹理格式由[=features=]提供。它们的命名应遵循这里的约定，以纹理名作为前缀。例如etc2-rgba8unorm。


<dfn dfn>texel block</dfn>是基于像素的{{GPUTextureFormat}}中纹理的单个可寻址元素，以及基于块的压缩{{GPUTextureFormat}}中的单个压缩块。


<dfn dfn>texel block width</dfn>和<dfn dfn>texel block height</dfn>指定一个[=texel block=]的尺寸。


- 对于基于像素的{{GPUTextureFormat}}，[=texel block width=]和[=texel block height=]始终为1。
- 对于基于块的压缩{{GPUTextureFormat}}，[=texel block width=]是每一行的纹素数量，[=texel block height=]是每个[=texel block=]中纹素行的数量。每种纹理格式的详细列表请参见[=#texture-format-caps=]。

一个{{GPUTextureFormat}}的[=aspect=]的<dfn dfn>texel block copy footprint</dfn>是一个纹理块在[=image copy=]过程中占用的字节数，如果适用的话。


注：
{{GPUTextureFormat}}的<dfn dfn>texel block memory cost</dfn>是存储一个[=texel block=]所需的字节数。并非所有格式都完全定义了此值。
**此值具有信息性质，非规范性质。**

<script type=idl>
enum GPUTextureFormat {
    // 8-bit formats
    "r8unorm",
    "r8snorm",
    "r8uint",
    "r8sint",

    // 16-bit formats
    "r16uint",
    "r16sint",
    "r16float",
    "rg8unorm",
    "rg8snorm",
    "rg8uint",
    "rg8sint",

    // 32-bit formats
    "r32uint",
    "r32sint",
    "r32float",
    "rg16uint",
    "rg16sint",
    "rg16float",
    "rgba8unorm",
    "rgba8unorm-srgb",
    "rgba8snorm",
    "rgba8uint",
    "rgba8sint",
    "bgra8unorm",
    "bgra8unorm-srgb",
    // Packed 32-bit formats
    "rgb9e5ufloat",
    "rgb10a2unorm",
    "rg11b10ufloat",

    // 64-bit formats
    "rg32uint",
    "rg32sint",
    "rg32float",
    "rgba16uint",
    "rgba16sint",
    "rgba16float",

    // 128-bit formats
    "rgba32uint",
    "rgba32sint",
    "rgba32float",

    // Depth/stencil formats
    "stencil8",
    "depth16unorm",
    "depth24plus",
    "depth24plus-stencil8",
    "depth32float",

    // "depth32float-stencil8" feature
    "depth32float-stencil8",

    // BC compressed formats usable if "texture-compression-bc" is both
    // supported by the device/user agent and enabled in requestDevice.
    "bc1-rgba-unorm",
    "bc1-rgba-unorm-srgb",
    "bc2-rgba-unorm",
    "bc2-rgba-unorm-srgb",
    "bc3-rgba-unorm",
    "bc3-rgba-unorm-srgb",
    "bc4-r-unorm",
    "bc4-r-snorm",
    "bc5-rg-unorm",
    "bc5-rg-snorm",
    "bc6h-rgb-ufloat",
    "bc6h-rgb-float",
    "bc7-rgba-unorm",
    "bc7-rgba-unorm-srgb",

    // ETC2 compressed formats usable if "texture-compression-etc2" is both
    // supported by the device/user agent and enabled in requestDevice.
    "etc2-rgb8unorm",
    "etc2-rgb8unorm-srgb",
    "etc2-rgb8a1unorm",
    "etc2-rgb8a1unorm-srgb",
    "etc2-rgba8unorm",
    "etc2-rgba8unorm-srgb",
    "eac-r11unorm",
    "eac-r11snorm",
    "eac-rg11unorm",
    "eac-rg11snorm",

    // ASTC compressed formats usable if "texture-compression-astc" is both
    // supported by the device/user agent and enabled in requestDevice.
    "astc-4x4-unorm",
    "astc-4x4-unorm-srgb",
    "astc-5x4-unorm",
    "astc-5x4-unorm-srgb",
    "astc-5x5-unorm",
    "astc-5x5-unorm-srgb",
    "astc-6x5-unorm",
    "astc-6x5-unorm-srgb",
    "astc-6x6-unorm",
    "astc-6x6-unorm-srgb",
    "astc-8x5-unorm",
    "astc-8x5-unorm-srgb",
    "astc-8x6-unorm",
    "astc-8x6-unorm-srgb",
    "astc-8x8-unorm",
    "astc-8x8-unorm-srgb",
    "astc-10x5-unorm",
    "astc-10x5-unorm-srgb",
    "astc-10x6-unorm",
    "astc-10x6-unorm-srgb",
    "astc-10x8-unorm",
    "astc-10x8-unorm-srgb",
    "astc-10x10-unorm",
    "astc-10x10-unorm-srgb",
    "astc-12x10-unorm",
    "astc-12x10-unorm-srgb",
    "astc-12x12-unorm",
    "astc-12x12-unorm-srgb"
};
</script>

<p id=depthPlus>
深度组件 {{GPUTextureFormat/“depth24plus”}} 和 {{GPUTextureFormat/“depth24plus-stencil8”}} 格式可以实现为 [=24 位深度=] 值或 {{GPUTextureFormat/“depth32float”}} 值。
</p>

问题（gpuweb/gpuweb＃1887）：在GPUAdapter（?）上添加一些内容，估计每个像素的字节数为
{{GPUTextureFormat/“stencil8”}}， {{GPUTextureFormat/“depth24plus-stencil8”}}，以及 {{GPUTextureFormat/“depth32float-stencil8”}}。


{{GPUTextureFormat/stencil8}} 这种格式可以分为两种：
实际的"stencil8"，或者"depth24stencil8"，其中深度方面为隐藏且无法访问。

<div class=note>
注：
虽然 depth32float 通道的精度严格高于 [=24-bit depth=] 通道的精度（在可表示范围（0.0到1.0）内的所有值），但请注意，可表示值集合并非严格的超集。


对于 [=24-bit depth=]，1 ULP 的值为常数 1 /（2<sup>24</sup> - 1）。
对于 depth32float，1 ULP 的值为不大于 1 /（2<sup>24</sup>）的可变值。
</div>

格式是<dfn lt=“renderable|renderable format”>可渲染</dfn>的，如果它是<dfn> color renderable format </ dfn>，或[=depth-or-stencil format=]。
如果格式在[[#plain-color-formats]]中列出并具有{{GPUTextureUsage/RENDER_ATTACHMENT}}功能，则它是
颜色可渲染格式。任何其他格式都不是颜色可渲染格式。
所有[=depth-or-stencil formats=]都是可渲染的。


具有可渲染格式的格式也是<dfn lt=“blendable|blendable format”>可混合的</dfn>
如果它可以与渲染管线混合一起使用。
请参阅[[#texture-format-caps]]。


格式是<dfn lt=“filterable|filterable format”>可过滤的</dfn>，如果它支持
{{GPUTextureSampleType}} {{GPUTextureSampleType/“float”}}
(而不仅仅是{{GPUTextureSampleType/“unfilterable-float”}});
也就是说，它可以与{{GPUSamplerBindingType/“filtering”}}的{{GPUSampler}}一起使用。
请参阅[[#texture-format-caps]]。

<div algorithm>
    <dfn abstract-op>resolving GPUTextureAspect</dfn>(format, aspect)

    **Arguments:**

    - {{GPUTextureFormat}} |format|
    - {{GPUTextureAspect}} |aspect|

    **Returns:** {{GPUTextureFormat}} 或 `null`

    1. 如果 |aspect| 为：

        <dl class=switch>
            : {{GPUTextureAspect/"all"}}
            :: 返回 |format|。

            : {{GPUTextureAspect/"depth-only"}}
            : {{GPUTextureAspect/"stencil-only"}}
            :: 如果 |format| 为 depth-stencil-format:
                返回 |format| 的 [=aspect-specific format=] 根据 [[#depth-formats]] 或 `null` 如果方面不存在于 |format| 中。
        </dl>
    1. 返回 `null`。
</div>

使用某些纹理格式需要在 {{GPUDevice}} 上启用功能。由于新格式可能会被添加到规范中，因此实现可能不知道这些枚举值。为了在实现之间规范化行为，如果未在设备上启用关联的功能，则尝试使用需要功能的格式将抛出异常。这使得行为与实现不知道格式时相同。


请参阅[[#texture-format-caps]]以获取有关哪些{{GPUTextureFormat}}需要功能的信息。

<div algorithm>
    <dfn abstract-op>验证纹理格式所需的特性</dfn> {{GPUTextureFormat}} |format| 使用逻辑 [=device=] |device| 通过运行以下步骤：

     1.如果|格式| 需要一个特性，而 |device|.{{device/[[features]]}} 不需要 [=list/contain=]
         特点：
         1.抛出一个{{TypeError}}。
</div>

<h3 id=gpuexternaltexture data-dfn-type=interface>`GPUExternalTexture`
<span id=gpu-external-texture></span>
</h3>

一个 {{GPUExternalTexture}} 是一个可采样的二维纹理，包装了一个外部视频对象。
{{GPUExternalTexture}} 对象的内容是一个快照，可能不会改变，无论是从 WebGPU 内部（它只是可采样的）还是从 WebGPU 外部（比如，由于视频帧的推进）。


它们通过使用 {{GPUBindGroupLayoutEntry/externalTexture}} 绑定组布局条目成员绑定到绑定组布局中。
外部纹理使用了多个绑定槽：请参阅 [=超过绑定槽限制=]。

    <div class=note>
        注：
        外部纹理可以在不创建导入源副本的情况下实现，
        但这取决于实现定义的因素。
        底层表示的所有权可以是独占的，也可以与其他所有者（如视频解码器）共享，但应用程序无法看到这一点。


        外部纹理的底层表示不可观察（除采样行为外），但通常可能包括


        - 最多三个2D数据平面（例如RGBA，Y+UV，Y+U+V）。
        - 在从这些平面读取之前，用于转换坐标的元数据（裁剪和旋转）。
        - 将值转换为指定的输出色彩空间的元数据（矩阵，伽玛，3D LUT）。

        所使用的配置在时间、系统、用户代理、媒体源之间，或在单个视频源的帧内可能不稳定。
        为了考虑到许多可能的表示，对每个外部纹理，该绑定保守地使用以下内容：


        - 三个采样纹理绑定（最多3个平面），
        - 一个采样纹理绑定用于3D LUT，
        - 一个采样器绑定用于采样3D LUT，以及
        - 一个统一缓冲区绑定用于元数据。
    </div>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUExternalTexture {
};
GPUExternalTexture includes GPUObjectBase;
</script>

{{GPUExternalTexture}} 局有以下内部插槽：

<dl dfn-type=attribute dfn-for="GPUExternalTexture">
    : <dfn>\[[expired]]</dfn>, 类型为 `boolean`
    ::
        指示对象是否已过期（不再可用）。
        最初设置为 `false` 。


        注：
        与类似的 `\[[destroyed]]` 槽位不同，这个值可以从 `true` 更改回 `false`。

    : <dfn>\[[descriptor]]</dfn>, 类型为 {{GPUExternalTextureDescriptor}}
    ::
        创建纹理的描述符。
</dl>

### 引入外部纹理 ### {#external-texture-creation}

从外部视频对象创建外部纹理，使用 {{GPUDevice/importExternalTexture()}}。


从 {{HTMLVideoElement}} 创建的外部纹理，在导入后的任务中会自动销毁，而不是像其他资源那样手动销毁或在垃圾回收时销毁。当外部纹理过期时，其 {{GPUExternalTexture/[[expired]]}} 插槽变为 true。


一旦 {{GPUExternalTexture}} 过期，必须再次调用 {{GPUDevice/importExternalTexture()}}。然而，用户代理可能会取消过期，并再次返回同一个 {{GPUExternalTexture}}，而不是创建一个新的。除非应用程序的执行预定与视频的帧率相匹配（例如，使用 requestVideoFrameCallback()），否则这种情况通常会发生。如果再次返回相同的对象，它们将进行相等比较，而引用先前对象的 {{GPUBindGroup}}、{{GPURenderBundle}} 等仍可使用。

<script type=idl>
dictionary GPUExternalTextureDescriptor
         : GPUObjectDescriptorBase {
    required HTMLVideoElement source;
    PredefinedColorSpace colorSpace = "srgb";
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>importExternalTexture(descriptor)</dfn>
    ::
        创建一个 {{GPUExternalTexture}} 包装提供的图像源。

        <div algorithm=GPUDevice.importExternalTexture>
            <div data-timeline=content>
                **Called on:** {{GPUDevice}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUDevice/importExternalTexture(descriptor)">
                    |descriptor|: 提供外部图像源对象（以及任何创建选项）。
                </pre>

                **Returns:** {{GPUExternalTexture}}

                [=内容时间线=] 步骤：

                1. 使 |source| 为 |descriptor|.{{GPUExternalTextureDescriptor/source}}.

                1. 如果 |source| 的当前图像内容与最近一次使用相同的 |descriptor| 调用 {{GPUDevice/importExternalTexture()}} 相同（忽略 {{GPUObjectDescriptorBase/label}}），并且用户代理选择重用它：

                    1. 令 |previousResult| 为先前返回的 {{GPUExternalTexture}}。
                    1. 将 |previousResult|.{{GPUExternalTexture/[[expired]]}} 设置为 false，更新对底层资源的所有权。
                    1. 令 |result| 为 |previousResult|。

                    注：
                    这允许应用程序检测到重复导入并避免重新创建依赖对象（如 {{GPUBindGroup}} ）。实现仍然需要能够处理单个帧由多个 {{GPUExternalTexture}} 包装，因为即使对于相同的帧，导入元数据（如 {{GPUExternalTextureDescriptor/colorSpace}} ）也可能发生变化。


                    否则：


                    1. 如果 |source| <l spec=html>[=is not origin-clean=]</l> ，则抛出 {{SecurityError}} 并停止。

                    1. 让 |usability| 是 [=?=] =检测图像参数可用性=。

                    1. 如果 |usability| 不是 `good`:

                        1. [$生成验证错误$]。
                        1. 返回无效的 {{GPUExternalTexture}} 。
                    1. 让 |data| 是将 |source| 的当前图像内容转换为 |descriptor|.{{GPUExternalTextureDescriptor/colorSpace}} 颜色空间并带有未预乘的透明度的结果。

                        这[[#color-space-conversions|可能导致]]值超出范围 [0, 1]。如果需要进行截取，可以在采样后进行。

                        注：这像是一个复制过程，但可以实现为对只读底层数据的引用，并在以后执行适当的元数据进行转换。

                    1. 让 |result| 是一个包装 |data| 的新 {{GPUExternalTexture}} 对象。

                1. 使用设备 |this| 和以下步骤 [$queue an automatic expiry task$]：

                    <div data-timeline=content>
                        1. 将 |result|.{{GPUExternalTexture/[[expired]]}} 设置为 `true`，
                            释放底层资源的所有权。
                    </div>

                    注：
                    应该在同一个任务中导入外部视频纹理，该任务会对纹理进行采样
                    (通常应该使用 `requestVideoFrameCallback` 或
                    {{AnimationFrameProvider/requestAnimationFrame()}} 根据应用程序进行调度)。
                    否则，纹理可能在
                    应用程序完成使用之前被这些步骤销毁。

                1. 将 |result|.{{GPUObjectBase/label}} 设置为 |descriptor|.{{GPUObjectDescriptorBase/label}}。
                1. 返回 |result|。
            </div>
        </div>
</dl>

<div class=example>
    以页面动画帧速率使用视频元素外部纹理进行渲染：

    <pre highlight=js>
        const videoElement = document.createElement('video');
        // ... set up videoElement, wait for it to be ready...

        let externalTexture;

        function frame() {
            requestAnimationFrame(frame);

            // Re-import only if necessary
            if (!externalTexture || externalTexture.expired) {
                externalTexture = gpuDevice.importExternalTexture({
                    source: videoElement
                });
            }

            // ... render using externalTexture...
        }
        requestAnimationFrame(frame);
    </pre>
</div>

<div class=example>
    以视频的帧速率使用视频元素外部纹理渲染，如果 `requestVideoFrameCallback` 可用：

    <pre highlight=js>
        const videoElement = document.createElement('video');
        // ... set up videoElement...

        function frame() {
            videoElement.requestVideoFrameCallback(frame);

            // Always re-import, because we know the video frame has advanced
            const externalTexture = gpuDevice.importExternalTexture({
                source: videoElement
            });

            // ... render using externalTexture...
        }
        videoElement.requestVideoFrameCallback(frame);
    </pre>
</div>

### 采样外部纹理 ### {#external-texture-sampling}

外部纹理在WGSL中用 `texture_external` 表示，并且可以使用 `textureLoad` 和 `textureSampleBaseClampToEdge` 进行读取。


提供给textureSampleBaseClampToEdge的 `sampler` 用于采样底层纹理。
结果在由{{GPUExternalTextureDescriptor/colorSpace}}设置的颜色空间中。
实现依赖的是，对于任何给定的外部纹理，采样器（和过滤器）是在转换为指定颜色空间的底层值之前还是之后应用的。


注：
如果内部表示是RGBA平面，那么采样行为就像在常规2D纹理上一样。
如果有多个底层平面（例如：Y+UV），采样器用于分别采样每个底层纹理，然后将YUV转换为指定颜色空间。


# 采样器 # {#samplers}

<h3 id=gpusampler data-dfn-type=interface>`GPUSampler`
<span id=sampler-interface></span>
</h3>

一个 {{GPUSampler}} 编码了变换和过滤信息，可以在着色器中使用这些信息来解释纹理资源数据。

{{GPUSampler}} 是通过 {{GPUDevice/createSampler()}} 创建的。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUSampler {
};
GPUSampler includes GPUObjectBase;
</script>

{{GPUSampler}} 具有以下内部插槽：

<dl dfn-type=attribute dfn-for=GPUSampler>
    : <dfn>\[[descriptor]]</dfn>, 类型为 {{GPUSamplerDescriptor}}, readonly
    ::
        创建 {{GPUSampler}} 的 {{GPUSamplerDescriptor}}。

    : <dfn>\[[isComparison]]</dfn>, 类型为 {{boolean}}
    ::
        {{GPUSampler}} 是否用作比较采样器。

    : <dfn>\[[isFiltering]]</dfn>, 类型为 {{boolean}}
    ::
        {{GPUSampler}} 是否对纹理的多个样本进行加权。
</dl>

### {{GPUSamplerDescriptor}} ### {#GPUSamplerDescriptor}

{{GPUSamplerDescriptor}} 指定用于创建 {{GPUSampler}} 的选项。

<script type=idl>
dictionary GPUSamplerDescriptor
         : GPUObjectDescriptorBase {
    GPUAddressMode addressModeU = "clamp-to-edge";
    GPUAddressMode addressModeV = "clamp-to-edge";
    GPUAddressMode addressModeW = "clamp-to-edge";
    GPUFilterMode magFilter = "nearest";
    GPUFilterMode minFilter = "nearest";
    GPUMipmapFilterMode mipmapFilter = "nearest";
    float lodMinClamp = 0;
    float lodMaxClamp = 32;
    GPUCompareFunction compare;
    [Clamp] unsigned short maxAnisotropy = 1;
};
</script>

<dl dfn-type=dict-member dfn-for=GPUSamplerDescriptor>
    : <dfn>addressModeU</dfn>
    : <dfn>addressModeV</dfn>
    : <dfn>addressModeW</dfn>
    ::
        分别为纹理宽度、高度和深度坐标指定 {{GPUAddressMode|address modes}}。

    : <dfn>magFilter</dfn>
    ::
        指定样本足迹小于或等于一个纹素时的采样行为。

    : <dfn>minFilter</dfn>
    ::
        指定样本足迹大于一个纹素时的采样行为。

    : <dfn>mipmapFilter</dfn>
    ::
        指定在 mipmap 级别之间进行采样的行为。

    : <dfn>lodMinClamp</dfn>
    : <dfn>lodMaxClamp</dfn>
    ::
        分别指定在对纹理进行采样时在内部使用的最小和最大细节级别。

    : <dfn>compare</dfn>
    ::
        提供时，采样器将是具有指定 {{GPUCompareFunction}} 的比较采样器。

         注：比较采样器可能会使用过滤，但采样结果将是
         依赖于实现并且可能不同于正常的过滤规则。

    : <dfn>maxAnisotropy</dfn>
    ::
        指定采样器使用的最大各向异性值夹具。


        注：大多数实现支持范围在1到16之间（包括1和16）的{{GPUSamplerDescriptor/maxAnisotropy}}值。所使用的{{GPUSamplerDescriptor/maxAnisotropy}}值将被限制在平台支持的最大值内。
</dl>

问题：解释如何计算LOD，以及在不同平台之间是否存在差异。

问题：解释各向异性采样是什么

{{GPUAddressMode}}描述了当采样留痕超出采样纹理的边界时，采样器的行为。

问题：更详细地描述“采样留痕”。

<script type=idl>
enum GPUAddressMode {
    "clamp-to-edge",
    "repeat",
    "mirror-repeat"
};
</script>

<dl dfn-type=enum-value dfn-for=GPUAddressMode>
    : <dfn>"clamp-to-edge"</dfn>
    ::
        纹理坐标被限制在 0.0 和 1.0 之间，包括 0.0 和 1.0 在内。

    : <dfn>"repeat"</dfn>
    ::
        纹理坐标环绕到纹理的另一侧。

    : <dfn>"mirror-repeat"</dfn>
    ::
        纹理坐标环绕到纹理的另一侧，但当坐标的整数部分为奇数时纹理会翻转。
</dl>

{{GPUFilterMode}} 和 {{GPUMipmapFilterMode}} 描述采样器在采样足迹与一个纹素不完全匹配时的行为。

<script type=idl>
enum GPUFilterMode {
    "nearest",
    "linear"
};

enum GPUMipmapFilterMode {
    "nearest",
    "linear"
};
</script>

<dl dfn-type=enum-value dfn-for=GPUFilterMode>
    : <dfn>"nearest"</dfn>
    ::
        返回最接近纹理坐标的纹理元素的值。

    : <dfn>"linear"</dfn>
    ::
        在每个维度中选择两个纹素并返回它们值之间的线性插值。
</dl>

{{GPUCompareFunction}}指定了比较采样器的行为。如果在着色器中使用了比较采样器，则输入值与采样纹理值进行比较，此比较测试的结果（0.0f表示通过，1.0f表示失败）会应用于过滤操作。


问题：描述过滤如何与比较采样相互作用。

<script type=idl>
enum GPUCompareFunction {
    "never",
    "less",
    "equal",
    "less-equal",
    "greater",
    "not-equal",
    "greater-equal",
    "always"
};
</script>

<dl dfn-type=enum-value dfn-for=GPUCompareFunction>
    : <dfn>"never"</dfn>
    ::
        比较测试永远不会通过。

    : <dfn>"less"</dfn>
    ::
        如果提供的值小于采样值，则通过比较测试。

    : <dfn>"equal"</dfn>
    ::
        如果提供的值等于采样值，则通过比较测试。

    : <dfn>"less-equal"</dfn>
    ::
        如果提供的值小于或等于采样值，则通过比较测试。

    : <dfn>"greater"</dfn>
    ::
        如果提供的值大于采样值，则通过比较测试。

    : <dfn>"not-equal"</dfn>
    ::
        如果提供的值不等于采样值，则通过比较测试。

    : <dfn>"greater-equal"</dfn>
    ::
        如果提供的值大于或等于采样值，则通过比较测试。

    : <dfn>"always"</dfn>
    ::
        比较测试总是通过。
</dl>

### 采样器创建 ### {#sampler-creation}

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createSampler(descriptor)</dfn>
    ::
        创建一个 {{GPUSampler}}。

        <div algorithm=GPUDevice.createSampler>
            <div data-timeline=content>
                **Called on:** {{GPUDevice}} this.

                **Arguments:**

                <pre class=argumentdef for="GPUDevice/createSampler(descriptor)">
                    |descriptor|: 要创建的 {{GPUSampler}} 的描述。
                </pre>

                **Returns:** {{GPUSampler}}

                [=内容时间线=] 步骤：

                1. 让 |s| 成为一个新的 {{GPUSampler}} 对象。
                1. 在 |this| 的 [=设备时间线=] 上执行 |initialization steps|。
                1. 返回 |s|。
            </div>
            <div data-timeline=device>
                [=Device timeline=] |initialization steps|:

                1. 如果以下任何条件未满足，则生成一个验证错误，使 |s| 无效，并停止。

                    <div class=validusage>
                        - |this| 为 [=有效=] 的。
                        - |descriptor|.{{GPUSamplerDescriptor/lodMinClamp}} &ge; 0.
                        - |descriptor|.{{GPUSamplerDescriptor/lodMaxClamp}} &ge;
                            |descriptor|.{{GPUSamplerDescriptor/lodMinClamp}}.
                        - |descriptor|.{{GPUSamplerDescriptor/maxAnisotropy}} &ge; 1.

                            注：大多数实现支持{{GPUSamplerDescriptor/maxAnisotropy}}的值在1到16之间，包括1和16。所提供的{{GPUSamplerDescriptor/maxAnisotropy}}值将被限制在平台支持的最大值内。

                        - 如果 |descriptor|.{{GPUSamplerDescriptor/maxAnisotropy}} &gt; 1:
                            - |descriptor|.{{GPUSamplerDescriptor/magFilter}},
                                |descriptor|.{{GPUSamplerDescriptor/minFilter}},
                                和 |descriptor|.{{GPUSamplerDescriptor/mipmapFilter}} 必须为
                                {{GPUMipmapFilterMode/"linear"}}.
                    </div>
                1. 设置 |s|.{{GPUSampler/[[descriptor]]}} 为 |descriptor|.
                1. 设置 |s|.{{GPUSampler/[[isComparison]]}} 为 `false` 如果 |a|.{{GPU Sampler/[[descriptor]]}} 的 {{GPU Sampler Descriptor/compare}} 属性为“null”或未定义。 否则，将其设置为“true”。
                1. 设置 |s|.{{GPUSampler/[[isFiltering]]}} 为 `false` 如果 {{GPUSamplerDescriptor/minFilter}}、{{GPUSamplerDescriptor/magFilter}} 或 {{GPUSamplerDescriptor/mipmapFilter}} 都没有 {{GPUFilterMode/"linear"}} 的值。 否则，将其设置为“true”。
            </div>
        </div>
</dl>

<div class=example>
    创建一个进行三线性过滤和重复纹理坐标的 {{GPUSampler}}：

    <pre highlight=js>
        const sampler = gpuDevice.createSampler({
            addressModeU: 'repeat',
            addressModeV: 'repeat',
            magFilter: 'linear',
            minFilter: 'linear',
            mipmapFilter: 'linear',
        });
    </pre>
</div>

# 资源绑定 # {#bindings}

<h3 id=gpubindgrouplayout data-dfn-type=interface>`GPUBindGroupLayout`
<span id=bind-group-layout></span>
</h3>

一个 {{GPUBindGroupLayout}} 定义了在 {{GPUBindGroup}} 中绑定的一组资源与它们在着色器阶段中的可访问性之间的接口。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUBindGroupLayout {
};
GPUBindGroupLayout includes GPUObjectBase;
</script>

{{GPUBindGroupLayout}} 具有以下内部插槽：

<dl dfn-type=attribute dfn-for=GPUBindGroupLayout>
    : <dfn>\[[descriptor]]</dfn>, of type {{GPUBindGroupLayoutDescriptor}}
    ::
</dl>

### 绑定组布局创建 ### {#bind-group-layout-creation}

{{GPUBindGroupLayout}} 通过 {{GPUDevice/createBindGroupLayout()|GPUDevice.createBindGroupLayout()}} 被创建。

<script type=idl>
dictionary GPUBindGroupLayoutDescriptor
         : GPUObjectDescriptorBase {
    required sequence<GPUBindGroupLayoutEntry> entries;
};
</script>

{{GPUBindGroupLayoutEntry}} 描述了要包含在 {{GPUBindGroupLayout}} 中的单个着色器资源绑定。

<script type=idl>
dictionary GPUBindGroupLayoutEntry {
    required GPUIndex32 binding;
    required GPUShaderStageFlags visibility;

    GPUBufferBindingLayout buffer;
    GPUSamplerBindingLayout sampler;
    GPUTextureBindingLayout texture;
    GPUStorageTextureBindingLayout storageTexture;
    GPUExternalTextureBindingLayout externalTexture;
};
</script>

{{GPUBindGroupLayoutEntry}} 字典有以下成员：

<dl dfn-type=dict-member dfn-for=GPUBindGroupLayoutEntry>
    : <dfn>binding</dfn>
    ::
        一个唯一的标识符，用于在 {{GPUBindGroupLayout}} 中的资源绑定，对应于 {{GPUBindGroupEntry/binding|GPUBindGroupEntry.binding}} 和 {{GPUShaderModule}} 中的 [=@binding=] 属性。

    : <dfn>visibility</dfn>
    ::
        {{GPUShaderStage}}成员的位集。
        每个设置的位表示{{GPUBindGroupLayoutEntry}}的资源
        将从关联的着色器阶段访问。

    : <dfn>buffer</dfn>
    ::
        当 [=map/exist|provided=] 时，表示此 {{GPUBindGroupLayoutEntry}} 的 [=绑定资源类型=] 是 {{GPUBufferBinding}}。

    : <dfn>sampler</dfn>
    ::
        当 [=map/exist|provided=] 时，表示此 {{GPUBindGroupLayoutEntry}} 的 [=绑定资源类型=] 是 {{GPUSampler}}。

    : <dfn>texture</dfn>
    ::
        当 [=map/exist|provided=] 时，表示此 {{GPUBindGroupLayoutEntry}} 的 [=binding resource type=] 是 {{GPUTextureView}}。

    : <dfn>storageTexture</dfn>
    ::
        当 [=map/exist|provided=] 时，表示此 {{GPUBindGroupLayoutEntry}} 的 [=binding resource type=] 是 {{GPUTextureView}}。

    : <dfn>externalTexture</dfn>
    ::
        当 [=map/exist|provided=] 时，表示此 {{GPUBindGroupLayoutEntry}} 的 [=绑定资源类型=] 是 {{GPUExternalTexture}}。
</dl>

<script type=idl>
typedef [EnforceRange] unsigned long GPUShaderStageFlags;
[Exposed=(Window, DedicatedWorker), SecureContext]
namespace GPUShaderStage {
    const GPUFlagsConstant VERTEX   = 0x1;
    const GPUFlagsConstant FRAGMENT = 0x2;
    const GPUFlagsConstant COMPUTE  = 0x4;
};
</script>

{{GPUShaderStage}} 包含以下标志，这些标志描述了此 {{GPUBindGroupLayoutEntry}} 的相应 {{GPUBindGroupEntry}} 的着色器阶段将对哪些可见：

<dl dfn-type=const dfn-for=GPUShaderStage>
    : <dfn>VERTEX</dfn>
    ::
        顶点着色器可以访问绑定组条目。

    : <dfn>FRAGMENT</dfn>
    ::
        片段着色器可以访问绑定组条目。

    : <dfn>COMPUTE</dfn>
    ::
        计算着色器可以访问绑定组条目。
</dl>

The [=binding member=] of a {{GPUBindGroupLayoutEntry}} is determined by which member of the
{{GPUBindGroupLayoutEntry}} is defined:
{{GPUBindGroupLayoutEntry/buffer}}, {{GPUBindGroupLayoutEntry/sampler}},
{{GPUBindGroupLayoutEntry/texture}}, {{GPUBindGroupLayoutEntry/storageTexture}}, or
{{GPUBindGroupLayoutEntry/externalTexture}}.
Only one may be defined for any given {{GPUBindGroupLayoutEntry}}.
Each member has an associated {{GPUBindingResource}}
type and each [=binding type=] has an associated [=internal usage=], given by this table:

<table class=data style="white-space: nowrap">
    <thead>
        <tr>
            <th><dfn dfn>Binding member</dfn>
            <th><dfn dfn lt="Binding Resource Type">Resource type</dfn>
            <th><dfn dfn>Binding type</dfn><br>
            <th><dfn dfn>Binding usage</dfn>
    </thead>
    <tr>
        <td rowspan=3>{{GPUBindGroupLayoutEntry/buffer}}
        <td rowspan=3>{{GPUBufferBinding}}
        <td>{{GPUBufferBindingType/"uniform"}}
        <td>[=internal usage/constant=]
    <tr>
        <td>{{GPUBufferBindingType/"storage"}}
        <td>[=internal usage/storage=]
    <tr>
        <td>{{GPUBufferBindingType/"read-only-storage"}}
        <td>[=internal usage/storage-read=]

    <tr>
        <td rowspan=3>{{GPUBindGroupLayoutEntry/sampler}}
        <td rowspan=3>{{GPUSampler}}
        <td>{{GPUSamplerBindingType/"filtering"}}
        <td rowspan=3>[=internal usage/constant=]
    <tr>
        <td>{{GPUSamplerBindingType/"non-filtering"}}
    <tr>
        <td>{{GPUSamplerBindingType/"comparison"}}

    <tr>
        <td rowspan=5>{{GPUBindGroupLayoutEntry/texture}}
        <td rowspan=5>{{GPUTextureView}}
        <td>{{GPUTextureSampleType/"float"}}
        <td rowspan=5>[=internal usage/constant=]
    <tr>
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
    <tr>
        <td>{{GPUTextureSampleType/"depth"}}
    <tr>
        <td>{{GPUTextureSampleType/"sint"}}
    <tr>
        <td>{{GPUTextureSampleType/"uint"}}

    <tr>
        <td>{{GPUBindGroupLayoutEntry/storageTexture}}
        <td>{{GPUTextureView}}
        <td>{{GPUStorageTextureAccess/"write-only"}}
        <td>[=internal usage/storage=]

    <tr>
        <td>{{GPUBindGroupLayoutEntry/externalTexture}}
        <td>{{GPUExternalTexture}}
        <td>
        <td>[=internal usage/constant=]
</table>

<div algorithm>
    如果朝着限制的插槽数超过了|limits|中支持的值，那么{{GPUBindGroupLayoutEntry}}值的[=list=] |entries| <dfn>超过了绑定插槽限制</dfn>。每个条目可以向多个限制使用多个插槽。

    1. 对于每个 |条目| 在 |entries| 中，如果：

        <dl class=switch>
            : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
                为 {{GPUBufferBindingType/"uniform"}} 且
                |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/hasDynamicOffset}} 为 `true`
            :: 考虑使用 1 个 {{supported limits/maxDynamicUniformBuffersPerPipelineLayout}} 插槽。
            : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
                为 {{GPUBufferBindingType/"storage"}} 且
                |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/hasDynamicOffset}} 为 `true`
            :: 考虑使用 1 个 {{supported limits/maxDynamicStorageBuffersPerPipelineLayout}} 插槽。
        </dl>
    1. 对每个在 &laquo; {{GPUShaderStage/VERTEX}}, {{GPUShaderStage/FRAGMENT}}, {{GPUShaderStage/COMPUTE}} &raquo; 中的着色器阶段 |stage|:
        1. 对于每个 |entries| 在 |entries| |entry|.{{GPUBindGroupLayoutEntry/visibility}} 包含 |stage|，如果：

            <dl class=switch>
                : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
                    为 {{GPUBufferBindingType/"uniform"}}
                :: 考虑 1 {{supported limits/maxUniformBuffersPerShaderStage}} 插槽将被使用。
                : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
                    为 {{GPUBufferBindingType/"storage"}} 或 {{GPUBufferBindingType/"read-only-storage"}}
                :: 考虑 1 {{supported limits/maxStorageBuffersPerShaderStage}} 插槽将被使用。
                : |entry|.{{GPUBindGroupLayoutEntry/sampler}} 为 [=map/exist|provided=]
                :: 考虑 1 {{supported limits/maxSamplersPerShaderStage}} 插槽将被使用。
                : |entry|.{{GPUBindGroupLayoutEntry/texture}} 为 [=map/exist|provided=]
                :: 考虑 1 {{supported limits/maxSampledTexturesPerShaderStage}} 插槽将被使用。
                : |entry|.{{GPUBindGroupLayoutEntry/storageTexture}} 为 [=map/exist|provided=]
                :: 考虑 1 {{supported limits/maxStorageTexturesPerShaderStage}} 插槽将被使用。
                : |entry|.{{GPUBindGroupLayoutEntry/externalTexture}} 为 [=map/exist|provided=]
                :: 考虑
                    4 {{supported limits/maxSampledTexturesPerShaderStage}} 插槽,
                    1 {{supported limits/maxSamplersPerShaderStage}} 插槽, 及
                    1 {{supported limits/maxUniformBuffersPerShaderStage}} 插槽
                    将被使用。
            </dl>
</div>

<script type=idl>
enum GPUBufferBindingType {
    "uniform",
    "storage",
    "read-only-storage"
};

dictionary GPUBufferBindingLayout {
    GPUBufferBindingType type = "uniform";
    boolean hasDynamicOffset = false;
    GPUSize64 minBindingSize = 0;
};
</script>

{{GPUBufferBindingLayout}} 字典具有以下成员：

<dl dfn-type=dict-member dfn-for=GPUBufferBindingLayout>
    : <dfn>type</dfn>
    ::
        指示绑定到此绑定的缓冲区所需的类型。

    : <dfn>hasDynamicOffset</dfn>
    ::
        指示此绑定是否需要动态偏移量。

    : <dfn>minBindingSize</dfn>
    ::
        指示与此绑定点一起使用的缓冲区绑定的最小{{GPUBufferBinding/size}}。


        在{{GPUDevice/createBindGroup()}}中，绑定始终根据此大小进行验证。


        如果这个值不是 `0`，管线创建还将[$validating shader binding|validates$]这个值≥变量的[=minimum buffer binding size=]。


        如果这个值是 `0`，它将被管线创建忽略，而是通过绘制/调度命令[$Validate encoder bind groups|validate$]，每个{{GPUBindGroup}}中的绑定都满足变量的[=minimum buffer binding size=]。


        注：
        理论上，对于早期验证指定的其他绑定相关字段（如{{GPUTextureBindingLayout/sampleType}}和{{GPUStorageTextureBindingLayout/format}}），也可以进行类似的执行时验证，而目前这些字段只能在管线创建时进行验证。
        然而，这种执行时验证可能会产生较高的成本或不必要的复杂性，因此只对{{GPUBufferBindingLayout/minBindingSize}} 提供这种验证，这些字段预计将产生最大的人体工程学影响。
</dl>

<script type=idl>
enum GPUSamplerBindingType {
    "filtering",
    "non-filtering",
    "comparison"
};

dictionary GPUSamplerBindingLayout {
    GPUSamplerBindingType type = "filtering";
};
</script>

{{GPUSamplerBindingLayout}} 字典具有以下成员：

<dl dfn-type=dict-member dfn-for=GPUSamplerBindingLayout>
    : <dfn>type</dfn>
    ::
        指示绑定到此绑定的采样器的必需类型。
</dl>

<script type=idl>
enum GPUTextureSampleType {
    "float",
    "unfilterable-float",
    "depth",
    "sint",
    "uint"
};

dictionary GPUTextureBindingLayout {
    GPUTextureSampleType sampleType = "float";
    GPUTextureViewDimension viewDimension = "2d";
    boolean multisampled = false;
};
</script>

{{GPUTextureBindingLayout}} 字典具有以下成员：

<dl dfn-type=dict-member dfn-for=GPUTextureBindingLayout>
    : <dfn>sampleType</dfn>
    ::
        指示绑定到此绑定的纹理视图所需的类型。

    : <dfn>viewDimension</dfn>
    ::
        指示绑定到此绑定的纹理视图所需的 {{GPUTextureViewDescriptor/dimension}}。

    : <dfn>multisampled</dfn>
    ::
        指示绑定到此绑定的纹理视图是否必须进行多重采样。
</dl>

<script type=idl>
enum GPUStorageTextureAccess {
    "write-only"
};

dictionary GPUStorageTextureBindingLayout {
    GPUStorageTextureAccess access = "write-only";
    required GPUTextureFormat format;
    GPUTextureViewDimension viewDimension = "2d";
};
</script>

{{GPUStorageTextureBindingLayout}} 字典具有以下成员：

<dl dfn-type=dict-member dfn-for=GPUStorageTextureBindingLayout>
    : <dfn>access</dfn>
    ::
        此绑定的访问模式，指示可读性和可写性。

         注：
         目前只有一种访问模式{{GPUStorageTextureAccess/"write-only"}}，未来会扩展。

    : <dfn>format</dfn>
    ::
        绑定到此绑定的纹理视图所需的 {{GPUTextureViewDescriptor/format}}。

    : <dfn>viewDimension</dfn>
    ::
        指示绑定到此绑定的纹理视图所需的 {{GPUTextureViewDescriptor/dimension}}。
</dl>

<script type=idl>
dictionary GPUExternalTextureBindingLayout {
};
</script>

A {{GPUBindGroupLayout}} 对象具有以下内部插槽：

<dl dfn-type=attribute dfn-for=GPUBindGroupLayout>
    : <dfn>\[[entryMap]]</dfn>, 类型为 [=ordered map=]&lt;{{GPUSize32}}, {{GPUBindGroupLayoutEntry}}&gt
    ::
        指向这个 {{GPUBindGroupLayout}} 描述的 {{GPUBindGroupLayoutEntry}} 的绑定索引映射。

    : <dfn>\[[dynamicOffsetCount]]</dfn>, 类型为 {{GPUSize32}}
    ::
        此 {{GPUBindGroupLayout}} 中具有动态偏移量的缓冲区绑定数。

    : <dfn>\[[exclusivePipeline]]</dfn>, 类型为 {{GPUPipelineBase}}?, 初始值为 `null`
    ::
        创建此{{GPUBindGroupLayout}}的管线（如果它是作为
        [[#default-pipeline-layout|默认管线布局]]的一部分创建的）。如果不是 `null` ，则使用此{{GPUBindGroupLayout}}创建的{{GPUBindGroup}}只能与指定的{{GPUPipelineBase}}一起使用。
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createBindGroupLayout(descriptor)</dfn>
    ::
        创建一个 {{GPUBindGroupLayout}}.

        <div algorithm=GPUDevice.createBindGroupLayout>
            <div data-timeline=content>
                **Called on:** {{GPUDevice}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUDevice/createBindGroupLayout(descriptor)">
                    |descriptor|: 要创建的 {{GPUBindGroupLayout}} 的描述。
                </pre>

                **Returns:** {{GPUBindGroupLayout}}

                [=Content timeline=] steps:

                1. 对于每个 {{GPUBindGroupLayoutEntry}} 在 |descriptor| 中的 |entry|.{{GPUBindGroupLayoutDescriptor/entries}}:
                    1. 如果 |entry|.{{GPUBindGroupLayoutEntry/storageTexture}} 为 [=map/exist|provided=]:
                        1. 验证所需特性的纹理格式对于 |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/format}} 与 |this|.{{GPUObjectBase/[[device]]}}。
                1. 让 |layout| 是一个新的 {{GPUBindGroupLayout}} 对象。
                1. 在 |this| 的 [=设备时间线=] 上发起 |initialization steps|。
                1. 返回 |layout|。
            </div>
            <div data-timeline=device>
                [=设备时间线=] |initialization steps|:

                1. 如果以下任何条件未满足，生成验证错误，并使 |layout| [=无效=]，然后停止。

                    <div class=validusage>
                        - |this| 为 [=有效=] 的。
                        - 使 |limits| 为 |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.
                        - |descriptor| 中每个条目的 {{GPUBindGroupLayoutEntry/binding}} 是唯一的。
                        - |descriptor| 中每个条目的 {{GPUBindGroupLayoutEntry/binding}} 必须是 |limits|.{{支持的限制/maxBindingsPerBindGroup}}。
                        - |descriptor|.{{GPUBindGroupLayoutDescriptor/entries}} must not  [=exceeds the binding slot limits|exceed the binding slot limits=] of |limits|。
                        - 对于每个 {{GPUBindGroupLayoutEntry}} |条目| 在 |descriptor|.{{GPUBindGroupLayoutDescriptor/entries}} 中：
                            - 确定是
                                |entry|.{{GPUBindGroupLayoutEntry/buffer}},
                                |entry|.{{GPUBindGroupLayoutEntry/sampler}},
                                |entry|.{{GPUBindGroupLayoutEntry/texture}}, 和
                                |entry|.{{GPUBindGroupLayoutEntry/storageTexture}} 之一 [=map/exist|provided=]。

                            - |entry|.{{GPUBindGroupLayoutEntry/visibility}} 仅包含 {{GPUShaderStage}} 中定义的位。

                            - 如果 |entry|.{{GPUBindGroupLayoutEntry/visibility}} 包含 {{GPUShaderStage/VERTEX}}：
                                - |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}} 不能是 {{GPUBufferBindingType/"storage"}}。
                                - |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}?.{{GPUStorageTextureBindingLayout/access}} 不能是 {{GPUStorageTextureAccess/"write-only"}}。

                            - 如果 |entry|.{{GPUBindGroupLayoutEntry/texture}}?.{{GPUTextureBindingLayout/multisampled}} 为 `true`:
                                - |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/viewDimension}} 为
                                    {{GPUTextureViewDimension/"2d"}}.
                                - |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} 不为
                                    {{GPUTextureSampleType/"float"}}.

                            - 如果 |entry|.{{GPUBindGroupLayoutEntry/storageTexture}} 为 [=map/exist|provided=]:
                                - |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/viewDimension}} 不为
                                    {{GPUTextureViewDimension/"cube"}} 或 {{GPUTextureViewDimension/"cube-array"}}.
                                - |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/format}} 必须是可以支持存储使用的格式。
                    </div>

                1. 设置 |layout|.{{GPUBindGroupLayout/[[descriptor]]}} to |descriptor|.
                1. 设置 |layout|.{{GPUBindGroupLayout/[[dynamicOffsetCount]]}} to the number of
                    entries in |descriptor| where {{GPUBindGroupLayoutEntry/buffer}} is [=map/exist|provided=] and
                    {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}} is `true`.
                1. 对每个 |descriptor|.{{GPUBindGroupLayoutDescriptor/entries}} 中的 {{GPUBindGroupLayoutEntry}} |entry|：
                    1. 使用 |entry|.{{GPUBindGroupLayoutEntry/binding}} 的键值，将 |entry| 插入 |layout|.{{GPUBindGroupLayout/[[entryMap]]}} 中。
            </div>
        </div>
</dl>

### 兼容性 ### {#bind-group-compatibility}

<div algorithm>
    如果满足以下所有条件，则两个{{GPUBindGroupLayout}}对象|a|和|b|被认为是<dfn dfn> 组等价</dfn>的：
    - |a|.{{GPUBindGroupLayout/[[exclusivePipeline]]}} == |b|.{{GPUBindGroupLayout/[[exclusivePipeline]]}}。
    - 对于任意的binding 数字 |binding|，满足以下条件之一：
        - 它同时不在 |a|.{{GPUBindGroupLayout/[[entryMap]]}} 和 |b|.{{GPUBindGroupLayout/[[entryMap]]}} 中。
        - |a|.{{GPUBindGroupLayout/[[entryMap]]}}[|binding|] == |b|.{{GPUBindGroupLayout/[[entryMap]]}}[|binding|]
</div>

如果绑定组布局是 [=group-equivalent=] 它们可以在所有内容中互换使用。

<h3 id=gpubindgroup data-dfn-type=interface>`GPUBindGroup`
<span id=gpu-bind-group></span>
</h3>

{{GPUBindGroup}} 定义了一组要绑定在一起的资源，以及这些资源在着色器阶段的使用方式。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUBindGroup {
};
GPUBindGroup includes GPUObjectBase;
</script>

{{GPUBindGroup}} 对象具有以下内部插槽：

<dl dfn-type=attribute dfn-for=GPUBindGroup>
    : <dfn>\[[layout]]</dfn>, of type {{GPUBindGroupLayout}}, readonly
    ::
        与此 {{GPUBindGroup}} 关联的 {{GPUBindGroupLayout}}。

    : <dfn>\[[entries]]</dfn>, of type [=sequence=]&lt;{{GPUBindGroupEntry}}&gt;, readonly
    ::
        {{GPUBindGroup}} 描述的一组 {{GPUBindGroupEntry}}。

    : <dfn>\[[usedResources]]</dfn>, of type [=ordered map=]&lt;[=subresource=], [=list=]&lt;[=internal usage=]&gt;&gt;, readonly
    ::
        此绑定组使用的缓冲区和纹理集 [=subresource=]，与 [=internal usage=] 标志列表相关联。
</dl>

### 绑定组创建 ### {#bind-group-creation}

{{GPUBindGroup}} 通过 {{GPUDevice/createBindGroup()|GPUDevice.createBindGroup()}} 创建。

<script type=idl>
dictionary GPUBindGroupDescriptor
         : GPUObjectDescriptorBase {
    required GPUBindGroupLayout layout;
    required sequence<GPUBindGroupEntry> entries;
};
</script>

{{GPUBindGroupDescriptor}} 字典有以下成员：

<dl dfn-type=dict-member dfn-for=GPUBindGroupDescriptor>
    : <dfn>layout</dfn>
    ::
        {{GPUBindGroupLayout}} 该绑定组的条目将符合。

    : <dfn>entries</dfn>
    ::
        一个条目列表，描述为 {{GPUBindGroupDescriptor/layout}} 描述的每个绑定向着色器公开的资源。
</dl>

<script type=idl>
typedef (GPUSampler or GPUTextureView or GPUBufferBinding or GPUExternalTexture) GPUBindingResource;

dictionary GPUBindGroupEntry {
    required GPUIndex32 binding;
    required GPUBindingResource resource;
};
</script>

{{GPUBindGroupEntry}} 描述了要绑定在 {{GPUBindGroup}} 中的单个资源，并且具有
以下成员：

<dl dfn-type=dict-member dfn-for=GPUBindGroupEntry>
    : <dfn>binding</dfn>
    ::
        {{GPUBindGroup}} 中资源绑定的唯一标识符，对应于 {{GPUBindGroupLayoutEntry/binding|GPUBindGroupLayoutEntry.binding}} 和 {{GPUShaderModule}} 中的 [=@binding=] 属性。

    : <dfn>resource</dfn>
    ::
        要绑定的资源，可以是 {{GPUSampler}}、{{GPUTextureView}}、{{GPUExternalTexture}} 或 {{GPUBufferBinding}}。
</dl>

<script type=idl>
dictionary GPUBufferBinding {
    required GPUBuffer buffer;
    GPUSize64 offset = 0;
    GPUSize64 size;
};
</script>

{{GPUBufferBinding}} 描述一个缓冲区和可选范围以绑定为资源，并具有以下成员：

<dl dfn-type=dict-member dfn-for=GPUBufferBinding>
    : <dfn>buffer</dfn>
    ::
        要绑定的 {{GPUBuffer}}。

    : <dfn>offset</dfn>
    ::
        从 {{GPUBufferBinding/buffer}} 的开头到缓冲区绑定暴露给着色器的范围的开头的偏移量（以字节为单位）。

    : <dfn>size</dfn>
    ::
        缓冲区绑定的大小（以字节为单位）。
        如果不是 [=map/exist|provided=]，则指定从 {{GPUBufferBinding/offset}} 开始到 {{GPUBufferBinding/buffer}} 结束的范围。
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createBindGroup(descriptor)</dfn>
    ::
        Creates a {{GPUBindGroup}}.

        <div algorithm=GPUDevice.createBindGroup>
            <div data-timeline=content>
                **Called on:** {{GPUDevice}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUDevice/createBindGroup(descriptor)">
                    |descriptor|: 要创建的 {{GPUBindGroup}} 的描述。
                </pre>

                **Returns:** {{GPUBindGroup}}

                [=内容时间线=] 步骤：

                1. 使 |bindGroup| 为一个新的 {{GPUBindGroup}} 对象。
                1. 在 |this| 的 [=设备时间线=] 上发起 |initialization steps|。
                1. 返回 |bindGroup|。
            </div>
            <div data-timeline=device>
                [=设备时间线=] |initialization steps|:

                1. 使 |limits| 为 |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.
                1. 如果以下任何条件未满足，生成验证错误，使 |bindGroup| [=无效=]，并停止。

                    <div class=validusage>
                        - |descriptor|.{{GPUBindGroupDescriptor/layout}} 可以与 |this| 一起使用。
                        - |descriptor|.{{GPUBindGroupDescriptor/layout}} 的 {{GPUBindGroupLayoutDescriptor/entries}} 长度 正好等于 |descriptor|.{{GPUBindGroupDescriptor/entries}} 的长度。

                        对于 |descriptor|.{{GPUBindGroupDescriptor/entries}} 中的每个 {{GPUBindGroupEntry}} |bindingDescriptor|：


                            - 让 |resource| 为 |bindingDescriptor|.{{GPUBindGroupEntry/resource}}.

                            - 在 |descriptor|.{{GPUBindGroupDescriptor/layout}}.{{GPUBindGroupLayoutDescriptor/entries}} 中有一个且仅有一个 {{GPUBindGroupLayoutEntry}} |layoutBinding|，它满足 |layoutBinding|.{{GPUBindGroupLayoutEntry/binding}} 等于 |bindingDescriptor|.{{GPUBindGroupEntry/binding}}。

                            - 如果为 |layoutBinding| 定义了 [=binding 成员=] ，那么

                                <dl class=switch>
                                    : {{GPUBindGroupLayoutEntry/sampler}}
                                    ::
                                        - |resource| 为一个 {{GPUSampler}}。
                                        - |resource| 可以与 |this| 一起使用。
                                        - 如果 |layoutBinding|.{{GPUBindGroupLayoutEntry/sampler}}.{{GPUSamplerBindingLayout/type}} 为：

                                            <dl class=switch>
                                                : {{GPUSamplerBindingType/"filtering"}}
                                                :: |resource|.{{GPUSampler/[[isComparison]]}} 为 `false`。

                                                : {{GPUSamplerBindingType/"non-filtering"}}
                                                ::
                                                    |resource|.{{GPUSampler/[[isFiltering]]}} 为 `false`。
                                                    |resource|.{{GPUSampler/[[isComparison]]}} 为 `false`。

                                                : {{GPUSamplerBindingType/"comparison"}}
                                                :: |resource|.{{GPUSampler/[[isComparison]]}} 为 `true`。
                                            </dl>

                                    : {{GPUBindGroupLayoutEntry/texture}}
                                    ::
                                        - |resource| 为一个 {{GPUTextureView}}。
                                        - |resource| 可以和 |this| 一起有效使用。
                                        - 使 |texture| 为 |resource|.{{GPUTextureView/[[texture]]}}。
                                        - |layoutBinding|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/viewDimension}}
                                            等于 |resource|'s {{GPUTextureViewDescriptor/dimension}}。
                                        - |layoutBinding|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}}
                                            与 |resource|'s {{GPUTextureViewDescriptor/format}} [[#texture-format-caps|compatible]]。
                                        - |texture|'s {{GPUTextureDescriptor/usage}} 包含 {{GPUTextureUsage/TEXTURE_BINDING}}。
                                        - 如果 |layoutBinding|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/multisampled}}
                                            为 `true`, |texture|'s {{GPUTextureDescriptor/sampleCount}}
                                            &gt; `1`, 否则 |texture|'s {{GPUTextureDescriptor/sampleCount}} 为 `1`。

                                    : {{GPUBindGroupLayoutEntry/storageTexture}}
                                    ::
                                        - |resource| 为一个 {{GPUTextureView}}。
                                        - |resource| 可以和 |this| 一起使用。
                                        - 使 |texture| 为 |resource|.{{GPUTextureView/[[texture]]}}。
                                        - |layoutBinding|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/viewDimension}}
                                            等于 |resource|'s {{GPUTextureViewDescriptor/dimension}}。
                                        - |layoutBinding|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/format}}
                                            等于 |resource|.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}}。
                                        - |texture|'s {{GPUTextureDescriptor/usage}} 包含 {{GPUTextureUsage/STORAGE_BINDING}}。
                                        - |resource|.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/mipLevelCount}} 必须为 1。

                                    :  {{GPUBindGroupLayoutEntry/buffer}}
                                    ::
                                        - |resource| 为一个 {{GPUBufferBinding}}。
                                        - |resource|.{{GPUBufferBinding/buffer}} 可以与 |this| 一起使用。
                                        - The bound part designated by |resource|.{{GPUBufferBinding/offset}} and
                                            |resource|.{{GPUBufferBinding/size}} resides inside the buffer and has non-zero size.
                                        - [$effective buffer binding size$](|resource|) &ge;
                                            |layoutBinding|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}.

                                        - 如果 |layoutBinding|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/type}} 为

                                            <dl class=switch>
                                                : {{GPUBufferBindingType/"uniform"}}
                                                ::
                                                    - |resource|.{{GPUBufferBinding/buffer}}.{{GPUBufferDescriptor/usage}}
                                                        包含 {{GPUBufferUsage/UNIFORM}}。
                                                    - [$effective buffer binding size$](|resource|) &le;
                                                        |limits|.{{supported limits/maxUniformBufferBindingSize}}。
                                                    - |resource|.{{GPUBufferBinding/offset}} 是
                                                        |limits|.{{supported limits/minUniformBufferOffsetAlignment}} 的倍数。

                                                : {{GPUBufferBindingType/"storage"}} 或
                                                    {{GPUBufferBindingType/"read-only-storage"}}
                                                ::
                                                    - |resource|.{{GPUBufferBinding/buffer}}.{{GPUBufferDescriptor/usage}}
                                                        包含 {{GPUBufferUsage/STORAGE}}.
                                                    - [$effective buffer binding size$](|resource|) &le;
                                                        |limits|.{{supported limits/maxStorageBufferBindingSize}}.
                                                    - [$effective buffer binding size$](|resource|) 是4的倍数。
                                                    - |resource|.{{GPUBufferBinding/offset}} 是
                                                        |limits|.{{supported limits/minStorageBufferOffsetAlignment}} 的倍数。
                                            </dl>

                                    :  {{GPUBindGroupLayoutEntry/externalTexture}}
                                    ::
                                        - |resource| 为一个 {{GPUExternalTexture}}.
                                        - |resource| 可以和 |this| 一起使用。
                                </dl>
                    </div>

                1. 使 |bindGroup|.{{GPUBindGroup/[[layout]]}} =
                    |descriptor|.{{GPUBindGroupDescriptor/layout}}.
                1. 使 |bindGroup|.{{GPUBindGroup/[[entries]]}} =
                    |descriptor|.{{GPUBindGroupDescriptor/entries}}.
                1. 使 |bindGroup|.{{GPUBindGroup/[[usedResources]]}} = {}.

                1. 对每个 |descriptor|.{{GPUBindGroupDescriptor/entries}} 中的 {{GPUBindGroupEntry}} |bindingDescriptor|：
                    1. 让 |internalUsage| 是 |layoutBinding| 的 [=binding usage=]。
                    1. 将|resource|看到的每个[=subresource=]以|internalUsage|的形式添加到{{GPUBindGroup/[[usedResources]]}}中。
            </div>
        </div>
</dl>

<div algorithm>
    <dfn abstract-op>effective buffer binding size</dfn>(binding)
        1. 如果 |binding|.{{GPUBufferBinding/size}} 没有 [=map/exist|提供=]：
            1. 返回 max(0, |binding|.{{GPUBufferBinding/buffer}}.{{GPUBuffer/size}} - |binding|.{{GPUBufferBinding/offset}});
        1. 返回 |binding|.{{GPUBufferBinding/size}}.
</div>

<div algorithm>
    两个 {{GPUBufferBinding}} 对象 |a| 和 |b| 当且仅当以下所有条件都为真时，被认为存在<dfn dfn>缓冲区绑定别名</dfn>：

    - |a|.{{GPUBufferBinding/buffer}} == |b|.{{GPUBufferBinding/buffer}}
    - 由 |a|.{{GPUBufferBinding/offset}} 和 |a|.{{GPUBufferBinding/size}} 形成的范围与
        由 |b|.{{GPUBufferBinding/offset}} 和 |b|.{{GPUBufferBinding/size}} 形成的范围相交。

    问题：当 size 可以为未定义时，定义如何通过 offset/size 形成范围。
</div>

<h3 id=gpupipelinelayout data-dfn-type=interface>`GPUPipelineLayout`
<span id=pipeline-layout></span>
</h3>

一个{{GPUPipelineLayout}}定义了在[=GPUBindingCommandsMixin/setBindGroup()=]中设置的所有{{GPUBindGroup}}对象的资源与通过{{GPURenderCommandsMixin/setPipeline(pipeline)|GPURenderCommandsMixin.setPipeline}}或{{GPUComputePassEncoder/setPipeline(pipeline)|GPUComputePassEncoder.setPipeline}}设置的管线中的着色器之间的映射关系。


资源的完整绑定地址可以定义为一个三元组：


1. 着色器阶段掩码，表示资源可见的阶段
2. 绑定组索引
3. 绑定编号

这个地址的组成部分也可以看作是管线的绑定空间。一个{{GPUBindGroup}}（带有相应的{{GPUBindGroupLayout}}）为固定的绑定组索引覆盖了该空间。其中包含的绑定需要是着色器在这个绑定组索引下使用的资源的超集。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUPipelineLayout {
};
GPUPipelineLayout includes GPUObjectBase;
</script>

{{GPUPipelineLayout}} 具有以下内部插槽：

<dl dfn-type=attribute dfn-for=GPUPipelineLayout>
    : <dfn>\[[bindGroupLayouts]]</dfn>, 类型为 [=list=]&lt;{{GPUBindGroupLayout}}&gt;
    ::
        在 {{GPUPipelineLayoutDescriptor/bindGroupLayouts|GPUPipelineLayoutDescriptor.bindGroupLayouts}} 中创建时提供的 {{GPUBindGroupLayout}} 对象。
</dl>

注：对许多 {{GPURenderPipeline}} 或 {{GPUComputePipeline}} 管线使用相同的 {{GPUPipelineLayout}} 可确保在这些管线之间切换时用户代理不需要在内部重新绑定任何资源。

<div class=example>
    {{GPUComputePipeline}} object X was created with {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGroupLayouts}} A, B, C. {{GPUComputePipeline}} object Y was created with {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGroupLayouts}} A, D, C. Supposing the command encoding sequence has two dispatches:

    1. [=GPUBindingCommandsMixin/setBindGroup()|setBindGroup=](0, ...)
    1. [=GPUBindingCommandsMixin/setBindGroup()|setBindGroup=](1, ...)
    1. [=GPUBindingCommandsMixin/setBindGroup()|setBindGroup=](2, ...)
    1. {{GPUComputePassEncoder/setPipeline()|setPipeline}}(X)
    1. {{GPUComputePassEncoder/dispatchWorkgroups()|dispatchWorkgroups}}()
    1. [=GPUBindingCommandsMixin/setBindGroup()|setBindGroup=](1, ...)
    1. {{GPUComputePassEncoder/setPipeline()|setPipeline}}(Y)
    1. {{GPUComputePassEncoder/dispatchWorkgroups()|dispatchWorkgroups}}()

    在这种情况下，即使{{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGroupLayouts}}索引2处的{{GPUBindGroupLayout}}和插槽2处的{{GPUBindGroup}}均未发生更改，用户代理也需要重新绑定组插槽2以进行第二次分派。
</div>

注：{{GPUPipelineLayout}} 的预期用法是将最常见且最不经常更改的绑定组放在布局的 “底部”，即更低的绑定组槽数，如 0 或 1。绑定组需要在绘制调用之间更频繁地更改，其索引应该越高。这一总体原则允许用户代理在绘制调用之间最小化状态更改，从而降低 CPU 开销。

### 管线布局创建 ### {#pipeline-layout-creation}

一个 {{GPUPipelineLayout}} 通过 {{GPUDevice/createPipelineLayout()|GPUDevice.createPipelineLayout()}} 被创建。

<script type=idl>
dictionary GPUPipelineLayoutDescriptor
         : GPUObjectDescriptorBase {
    required sequence<GPUBindGroupLayout> bindGroupLayouts;
};
</script>

{{GPUPipelineLayoutDescriptor}} 字典定义了管线使用的所有 {{GPUBindGroupLayout}}，并具有以下成员：

<dl dfn-type=dict-member dfn-for=GPUPipelineLayoutDescriptor>
    : <dfn>bindGroupLayouts</dfn>
    ::
        一个将被管线使用的{{GPUBindGroupLayout}}列表。每个元素对应于{{GPUShaderModule}}中的一个[=@group=]属性，其中第 `N` 个元素对应于 `@group(N)`。
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createPipelineLayout(descriptor)</dfn>
    ::
        创建一个 {{GPUPipelineLayout}}。

        <div algorithm=GPUDevice.createPipelineLayout>
            <div data-timeline=content>
                **Called on:** {{GPUDevice}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUDevice/createPipelineLayout(descriptor)">
                    |descriptor|: 要创建的 {{GPUPipelineLayout}} 的描述。
                </pre>

                **Returns:** {{GPUPipelineLayout}}

                [=内容时间线=] 步骤：

                1. 使 |pl| 为一个新的 {{GPUPipelineLayout}} 对象。
                1. 在 |this| 的 [=设备时间线=] 上发起 |initialization steps|。
                1. 返回 |pl|。
            </div>
            <div data-timeline=device>
                [=设备时间线=] |initialization steps|:

                1. 使 |limits| 为 |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.
                1. 让 |allEntries| 成为连接
                    |bgl|.{{GPUBindGroupLayout/[[descriptor]]}}.{{GPUBindGroupLayoutDescriptor/entries}}
                    中所有|bgl|在|descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}}的结果。
                1. 如果以下任何条件不满足[生成验证错误]，使 |pl| 无效，并停止。

                    <div class=validusage>
                        - 每个 |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}} 中的 {{GPUBindGroupLayout}} 必须与 |this| 一起[$valid to use with$]，并且 {{GPUBindGroupLayout/[[exclusivePipeline]]}} 为 null。
                        - |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}} 的[=list/size=] 必须 ≤ |limits|.{{supported limits/maxBindGroups}}。
                        - |allEntries| 一定不能超过 |limits| 的绑定槽数量限制。
                    </div>

                1. 设置 |pl|.{{GPUPipelineLayout/[[bindGroupLayouts]]}} 为
                    |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}}.
            </div>
        </div>
</dl>

注：如果两个{{GPUPipelineLayout}}对象的内部{{GPUPipelineLayout/[[bindGroupLayouts]]}}序列包含[=group-equivalent=]的{{GPUBindGroupLayout}}对象，那么它们在任何用途上都被认为是等效的。

## 示例 ## {#bindgroup-examples}

<div class=example>
    创建一个描述具有统一缓冲区、纹理和采样器的绑定的 {{GPUBindGroupLayout}}。
    然后使用 {{GPUBindGroupLayout}} 创建一个 {{GPUBindGroup}} 和一个 {{GPUPipelineLayout}}。

    <pre highlight=js>
        const bindGroupLayout = gpuDevice.createBindGroupLayout({
            entries: [{
                binding: 0,
                visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
                buffer: {}
            }, {
                binding: 1,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {}
            }, {
                binding: 2,
                visibility: GPUShaderStage.FRAGMENT,
                sampler: {}
            }]
        });

        const bindGroup = gpuDevice.createBindGroup({
            layout: bindGroupLayout,
            entries: [{
                binding: 0,
                resource: { buffer: buffer },
            }, {
                binding: 1,
                resource: texture
            }, {
                binding: 2,
                resource: sampler
            }]
        });

        const pipelineLayout = gpuDevice.createPipelineLayout({
            bindGroupLayouts: [bindGroupLayout]
        });
    </pre>
</div>

# 着色器模块 # {#shader-modules}

<h3 id=gpushadermodule data-dfn-type=interface>`GPUShaderModule`
<span id=shader-module></span>
</h3>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUShaderModule {
    Promise<GPUCompilationInfo> getCompilationInfo();
};
GPUShaderModule includes GPUObjectBase;
</script>

{{GPUShaderModule}} 是对内部着色器模块对象的引用。

### 着色器模块创建 ### {#shader-module-creation}

<script type=idl>
dictionary GPUShaderModuleDescriptor
         : GPUObjectDescriptorBase {
    required USVString code;
    object sourceMap;
    record<USVString, GPUShaderModuleCompilationHint> hints;
};
</script>

<dl dfn-type=dict-member dfn-for=GPUShaderModuleDescriptor>
    : <dfn>code</dfn>
    ::
        着色器模块的 <a href="https://gpuweb.github.io/gpuweb/wgsl/">WGSL</a> 源代码。

    : <dfn>sourceMap</dfn>
    ::
        如果定义了，可以解释为source-map-v3格式。


        源映射是可选的，但可以作为一种支持开发工具集成的标准化方式，例如源语言调试[[SourceMap]]。
        源映射中的WGSL名称（标识符）遵循[=WGSL标识符对比=]中定义的规则。

    : <dfn>hints</dfn>
    ::
        如果定义了一个从着色器映射的入口点名称到一个 {{GPUShaderModuleCompilationHint}}。这些 {{GPUShaderModuleCompilationHint}} 上不执行任何验证。实现应该使用 {{GPUShaderModuleCompilationHint}} 中的任何信息来执行尽可能多的 {{GPUDevice/createShaderModule()}} 内的编译。入口点名称遵循 [=WGSL 标识符比较=] 中定义的规则。


        注：在 {{GPUShaderModuleDescriptor/hints}} 中提供信息没有任何可观察的效果，除了性能。因为一个单独的着色器模块可以容纳多个入口点，并且可以从一个着色器模块创建多个管线，因此在 {{GPUDevice/createShaderModule()}} 中一次性进行尽可能多的编译会比在多个调用 {{GPUDevice/createComputePipeline()}} / {{GPUDevice/createRenderPipeline()}} 中多次编译性能更高。
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createShaderModule(descriptor)</dfn>
    ::
        创建一个 {{GPUShaderModule}}。

        <div algorithm=GPUDevice.createShaderModule>
            <div data-timeline=content>
                **Called on:** {{GPUDevice}} this.

                **Arguments:**

                <pre class=argumentdef for="GPUDevice/createShaderModule(descriptor)">
                    |descriptor|: 要创建的 {{GPUShaderModule}} 的描述。
                </pre>

                **Returns:** {{GPUShaderModule}}

                [=内容时间线=] 步骤：

                1. 使 |sm| 为一个新的 {{GPUShaderModule}} 对象。
                1. 在 |this| 的 [=设备时间线=] 上发起 |initialization steps|。
                1. 返回 |sm|。
            </div>
            <div data-timeline=device>
                [=设备时间线=] |initialization steps|:

                1. 让 |result| 成为使用WGSL源的[=shader module creation=]的结果
                    |descriptor|.{{GPUShaderModuleDescriptor/code}}。
                1. 如果以下任何要求未得到满足，产生一个验证错误，使 |sm| [=无效=]，然后返回。

                    <div class=validusage>
                        - |this| 必须 [=有效=]。
                        - |result| 必须不为 [=shader-creation error|shader-creation=] [=program error=]。
                    </div>

                问题（gpuweb/gpuweb#2308）：
                是否应允许在此处出现内部错误（[=uncategorized errors=]），还是应该将其延迟至管线创建？


                问题：描述剩余的 {{GPUDevice/createShaderModule()}} 验证和算法步骤。

                <div class=note>
                    注：
                    用户代理不应该在此处引发的验证错误的 {{GPUError/message}} 文本中包含详细的编译器错误消息或着色器文本：
                    这些细节可以通过 {{GPUShaderModule/getCompilationInfo()}} 访问。
                    用户代理应该为开发者提供便于调试的易于阅读、格式化的错误详细信息（例如浏览器开发者控制台中的警告，可以展开以显示完整的着色器源代码）。


                    由于着色器编译错误在生产应用程序中应该很少出现，用户代理可以选择无论错误处理如何（[=GPU错误范围=]或者
                    {{GPUDevice/uncapturederror}} 事件处理器），都向*开发者*显示它们，例如作为可展开的警告。
                    如果没有这样做，它们应该提供并记录另一种方法供开发者访问易于阅读的错误详细信息，例如添加一个复选框以无条件显示错误，
                    或者在将 {{GPUCompilationInfo}} 对象记录到控制台时显示人类可读的详细信息。
                </div>
            </div>
        </div>
</dl>

<div class=example>
    从 WGSL 代码创建一个 {{GPUShaderModule}}：

    <pre highlight=js>
        // A simple vertex and fragment shader pair that will fill the viewport with red.
        const shaderSource = \`
            var&lt;private&gt; pos : array&lt;vec2&lt;f32&gt;, 3&gt; = array&lt;vec2&lt;f32&gt;, 3&gt;(
                vec2(-1.0, -1.0), vec2(-1.0, 3.0), vec2(3.0, -1.0));

            @vertex
            fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -&gt; @builtin(position) vec4&lt;f32&gt; {
                return vec4(pos[vertexIndex], 1.0, 1.0);
            }

            @fragment
            fn fragmentMain() -&gt; @location(0) vec4&lt;f32&gt; {
                return vec4(1.0, 0.0, 0.0, 1.0);
            }
        \`;

        const shaderModule = gpuDevice.createShaderModule({
            code: shaderSource,
        });
    </pre>
</div>

#### 着色器模块编译提示 #### {#shader-module-compilation-hints}

着色器模块编译提示是可选的、额外的信息，用来表示给定的 {{GPUShaderModule}} 入口点将来打算如何使用。对于某些实现来说，这些信息可能有助于更早地编译着色器模块，从而可能提高性能。

<script type=idl>
dictionary GPUShaderModuleCompilationHint {
    (GPUPipelineLayout or GPUAutoLayoutMode) layout;
};
</script>

<dl dfn-type=dict-member dfn-for=GPUShaderModuleCompilationHint>
    : <dfn>layout</dfn>
    ::
        一个 {{GPUPipelineLayout}}，将来可以在 {{GPUDevice/createComputePipeline()}} 或 {{GPUDevice/createRenderPipeline()}} 调用中与 {{GPUShaderModule}} 一起使用。
        如果设置为 {{GPUAutoLayoutMode/“auto”}}，则将使用与此提示关联的入口点的[$默认管线布局$]。
</dl>

<div class=note>
    注：
    如果可能，作者应该同时向 {{GPUDevice/createShaderModule()}} 和 {{GPUDevice/createComputePipeline()}} / {{GPUDevice/createRenderPipeline()}} 提供相同的信息。


    如果作者在调用 {{GPUDevice/createShaderModule()}} 时无法提供提示信息，他们通常不应该延迟调用 {{GPUDevice/createShaderModule()}}；而应该从 {{GPUShaderModuleDescriptor/hints}} 或 {{GPUShaderModuleCompilationHint}} 中省略未知信息。省略此信息可能导致编译被推迟到 {{GPUDevice/createComputePipeline()}} / {{GPUDevice/createRenderPipeline()}}。

    如果作者对传递给 {{GPUDevice/createShaderModule()}} 的提示信息与稍后传递给 {{GPUDevice/createComputePipeline()}} / {{GPUDevice/createRenderPipeline()}} 的相同模块的信息是否匹配没有把握，他们应该避免将该信息传递给 {{GPUDevice/createShaderModule()}}，因为将不匹配的信息传递给 {{GPUDevice/createShaderModule()}} 可能导致不必要的编译发生。
</div>

### 着色器模块编译信息 ### {#shader-module-compilation-information}

<script type=idl>
enum GPUCompilationMessageType {
    "error",
    "warning",
    "info"
};

[Exposed=(Window, DedicatedWorker), Serializable, SecureContext]
interface GPUCompilationMessage {
    readonly attribute DOMString message;
    readonly attribute GPUCompilationMessageType type;
    readonly attribute unsigned long long lineNum;
    readonly attribute unsigned long long linePos;
    readonly attribute unsigned long long offset;
    readonly attribute unsigned long long length;
};

[Exposed=(Window, DedicatedWorker), Serializable, SecureContext]
interface GPUCompilationInfo {
    readonly attribute FrozenArray<GPUCompilationMessage> messages;
};
</script>

一个 {{GPUCompilationMessage}} 是由 {{GPUShaderModule}} 编译器生成的信息、警告或错误消息。这些消息旨在以人类可读的方式帮助开发人员诊断与他们的着色器 {{GPUShaderModuleDescriptor/code}} 有关的问题。每个消息可能对应着色器代码中的某个单点，着色器代码的子串，或者可能根本不对应代码中的任何特定点。


{{GPUCompilationMessage}} 具有以下属性：

<dl dfn-type=attribute dfn-for=GPUCompilationMessage>
    : <dfn>message</dfn>
    ::
        这个编译信息的可读、[=可本地化文本=]。


        注：{{GPUCompilationMessage/message}}应遵循[=最佳实践，关于语言和方向信息=]。这包括利用任何未来可能出现的有关字符串语言和方向元数据的标准。


        <p class="note editorial">编者按：
        在撰写本文时，尚未提供任何可以与旧版API兼容且一致的语言/方向建议，但一旦出现，应正式采纳。

    : <dfn>type</dfn>
    ::
        消息的严重级别。

        如果{{GPUCompilationMessage/type}}是{{GPUCompilationMessageType/"error"}}，它对应一个[=shader-creation error=]。

    : <dfn>lineNum</dfn>
    ::
        在着色器 {{GPUShaderModuleDescriptor/code}} 中与 {{GPUCompilationMessage/message}} 对应的行号。值为基于一的，这样 lineNum 为 `1` 表示着色器 {{GPUShaderModuleDescriptor/code}} 的第一行。行由 [=line breaks=] 分隔。


        如果 {{GPUCompilationMessage/message}} 对应于一个子字符串，则指向子字符串开始的行。如果 {{GPUCompilationMessage/message}} 与着色器 {{GPUShaderModuleDescriptor/code}} 中的任何特定点都不对应，则必须为 `0`。

    : <dfn>linePos</dfn>
    ::
        偏移量，以UTF-16代码单元为单位，从着色器 {{GPUShaderModuleDescriptor/code}} 的行起始位置 {{GPUCompilationMessage/lineNum}} 到 {{GPUCompilationMessage/message}} 对应的点或子串起始位置。值是从1开始的，这样，{{GPUCompilationMessage/linePos}} 的值 `1` 表示行的第一个代码单元。


        如果 {{GPUCompilationMessage/message}} 对应一个子串，则该指针指向子串的第一个UTF-16代码单元。如果 {{GPUCompilationMessage/message}} 不对应着色器 {{GPUShaderModuleDescriptor/code}} 中的任何特定点，则必须为 `0`。

    : <dfn>offset</dfn>
    ::
        从着色器{{GPUShaderModuleDescriptor/code}}开始的偏移量，以UTF-16代码单元为单位，到{{GPUCompilationMessage/message}}相对应的点或子字符串的开始位置。必须引用与{{GPUCompilationMessage/lineNum}}和{{GPUCompilationMessage/linePos}}相同的位置。如果{{GPUCompilationMessage/message}}不对应着色器{{GPUShaderModuleDescriptor/code}}中的任何特定点，则必须为 `0`。

    : <dfn>length</dfn>
    ::
        在与 {{GPUCompilationMessage/message}} 对应的子字符串中的 UTF-16 编码单元数。 如果消息不对应子字符串，则 {{GPUCompilationMessage/length}} 必须为 0。
</dl>

注：{{GPUCompilationMessage}}.{{GPUCompilationMessage/lineNum}} 和
{{GPUCompilationMessage}}.{{GPUCompilationMessage/linePos}} 都是从1开始的，因为它们最常见的用途预计是打印出可直接与许多文本编辑器中显示的行号和列号相关联的易于阅读的消息。


注：{{GPUCompilationMessage}}.{{GPUCompilationMessage/offset}} 和
{{GPUCompilationMessage}}.{{GPUCompilationMessage/length}} 可以传递给
`substr()` 以获取着色器 {{GPUShaderModuleDescriptor/code}} 子字符串中与
{{GPUCompilationMessage/message}} 相对应的部分。

<dl dfn-type=method dfn-for=GPUShaderModule>
    : <dfn>getCompilationInfo()</dfn>
    ::
        返回 {{GPUShaderModule}} 编译期间生成的任何消息。

         消息的位置、顺序和内容是实现定义的。
         特别是，消息可能不会按 {{GPUCompilationMessage/lineNum}} 排序。

        <div algorithm=GPUShaderModule.getCompilationInfo>
            <div data-timeline=content>
                **Called on:** {{GPUShaderModule}} this

                **Returns:** {{Promise}}&lt;{{GPUCompilationInfo}}&gt;

                [=内容时间线=] 步骤：

                1. 使 <var data-timeline=content>contentTimeline</var> 为当前 [=内容时间线=]。
                1. 使 |promise| 为 [=a new promise=].
                1. 在 |this| 的 [=设备时间线=] 上发起 |synchronization steps|。
                1. 返回 |promise|。
            </div>
            <div data-timeline=device>
                [=设备时间线=] |synchronization steps|:

                1. 当 [=设备时间线=] 通知 |this| 的 [=shader module creation=] 已完成时：
                     1. 让 |messages| 是在 |this| 的 [=shader module creation=] 期间生成的任何错误、警告或信息性消息的列表。
                     1. 在 <var data-timeline=content>contentTimeline</var> 上发布后续步骤。
            </div>
            <div data-timeline=content>
                [=内容时间线=] 步骤：

                1. 使 |info| 为一个新的 {{GPUCompilationInfo}}。
                1. 对每个 |messages| 中的 |message|：
                    1. 使 |m| 为一个新的 {{GPUCompilationMessage}}。
                    1. 设置 |m|.{{GPUCompilationMessage/message}} 为 |message| 的文本。
                    1.
                        <dl class=switch>
                            : 如果 |message| 为一个 [=shader-creation error=]:
                            :: 设置 |m|.{{GPUCompilationMessage/type}} 为
                                {{GPUCompilationMessageType/"error"}}
                            : 如果 |message| 为一个警告：
                            :: 设置 |m|.{{GPUCompilationMessage/type}} 为
                                {{GPUCompilationMessageType/"warning"}}
                            : 否则
                            :: 设置 |m|.{{GPUCompilationMessage/type}} 为
                                {{GPUCompilationMessageType/"info"}}
                        </dl>
                    1.
                        <dl class=switch>
                            : 如果 |message| 与着色器 {{GPUShaderModuleDescriptor/code}} 中的特定子字符串或位置相关联：
                            ::
                                1. 将 |m|.{{GPUCompilationMessage/lineNum}} 设置为消息引用的第一行的基于一的编号。
                                2. 将 |m|.{{GPUCompilationMessage/linePos}} 设置为 |m|.{{GPUCompilationMessage/lineNum}} 上消息引用的第一个基于一的 UTF-16 代码单元编号，如果 |message| 引用整行，则为 1。
                                3. 将 |m|.{{GPUCompilationMessage/offset}} 设置为从着色器开头到 |message| 引用的子字符串或位置开头的 UTF-16 代码单元数。
                                4. 将 |m|.{{GPUCompilationMessage/length}} 设置为 |message| 引用的子字符串的 UTF-16 代码单元长度，如果 |message| 引用一个位置，则为 0。
                            : 否则：
                            ::
                                1. 设置 |m|.{{GPUCompilationMessage/lineNum}} 为 `0`。
                                1. 设置 |m|.{{GPUCompilationMessage/linePos}} 为 `0`。
                                1. 设置 |m|.{{GPUCompilationMessage/offset}} 为 `0`。
                                1. 设置 |m|.{{GPUCompilationMessage/length}} 为 `0`。
                        </dl>
                    1. [=list/添加=] |m| 至 |info|.{{GPUCompilationInfo/messages}}。

                1. 以 |info| [=解析=] |promise|。
            </div>
        </div>
</dl>

# 管线 # {#pipelines}

一个<dfn dfn>管线</dfn>，无论是{{GPUComputePipeline}}还是{{GPURenderPipeline}}，代表了完成输入数据处理的整个功能，这些数据以绑定和顶点缓冲区的形式存在，并产生一些输出，如输出渲染目标中的颜色。


在结构上，[=pipeline=] 由一系列可编程阶段（着色器）和固定功能状态（如混合模式）组成。


注：在内部，根据目标平台，驱动程序可能会将一些固定功能状态转换为着色器代码，并将其与用户提供的着色器链接在一起。这种链接是对象作为一个整体创建的原因之一。


这种组合状态是作为一个单独的对象创建的（{{GPUComputePipeline}} 或 {{GPURenderPipeline}}），并使用一个命令进行切换（分别为：{{GPUComputePassEncoder}}.{{GPUComputePassEncoder/setPipeline()}} 或 {{GPURenderCommandsMixin}}.{{GPURenderCommandsMixin/setPipeline()}}）。


创建管线有两种方法：

: <dfn dfn>immediate pipeline creation</dfn>
:: {{GPUDevice/createComputePipeline()}} and {{GPUDevice/createRenderPipeline()}}
    返回一个可以立即在 pass 编码器中使用的管线对象。

    当此操作失败时，管线对象将无效，调用将产生一个[$validation error$]或一个[$internal error$]。

    注：
    返回一个句柄对象是立即进行的，但实际的管线创建并不是同步的。如果管线创建需要很长时间，这可能会在创建调用和首次使用它的{{GPUQueue/submit()}}之间的某个时间点引入[=设备时间表=]中的停顿。这个时间点没有明确规定，但最可能是以下之一：在创建时，在 setPipeline() 中第一次使用管线时，在相应的{{GPUCommandEncoder}}或{{GPURenderBundleEncoder}}的finish()时，或在{{GPUCommandBuffer}}的 {{GPUQueue/submit()}}时。

: <dfn dfn>async pipeline creation</dfn>
:: {{GPUDevice/createComputePipelineAsync()}} and {{GPUDevice/createRenderPipelineAsync()}}
    返回一个 `Promise`，当管线创建完成时，它将解析为一个管线对象。


    当这个操作失败时，`Promise`会被一个{{GPUPipelineError}}拒绝。

<dfn interface>GPUPipelineError</dfn> 描述管线创建失败。

<!--TODO(gpuweb/gpuweb#3709): Change `message` to optional, defaulting to `""`. -->

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext, Serializable]
interface GPUPipelineError : DOMException {
    constructor((DOMString or undefined) message, GPUPipelineErrorInit options);
    readonly attribute GPUPipelineErrorReason reason;
};

dictionary GPUPipelineErrorInit {
    required GPUPipelineErrorReason reason;
};

enum GPUPipelineErrorReason {
    "validation",
    "internal"
};
</script>

{{GPUPipelineError}} constructor:

<dl dfn-type=constructor dfn-for=GPUPipelineError data-timeline=content>
    : <dfn>constructor()</dfn>
    ::
        <div algorithm="GPUPipelineError constructor">
            <pre class=argumentdef for="GPUPipelineError/constructor()">
                |message|: 基础{{DOMException}}的错误信息。
                |options|: 针对{{GPUPipelineError}}的特定选项。
            </pre>

            1. 设置 [=this=].{{DOMException/name}} 为 `"GPUPipelineError"`。
            1. 设置 [=this=].{{DOMException/message}} 为 |message| ?? `""`。
            1. 设置 [=this=].{{GPUPipelineError/reason}} 为 |options|.{{GPUPipelineErrorInit/reason}}。
        </div>
</dl>

{{GPUPipelineError}} 具有以下参数：

<dl dfn-type=attribute dfn-for=GPUPipelineError>
    : <dfn>reason</dfn>
    ::
        一个只读的[=slot-backed attribute=]，以<dfn enum for="">GPUPipelineErrorReason</dfn>的形式展示管线创建过程中遇到的错误类型：

        <ul dfn-type=enum-value dfn-for=GPUPipelineErrorReason>
            - <dfn>"validation"</dfn>: 一个 [$validation error$].
            - <dfn>"internal"</dfn>: 一个 [$internal error$].
        </ul>
</dl>

{{GPUPipelineError}} 对象是 [[HTML#serializable-objects|serializable objects]].

<div algorithm="GPUPipelineError serialization steps" data-timeline=content>
    它们的[=序列化步骤=]，给定 |value| 和 |serialized|，如下：


    1. 根据给定的|值|和|序列化|,运行{{DOMException}}的[=序列解步骤=]。
</div>

<div algorithm="GPUPipelineError deserialization steps" data-timeline=content>
    他们的 [=deserialization steps=]，给定 |value| 和 |serialized|，如下：


    1. 运行 {{DOMException}} [=deserialization steps=] 给定 |value| 和 |serialized|。
</div>

## 基础管线 ## {#pipeline-base}

<script type=idl>
enum GPUAutoLayoutMode {
    "auto"
};

dictionary GPUPipelineDescriptorBase
         : GPUObjectDescriptorBase {
    required (GPUPipelineLayout or GPUAutoLayoutMode) layout;
};

interface mixin GPUPipelineBase {
    [NewObject] GPUBindGroupLayout getBindGroupLayout(unsigned long index);
};
</script>

{{GPUPipelineBase}} 具有以下内部插槽：

<dl dfn-type=attribute dfn-for=GPUPipelineBase>
    : <dfn>\[[layout]]</dfn>, 类型为 `GPUPipelineLayout`
    ::
        此资源布局的定义可以与 `this` 一起使用。
</dl>

{{GPUPipelineBase}} 具有以下方法：

<dl dfn-type=method dfn-for=GPUPipelineBase>
    : <dfn>getBindGroupLayout(index)</dfn>
    ::
        获取与{{GPUPipelineBase}}的
        {{GPUBindGroupLayout}}兼容的 `index` 处的{{GPUBindGroupLayout}}。

        <div algorithm=GPUPipelineBase.getBindGroupLayout>
            <div data-timeline=content>
                **Called on:** {{GPUPipelineBase}} |this|

                **Arguments:**

                <pre class=argumentdef for="GPUPipelineBase/getBindGroupLayout(index)">
                    |index|: 管线布局的 {{GPUPipelineLayout/[[bindGroupLayouts]]}} 序列的索引。
                </pre>

                **Returns:** {{GPUBindGroupLayout}}

                [=内容时间线=] steps:

                1. 使 |layout| 为一个新的 {{GPUBindGroupLayout}} 对象。
                1. 在 |this| 的 [=设备时间线=] 上发起 |initialization steps|。
                1. 返回 |layout|。
            </div>
            <div data-timeline=device>
                [=设备时间线=] |initialization steps|:

                1. 如果以下任何条件不满足，生成验证错误，使得|layout| 无效，并停止。


                <div class=validusage>
                    - |this| 是有效的。
                    - |index| 小于 |this|.{{GPUPipelineBase/[[layout]]}}.{{GPUPipelineLayout/[[bindGroupLayouts]]}} 的 [=list/size=]
                </div>


                1. 初始化 |layout|，使其成为 |this|.{{GPUPipelineBase/[[layout]]}}.{{GPUPipelineLayout/[[bindGroupLayouts]]}}[|index|] 的副本。

                注意: {{GPUBindGroupLayout}} 仅按值使用，而不是按引用使用，因此这等同于在新的包装器中返回相同的内部对象。每次返回一个新的 {{GPUBindGroupLayout}} 包装器是为了避免在 [=内容时间线=] 和 [=设备时间线=] 之间进行往返。
            </div>
        </div>
</dl>

### 默认管线布局 ### {#default-pipeline-layout}

一个创建时将 {{GPUPipelineDescriptorBase/layout}} 设置为 {{GPUAutoLayoutMode/“auto”}} 的 {{GPUPipelineBase}} 对象，会创建并使用一个默认布局。


注：默认布局是为简单 pipeline 提供的便利，但在大多数情况下推荐使用显式布局。从默认布局创建的绑定组不能与其他 pipeline 一起使用，当改变着色器时，默认布局的结构可能会改变，从而导致意外的绑定组创建错误。

<div algorithm="default pipeline layout creation">

要为{{GPUPipelineBase}} |pipeline|创建一个<dfn abstract-op>默认管线布局</dfn>，请执行以下步骤：

    1. 令 |groupCount| 为 0。
    1. 令 |groupDescs| 为一个有 |device|.{{device/[[limits]]}}.{{supported limits/maxBindGroups}}
        个新的 {{GPUBindGroupLayoutDescriptor}} 对象的序列。
    1. 对于 |groupDescs| 中的每个 |groupDesc|：

        1. 将 |groupDesc|.{{GPUBindGroupLayoutDescriptor/entries}} 设置为一个空的 [=序列=]。
        
    1. 对于用于创建 |pipeline| 的描述符中的每个 {{GPUProgrammableStage}} |stageDesc|：

        1. 令 |shaderStage| 为 |stageDesc|.{{GPUProgrammableStage/entryPoint}} 
            在 |stageDesc|.{{GPUProgrammableStage/module}} 中的 {{GPUShaderStageFlags}} 。
        1. 对于 |stageDesc| [=静态使用=] 的每个资源 |resource|：
        
            1. 让 |group| 成为 |resource| 的 "group" 装饰。
            1. 让 |binding| 成为 |resource| 的 "binding" 装饰。
            1. 让 |entry| 成为一个新的 {{GPUBindGroupLayoutEntry}}。
            1. 将 |entry|.{{GPUBindGroupLayoutEntry/binding}} 设置为 |binding|。
            1. 将 |entry|.{{GPUBindGroupLayoutEntry/visibility}} 设置为 |shaderStage|。
            1. 如果 |resource| 用于采样器绑定：

                1. 令 |samplerLayout| 为一个新的 {{GPUSamplerBindingLayout}}。
                1. 设置 |entry|.{{GPUBindGroupLayoutEntry/sampler}} 为 |samplerLayout|。

            1. 如果 |resource| 用于比较采样器绑定：

                1. 创建一个新的 {{GPUSamplerBindingLayout}}，将其命名为 |samplerLayout|。
                1. 将 |samplerLayout| 的 {{GPUSamplerBindingLayout/type}} 设置为 {{GPUSamplerBindingType/"comparison"}}。
                1. 将 |entry| 的 {{GPUBindGroupLayoutEntry/sampler}} 设置为 |samplerLayout|。

            1. 如果 |resource| 用于缓冲区绑定：

                1. 创建一个新的 {{GPUBufferBindingLayout}}，将其命名为 |bufferLayout|。

                1. 将 |bufferLayout| 的 {{GPUBufferBindingLayout/minBindingSize}} 设置为 |resource| 的 [=最小缓冲区绑定尺寸=]。

                1. 如果 |resource| 用于只读存储缓冲区：

                    1. 将 |bufferLayout| 的 {{GPUBufferBindingLayout/type}} 设置为 {{GPUBufferBindingType/"read-only-storage"}}。

                1. 如果 |resource| 用于存储缓冲区：

                    1. 将 |bufferLayout| 的 {{GPUBufferBindingLayout/type}} 设置为 {{GPUBufferBindingType/"storage"}}。

                1. 将 |entry| 的 {{GPUBindGroupLayoutEntry/buffer}} 设置为 |bufferLayout|。

            1. 如果 |resource| 是采样纹理绑定：

                1. 令 |textureLayout| 为一个新的 {{GPUTextureBindingLayout}}。

                1. 如果 |resource| 是深度纹理绑定：

                    - 将 |textureLayout|.{{GPUTextureBindingLayout/sampleType}} 设置为 {{GPUTextureSampleType/"depth"}}

                    否则，如果 |resource| 的采样类型是：

                    <dl class=switch>
                        : `f32` 并且存在一个带有 `textureSample*` 内置的 |resource| 的 [=static use=]
                        :: 将 |textureLayout|.{{GPUTextureBindingLayout/sampleType}} 设置为 {{GPUTextureSampleType/"float"}}
                        : `f32` 其他情况
                        :: 将 |textureLayout|.{{GPUTextureBindingLayout/sampleType}} 设置为 {{GPUTextureSampleType/"unfilterable-float"}}
                        : `i32`
                        :: 将 |textureLayout|.{{GPUTextureBindingLayout/sampleType}} 设置为 {{GPUTextureSampleType/"sint"}}
                        : `u32`
                        :: 将 |textureLayout|.{{GPUTextureBindingLayout/sampleType}} 设置为 {{GPUTextureSampleType/"uint"}}
                    </dl>

                1. 将 |textureLayout|.{{GPUTextureBindingLayout/viewDimension}} 设置为 |resource| 的维度。
                1. 如果 |resource| 是多重采样纹理：

                    1. 将 |textureLayout|.{{GPUTextureBindingLayout/multisampled}} 设置为 `true`。

                1. 设置 |entry|.{{GPUBindGroupLayoutEntry/texture}} 为 |textureLayout|。

            1. 如果|resource|适用于存储纹理绑定:

                1. 令|storageTextureLayout|为一个新的{{GPUStorageTextureBindingLayout}}。
                1. 设置|storageTextureLayout|.{{GPUStorageTextureBindingLayout/format}}为|resource|的格式。
                1. 设置|storageTextureLayout|.{{GPUStorageTextureBindingLayout/viewDimension}}为|resource|的维度。

                1. 如果|resource|是一个只写存储纹理:

                    1. 设置|storageTextureLayout|.{{GPUStorageTextureBindingLayout/access}}为{{GPUStorageTextureAccess/"write-only"}}。

                1. 设置|entry|.{{GPUBindGroupLayoutEntry/storageTexture}}为|storageTextureLayout|。

            1. 设置|groupCount|为max(|groupCount|，|group|+1)。

            1. 如果 |groupDescs|[|group|] 有一个条目 |previousEntry|，其 {{GPUBindGroupLayoutEntry/binding}} 等于 |binding| :

                1. 如果 |entry| 和 |previousEntry| 具有不同的 {{GPUBindGroupLayoutEntry/visibility}} :

                    1. 将 |entry|.{{GPUBindGroupLayoutEntry/visibility}} 中设置的位添加到 |previousEntry|.{{GPUBindGroupLayoutEntry/visibility}}

                1. 如果 |resource| 是一个缓冲区绑定，并且 |entry| 的
                    {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}
                    大于 |previousEntry| :

                    1. 设置 |previousEntry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}
                        为 |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}。

                1. 如果 |resource| 是一个采样纹理绑定，并且 |entry| 和 |previousEntry|
                    的 {{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} 不同，
                    且 |entry| 和 |previousEntry| 都具有 {{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}}
                    的 {{GPUTextureSampleType/"float"}} 或 {{GPUTextureSampleType/"unfilterable-float"}} 类型：
                    1. 设置 |previousEntry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} 为
                        {{GPUTextureSampleType/"float"}}。

                1. 如果 |entry| 和 |previousEntry| 之间的任何其他属性不相等：

                    1. 返回 `null`（这将导致管线的创建失败）。

            1. 其他情况

                1. 将 |entry| 附加到 |groupDescs|[|group|]。

    1. 对于从 0 到 |groupCount| - 1（含）的每个 |i|：
        1. 让 |groupDesc| 为 |groupDescs|[|i|]。
        1. 令 |bindGroupLayout| 为调用 |device|.{{GPUDevice/createBindGroupLayout()}}(|groupDesc|)的结果。
        1. 将 |bindGroupLayout|.{{GPUBindGroupLayout/[[exclusivePipeline]]}} 设置为 |pipeline|。
        1. 将 |bindGroupLayout| 添加到 |groupLayouts|。

    1. 令 |desc| 为一个新的 {{GPUPipelineLayoutDescriptor}}。

    1. 将 |desc|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}} 设置为 |groupLayouts|。

    1. 返回 |device|.{{GPUDevice/createPipelineLayout()}}(|desc|)。
</div>

<h4 id=gpuprogrammablestage data-dfn-type=dictionary>`GPUProgrammableStage`
<span id=GPUProgrammableStage></span>
</h4>

一个 {{GPUProgrammableStage}} 描述了用户提供的 {{GPUShaderModule}} 中控制 [=pipeline=] 的可编程阶段之一的入口点。入口点名称遵循 [=WGSL 标识符比较=] 中定义的规则。

<script type=idl>
dictionary GPUProgrammableStage {
    required GPUShaderModule module;
    required USVString entryPoint;
    record<USVString, GPUPipelineConstantValue> constants;
};

typedef double GPUPipelineConstantValue; // May represent WGSL's bool, f32, i32, u32, and f16 if enabled.
</script>

{{GPUProgrammableStage}} 具有以下成员：

<dl dfn-for=GPUProgrammableStage dfn-type=dict-member>
    : <dfn>module</dfn>
    ::
        包含该可编程阶段将执行的代码的{{GPUShaderModule}}。

    : <dfn>entryPoint</dfn>
    ::
        函数名称位于 {{GPUProgrammableStage/module}} 中，此阶段将使用该函数来执行其工作。

    : <dfn>constants</dfn>
    ::
        指定着色器模块 {{GPUProgrammableStage/module}} 中 [=pipeline-overridable=] 常量的值。


        每个这样的 [=pipeline-overridable=] 常量都由单个 [=pipeline-overridable constant identifier string=] 唯一标识 (表示常量的数字ID，如果有，则表示常量的标识符名称)。源代码映射中的 WGSL 名称（标识符）遵循 [=WGSL identifier comparison=] 中定义的规则。


        每个键值对的键必须等于这样一个常量的标识符字符串。当管线被执行时，该常量将具有指定的值。


        值指定为 <dfn typedef for="">GPUPipelineConstantValue</dfn>, 这是一个 {{double}}。它们被转换为管线可覆盖常量的 [$to WGSL 类型$] (bool/i32/u32/f32/f16)。如果转换失败，则会生成一个验证错误。

        <div class=example>
            Pipeline-overridable constants defined in WGSL:

            <pre highlight=rust>
                @id(0)      override has_point_light: bool = true;  // Algorithmic control.
                @id(1200)   override specular_param: f32 = 2.3;     // Numeric control.
                @id(1300)   override gain: f32;                     // Must be overridden.
                            override width: f32 = 0.0;              // Specifed at the API level
                                                                    //   using the name "width".
                            override depth: f32;                    // Specifed at the API level
                                                                    //   using the name "depth".
                                                                    //   Must be overridden.
                            override height = 2 * depth;            // The default value
                                                                    // (if not set at the API level),
                                                                    // depends on another
                                                                    // overridable constant.
            </pre>

            对应的JavaScript代码，仅提供所需的重写（没有默认值）：

            <pre highlight=js>
                {
                    // ...
                    constants: {
                        1300: 2.0,  // "gain"
                        depth: -1,  // "depth"
                    }
                }
            </pre>

            相应的 JavaScript 代码，覆盖所有常量：

            <pre highlight=js>
                {
                    // ...
                    constants: {
                        0: false,   // "has_point_light"
                        1200: 3.0,  // "specular_param"
                        1300: 2.0,  // "gain"
                        width: 20,  // "width"
                        depth: -1,  // "depth"
                        height: 15, // "height"
                    }
                }
            </pre>
        </div>
</dl>

<div algorithm data-timeline=device>
    <dfn abstract-op>validating GPUProgrammableStage</dfn>(stage, descriptor, layout)

    **Arguments:**

    - {{GPUShaderStage}} |stage|
    - {{GPUProgrammableStage}} |descriptor|
    - {{GPUPipelineLayout}} |layout|

    返回 `true`，如果满足以下所有条件：


    - |descriptor| 的 {{GPUProgrammableStage/module}} 必须是一个 [=有效=] 的 {{GPUShaderModule}}。
    - |descriptor| 的 {{GPUProgrammableStage/module}} 必须包含一个入口点，用于着色阶段 |阶段|，命名为 |descriptor| 的 {{GPUProgrammableStage/entryPoint}}。
    - 对于 |descriptor| 中 [=静态使用=] 的每一个 |binding|：
        - [$validating shader binding$] (|binding|，|layout|) 必须返回 `true`。
    - 对于 |descriptor| 中的每个纹理和采样器，它们在纹理采样调用中 [=静态使用=]：
        1. 将 |texture| 设为调用中采样纹理相对应的 {{GPUBindGroupLayoutEntry}}。
        1. 将 |sampler| 设为调用中使用的采样器相对应的 {{GPUBindGroupLayoutEntry}}。
        1. 如果 |sampler| 的 {{GPUSamplerBindingLayout/type}} 为 {{GPUSamplerBindingType/"filtering"}}，则 |纹理| 的 {{GPUTextureBindingLayout/sampleType}} 必须为 {{GPUTextureSampleType/"float"}}。
    - 对于 |descriptor| 的 {{GPUProgrammableStage/constants}} 中的每个 |键| ➞ |值|：
        1. |key| 必须等于着色器模块 |descriptor| 的 {{GPUProgrammableStage/module}} 中根据 [=WGSL 标识符比较=] 规则定义的某个 [=管线可重载=] 常量的 [=管线可重载常量标识符字符串=]。将该常量的类型设为 |T|。
        1. 将 IDL 值 |值| [$to WGSL 类型$] |T| 转换成不抛出 {{TypeError}} 的异常。
    - 对于 |descriptor| 中 [=静态使用=] 的每个 [=管线可重载常量标识符字符串=] |键|:
        -如果由 |key| 标识的管线可重载常量 [=管线可重载常量默认值|没有默认值=]，则 |descriptor| 的 {{GPUProgrammableStage/constants}} 必须 [=映射/包含=] |键|。

    返回值 `false` 对应于 [=管线创建错误=]。
</div>

<div algorithm>
    <dfn abstract-op>validating shader binding</dfn>(binding, layout)

    **Arguments:**

    - 着色器绑定声明 |variable|，从着色器模块反射出的模块作用域变量声明
    - {{GPUPipelineLayout}} |layout|

    让 |bindGroup| 成为绑定组索引，|bindIndex| 成为着色器绑定声明 |variable| 的绑定索引。


    如果满足以下所有条件，则返回 `true`：

        - |layout|.{{GPUPipelineLayout/[[bindGroupLayouts]]}}[|bindGroup|] 包含 一个 {{GPUBindGroupLayoutEntry}} |entry|，其 |entry|.{{GPUBindGroupLayoutEntry/binding}} == |bindIndex|。
        - 如果 |entry| 的定义的 [=binding member=] 是：

            <dl class=switch>
                : {{GPUBindGroupLayoutEntry/buffer}}
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/type}} 为：

                    <dl class=switch>
                        : {{GPUBufferBindingType/"uniform"}}
                        :: |variable| 的地址空间为 `uniform`。
                        : {{GPUBufferBindingType/"storage"}}
                        :: |variable| 的地址空间为 `storage`，地址模式为 `read_write`。
                        : {{GPUBufferBindingType/"read-only-storage"}}
                        :: |variable| 的地址空间为 `storage`，地址模式为 `read`。
                    </dl>

                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}} 不是 `0`，那么它必须至少是着色器中关联缓冲区绑定变量的[=最小缓冲区绑定大小=]。

                : {{GPUBindGroupLayoutEntry/sampler}}
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/sampler}}.{{GPUSamplerBindingLayout/type}} 为：

                    <dl class=switch>
                        : {{GPUSamplerBindingType/"filtering"}} or {{GPUSamplerBindingType/"non-filtering"}}
                        :: |variable| 类型为 `sampler`.
                        : {{GPUSamplerBindingType/"comparison"}}
                        :: |variable| 类型为 `sampler_comparison`.
                    </dl>

                : {{GPUBindGroupLayoutEntry/texture}}
                ::
                    如果且仅当 |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/multisampled}} 为 true，|variable| 类型为 texture_multisampled_2d<T> 或 texture_depth_multisampled_2d<T>。
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} 为：

                    <dl class=switch>
                        : {{GPUTextureSampleType/"float"}}, {{GPUTextureSampleType/"unfilterable-float"}},
                            {{GPUTextureSampleType/"sint"}} or {{GPUTextureSampleType/"uint"}}
                        ::
                            |variable| 为以下类型之一：

                            - `texture_1d<T>`
                            - `texture_2d<T>`
                            - `texture_2d_array<T>`
                            - `texture_cube<T>`
                            - `texture_cube_array<T>`
                            - `texture_3d<T>`
                            - `texture_multisampled_2d<T>`
                        ::
                            如果 |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} 为：

                            <dl class=switch>
                                : {{GPUTextureSampleType/"float"}} or {{GPUTextureSampleType/"unfilterable-float"}}
                                :: 采样类型 `T` 为 `f32`.
                                : {{GPUTextureSampleType/"sint"}}
                                :: 采样类型 `T` 为 `i32`.
                                : {{GPUTextureSampleType/"uint"}}
                                :: 采样类型 `T` 为 `u32`.
                            </dl>

                        : {{GPUTextureSampleType/"depth"}}
                        ::
                            |variable| 为以下类型之一：

                            - `texture_2d<T>`
                            - `texture_2d_array<T>`
                            - `texture_cube<T>`
                            - `texture_cube_array<T>`
                            - `texture_multisampled_2d<T>`
                            - `texture_depth_2d`
                            - `texture_depth_2d_array`
                            - `texture_depth_cube`
                            - `texture_depth_cube_array`
                            - `texture_depth_multisampled_2d`

                            其中采样类型 `T` 是 `f32`。
                    </dl>
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/viewDimension}} 为：

                    <dl class=switch>
                        : {{GPUTextureViewDimension/"1d"}}
                        :: |variable| 类型为 `texture_1d<T>`.
                        : {{GPUTextureViewDimension/"2d"}}
                        :: |variable| 类型为 `texture_2d<T>` 或 `texture_multisampled_2d<T>`.
                        : {{GPUTextureViewDimension/"2d-array"}}
                        :: |variable| 类型为 `texture_2d_array<T>`.
                        : {{GPUTextureViewDimension/"cube"}}
                        :: |variable| 类型为 `texture_cube<T>`.
                        : {{GPUTextureViewDimension/"cube-array"}}
                        :: |variable| 类型为 `texture_cube_array<T>`.
                        : {{GPUTextureViewDimension/"3d"}}
                        :: |variable| 类型为 `texture_3d<T>`.
                    </dl>

                : {{GPUBindGroupLayoutEntry/storageTexture}}
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/viewDimension}} 为：

                    <dl class=switch>
                        : {{GPUTextureViewDimension/"1d"}}
                        :: |variable| 类型为 `texture_storage_1d<T, A>`.
                        : {{GPUTextureViewDimension/"2d"}}
                        :: |variable| 类型为 `texture_storage_2d<T, A>`.
                        : {{GPUTextureViewDimension/"2d-array"}}
                        :: |variable| 类型为 `texture_storage_2d_array<T, A>`.
                        : {{GPUTextureViewDimension/"3d"}}
                        :: |variable| 类型为 `texture_storage_3d<T, A>`.
                    </dl>
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/access}} 为：

                    <dl class=switch>
                        : {{GPUStorageTextureAccess/"write-only"}}
                        :: 访问模式 `A` 为 `write`.
                    </dl>
                ::
                    纹素格式 `T` 等于
                    |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/format}}.
            </dl>
</div>

<div algorithm>
    缓冲区绑定变量 |var| 的<dfn dfn>最小缓冲区绑定大小</dfn>的计算如下：

    1. 让 |T| 成为 |var| 的[= store type =]。
    1. 如果 |T| 是一个[=运行时大小=]的数组或包含一个运行时大小的数组，将 `array<E>` 替换为 `array<E, 1>`。

        注：这确保总是有足够的内存存放一个元素，允许数组索引被限制在数组的长度范围内，从而在内存里进行访问。
    1. 返回 [$SizeOf$](|T|)。

    注：
    强制执行此下限可确保通过缓冲区变量进行的读写仅访问缓冲区绑定区域内的内存位置。
</div>

<div algorithm>
    资源绑定、[=管线可覆盖=] 常量、着色器阶段输入或着色器阶段输出
    被认为是由 {{GPUProgrammableStage}} <dfn dfn lt=“statically used|static use”>静态使用</dfn>，
    如果它存在于指定的 {{GPUProgrammableStage/entryPoint}} 的 [=interface of a shader stage|着色器阶段接口=] 中，
    在指定的着色器 {{GPUProgrammableStage/module}} 中。
</div>

<h3 id=gpucomputepipeline data-dfn-type=interface>`GPUComputePipeline`
<span id=compute-pipeline></span>
</h3>

一个{{GPUComputePipeline}}是一种控制计算着色器阶段的[=管线=]，可以在{{GPUComputePassEncoder}}中使用。


计算输入和输出都包含在绑定中，根据给定的{{GPUPipelineLayout}}。
输出对应于类型为{{GPUBufferBindingType/“storage”}}的{{GPUBindGroupLayoutEntry/buffer}}绑定，以及类型为{{GPUStorageTextureAccess/“write-only”}}的{{GPUBindGroupLayoutEntry/storageTexture}}绑定。

计算 [=管线=] 的阶段：

1. Compute shader

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUComputePipeline {
};
GPUComputePipeline includes GPUObjectBase;
GPUComputePipeline includes GPUPipelineBase;
</script>

### 计算管线创建 ### {#compute-pipeline-creation}

一个 {{GPUComputePipelineDescriptor}} 描述了一个计算 [=pipeline=]。请参阅 [[#computing-operations]] 以获取更多详细信息。

<script type=idl>
dictionary GPUComputePipelineDescriptor
         : GPUPipelineDescriptorBase {
    required GPUProgrammableStage compute;
};
</script>

{{GPUComputePipelineDescriptor}} 具有以下成员：

<dl dfn-type=dict-member dfn-for=GPUComputePipelineDescriptor>
    : <dfn>compute</dfn>
    ::
        描述 [=管线=] 的计算着色器入口点。
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createComputePipeline(descriptor)</dfn>
    ::
        Creates a {{GPUComputePipeline}} using [=immediate pipeline creation=].

        <div algorithm=GPUDevice.createComputePipeline>
            <div data-timeline=content>
                **Called on:** {{GPUDevice}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUDevice/createComputePipeline(descriptor)">
                    |descriptor|: 要创建的 {{GPUComputePipeline}} 的描述。
                </pre>

                **Returns:** {{GPUComputePipeline}}

                [=内容时间线=] 步骤：

                1. 让 |pipeline| 成为一个新的 {{GPUComputePipeline}} 对象。
                1. 在 |this| 的 [=Device timeline=] 上发布 |initialization steps|。
                1. 返回 |pipeline|。
            </div>
            <div data-timeline=device>
                [=设备时间线=] |initialization steps|:

                1. 如果 |descriptor|.{{GPUPipelineDescriptorBase/layout}} 是 {{GPUAutoLayoutMode/“auto”}}，则让 |layout| 成为 |pipeline| 的新[$默认管线布局$]；否则，使用 |descriptor|.{{GPUPipelineDescriptorBase/layout}}。

                1. 如果以下任何条件不满足 [$生成验证错误$]，则使 |pipeline| 变为 [=invalid=]，并停止。

                    <div class=validusage>
                        - |layout| 必须是与 |this| [$可用$]的。
                        - 与[[$验证 GPUProgrammableStage$]]({{GPUShaderStage/COMPUTE}}，
                            |descriptor|.{{GPUComputePipelineDescriptor/compute}}，|layout|) 成功匹配。
                        - 设 |workgroupStorageUsed| 是由 |descriptor|.{{GPUComputePipelineDescriptor/compute}} 的"[=地址空间/工作组=]"地址空间中的所有变量的类型 |T| 的 [$SizeOf$](|T|) 在每个
                            类型 |T| 上的 [=roundUp=](16) 的和。

                            |workgroupStorageUsed| 必须是&le;
                            |device|.limits.{{支持的限制/maxComputeWorkgroupStorageSize}}。

                            问题(gpuweb/gpuweb#3485)：这是否需要考虑填充？
                        - |descriptor|.{{GPUComputePipelineDescriptor/compute}} 的工作组使用数量必须是 &le;
                            |device|.limits.{{支持的限制/maxComputeInvocationsPerWorkgroup}}。

                        - |descriptor|.{{GPUComputePipelineDescriptor/compute}} 的
                            `workgroup_size` 属性的每个组件都必须是 &le; [在
                            [|device|.limits.{{支持的限制/maxComputeWorkgroupSizeX}},
                            |device|.limits.{{支持的限制/maxComputeWorkgroupSizeY}},
                            |device|.limits.{{支持的限制/maxComputeWorkgroupSizeZ}}]] 对应的组件。
                    </div>
                1. 将 |pipeline|.{{GPUPipelineBase/[[layout]]}} 设置为 |layout|。
            </div>
        </div>

    : <dfn>createComputePipelineAsync(descriptor)</dfn>
    ::
        创建一个使用 [=异步管线创建=] 的 {{GPUComputePipeline}}。
        当创建的管线准备好可立即使用时，返回的 {{Promise}} 将会解析。


        如果管线创建失败，返回的 {{Promise}} 会以 {{GPUPipelineError}} 拒绝。

        注：尽可能使用此方法，因为它可以阻止 [=queue timeline=] 在管线编译上的工作。

        <div algorithm=GPUDevice.createComputePipelineAsync>
            <div data-timeline=content>
                **Called on:** {{GPUDevice}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUDevice/createComputePipelineAsync(descriptor)">
                    |descriptor|: Description of the {{GPUComputePipeline}} to create.
                </pre>

                **Returns:** {{Promise}}&lt;{{GPUComputePipeline}}&gt;

                [=内容时间线=] 步骤：

                1. 设 <var data-timeline=content>contentTimeline</var> 为当前的 [=内容时间线=]。
                1. 设 |promise| 为 [=a new promise=]。
                1. 在 |this| 的 [=设备时间线=]上发布 |initialization steps|。
                1. 返回 |promise|。
            </div>
            <div data-timeline=device>
                [=设备时间线=] |initialization steps|:

                1. 令 |pipeline| 为一个新的 {{GPUComputePipeline}}，创建方式如同调用 |this|.{{GPUDevice/createComputePipeline()}} 并使用 |descriptor|；

                1. 当 |pipeline| 准备好被使用或已变为 [=无效=] 的，在 <var data-timeline=content>contentTimeline</var> 上发出后续步骤。
            </div>
            <div data-timeline=content>
                [=Content timeline=] steps:

                1. If |pipeline|...
                    <dl class=switch>
                        : [=有效=]
                        :: 以 |pipeline| [=解析=] |promise|。
                        : 由于 [$内部错误$] 而变为 [=无效=] 的
                        :: 拒绝 |promise|，并附带一个 {{GPUPipelineError}}，其中 {{GPUPipelineErrorInit/reason}} 的值为 {{GPUPipelineErrorReason/“internal”}}。
                        : 由于 [$验证错误$] 而变为 [=无效=]的
                        :: 拒绝 |promise|，并附带一个 {{GPUPipelineError}}，其中
                            {{GPUPipelineErrorInit/reason}} 的值为 {{GPUPipelineErrorReason/“validation”}}。
                    </dl>
            </div>
        </div>
</dl>

<div class=example>
    Creating a simple {{GPUComputePipeline}}:

    <pre highlight=js>
        const computePipeline = gpuDevice.createComputePipeline({
            layout: pipelineLayout,
            compute: {
                module: computeShaderModule,
                entryPoint: 'computeMain',
            }
        });
    </pre>
</div>

<h3 id=gpurenderpipeline data-dfn-type=interface>`GPURenderPipeline`
<span id=render-pipeline></span>
</h3>

一个{{GPURenderPipeline}}是一种[=管线=]，用于控制顶点和片段着色器阶段，并可以在{{GPURenderPassEncoder}}和{{GPURenderBundleEncoder}}中使用。

渲染 [=管线=] 输入包括：

- 绑定(bindings)，根据给定的{{GPUPipelineLayout}}进行
- 顶点和索引缓冲区，由{{GPUVertexState}}描述
- 颜色附件，由{{GPUColorTargetState}}描述
- 可选的深度模板附件，由{{GPUDepthStencilState}}描述

渲染 [=管线=] 输出包括：

- 具有{{GPUBufferBindingType/“storage”}}类型的{{GPUBindGroupLayoutEntry/buffer}}绑定
- 具有{{GPUStorageTextureAccess/“write-only”}}访问权限的{{GPUBuildGroupLayoutEntry/storageTexture}}绑定
- 颜色附件，由{{GPUColorTargetState}}描述
- 可选的深度模板附件，由{{GPUDepthStencilState}}描述

渲染 [=管线=] 包括以下<dfn dfn>渲染阶段</dfn>：

1. 顶点获取，由{{GPUVertexState/buffers|GPUVertexState.buffers}}控制
1. 顶点着色器，由{{GPUVertexState}}控制
1. 图元装配，由{{GPUPrimitiveState}}控制
1. 栅格化，由{{GPUPrimitiveState}}，{{GPUDepthStencilState}}和{{GPUMultisampleState}}控制
1. 片段着色器，由{{GPUFragmentState}}控制
1. 模板测试及操作，由{{GPUDepthStencilState}}控制
1. 深度测试及写操作，由{{GPUDepthStencilState}}控制
1. 输出合并，由{{GPUFragmentState/targets|GPUFragmentState.targets}}控制

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderPipeline {
};
GPURenderPipeline includes GPUObjectBase;
GPURenderPipeline includes GPUPipelineBase;
</script>

{{GPURenderPipeline}} 具有以下内部插槽：

<dl dfn-type=attribute dfn-for=GPURenderPipeline>
    : <dfn>\[[descriptor]]</dfn>, 类型为 {{GPURenderPipelineDescriptor}}
    ::
        {{GPURenderPipelineDescriptor}} 描述这个管线。

         {{GPURenderPipelineDescriptor}} 的所有可选字段都已定义。

    : <dfn>\[[writesDepth]]</dfn>, 类型为 boolean
    :: 如果管线写入深度/模板附件的深度组件，则为真

    : <dfn>\[[writesStencil]]</dfn>, 类型为 boolean
    :: 如果管线写入深度/模板附件的模板组件，则为真
</dl>

### 渲染管线创建 ### {#render-pipeline-creation}

一个{{GPURenderPipelineDescriptor}}通过配置每个[=渲染阶段=]来描述一个渲染[=管线=]。
有关更多详细信息，请参阅[[#rendering-operations]]。

<script type=idl>
dictionary GPURenderPipelineDescriptor
         : GPUPipelineDescriptorBase {
    required GPUVertexState vertex;
    GPUPrimitiveState primitive = {};
    GPUDepthStencilState depthStencil;
    GPUMultisampleState multisample = {};
    GPUFragmentState fragment;
};
</script>

{{GPURenderPipelineDescriptor}} 具有以下成员：

<dl dfn-type=dict-member dfn-for=GPURenderPipelineDescriptor>
    : <dfn>vertex</dfn>
    ::
        描述了 [=管线=] 的顶点着色器入口点及其输入缓冲区布局。

    : <dfn>primitive</dfn>
    ::
        描述与 [=管线=] 相关的原始属性。

    : <dfn>depthStencil</dfn>
    ::
        描述了可选的深度模板属性，包括测试、操作和偏差。

    : <dfn>multisample</dfn>
    ::
        描述 [=管线=] 的多重采样属性。

    : <dfn>fragment</dfn>
    ::
        描述了 [=管线=] 的片段着色器入口点及其输出颜色。如果没有 [=map/exist|提供=]，则启用 [[#no-color-output]] 模式。
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createRenderPipeline(descriptor)</dfn>
    ::
        创建一个使用[=即时管道创建=]的{{GPURenderPipeline}}。

        <div algorithm=GPUDevice.createRenderPipeline>
            <div data-timeline=content>
                **Called on:** {{GPUDevice}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUDevice/createRenderPipeline(descriptor)">
                    |descriptor|: Description of the {{GPURenderPipeline}} to create.
                </pre>

                **Returns:** {{GPURenderPipeline}}

                [=内容时间线=] 步骤：

                1. 如果 |descriptor|.{{GPURenderPipelineDescriptor/fragment}} 被 [=map/exist|提供=]：

                    1. 对于 |descriptor|.{{GPURenderPipelineDescriptor/fragment}}.{{GPUFragmentState/targets}} 中每个非 null 的 |colorState| 的 [=list/For each=] 操作：
                        1. 使用 |this|.{{GPUObjectBase/[[device]]}}，对 |colorState|.{{GPUColorTargetState/format}} 进行 [=?=] [$验证纹理格式所需特性$]。
                1. 如果 |descriptor|.{{GPURenderPipelineDescriptor/depthStencil}} 被 [=map/exist|提供=]：
                    1. 使用 |this|.{{GPUObjectBase/[[device]]}}，对 |descriptor|.{{GPURenderPipelineDescriptor/depthStencil}}.{{GPUDepthStencilState/format}} 进行 [=?=] [$验证纹理格式所需特性$]。
                1. 让 |pipeline| 成为一个新的 {{GPURenderPipeline}} 对象。
                1. 在 |this| 的 [=设备时间线=] 上发出 |初始化步骤|。
                1. 返回 |pipeline|。

            </div>
            <div data-timeline=device>
                [=设备时间线=] |initialization steps|:

                1. 如果 |descriptor|.{{GPUPipelineDescriptorBase/layout}} 是 {{GPUAutoLayoutMode/“auto”}}，则让 |layout| 成为 |pipeline| 的一个新的[$默认管道布局$]，否则为 |descriptor|.{{GPUPipelineDescriptorBase/layout}}。
                1. 如果任何以下条件不满足： [$产生一个验证错误$]，使 |pipeline| [=无效=]，并停止。

                    <div class=validusage>
                        - |layout| 可以与 |this| 一起[$有效使用$]。
                        - [$验证GPURenderPipelineDescriptor$](|descriptor|, |layout|, |this|)成功。
                        - |layout|.{{GPUPipelineLayout/[[bindGroupLayouts]]}}.length + |vertexBufferCount| ≤
                            |this|.{{GPUObjectBase/[[device]]}}.{{设备/[[限制]]}}.{{支持的限制/maxBindGroupsPlusVertexBuffers}}，
                            其中 |vertexBufferCount| 是 |descriptor|.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}中值为 `未定义` 的最大索引。
                    </div>

                1. 将|descriptor|设置为|pipeline|.{{GPURenderPipeline/[[descriptor]]}}。
                1. 将|pipeline|.{{GPURenderPipeline/[[writesDepth]]}}设置为false。
                1. 将|pipeline|.{{GPURenderPipeline/[[writesStencil]]}}设置为false。
                1. 令|depthStencil|为|descriptor|.{{GPURenderPipelineDescriptor/depthStencil}}。
                1. 如果|depthStencil|不为null：
                    1. 将|pipeline|.{{GPURenderPipeline/[[writesDepth]]}}设置为|depthStencil|.{{GPUDepthStencilState/depthWriteEnabled}}。
                    1. 如果|depthStencil|.{{GPUDepthStencilState/stencilWriteMask}}不为 `0`：
                        1. 令|stencilFront|为|depthStencil|.{{GPUDepthStencilState/stencilFront}}。
                        1. 令|stencilBack|为|depthStencil|.{{GPUDepthStencilState/stencilBack}}。
                        1. 令|cullMode|为|descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/cullMode}}。
                        1. 如果 |cullMode| 不是 {{GPUCullMode/“front”}}，且 |stencilFront|.{{GPUStencilFaceState/passOp}}、 |stencilFront|.{{GPUStencilFaceState/depthFailOp}} 或 |stencilFront|.{{GPUStencilFaceState/failOp}} 中的任何一个不是 {{GPUStencilOperation/“keep”}}：
                            1. 将|pipeline|.{{GPURenderPipeline/[[writesStencil]]}}设置为true。
                        1. 如果 |cullMode| 不是 {{GPUCullMode/“back”}}，且 |stencilBack|.{{GPUStencilFaceState/passOp}}、 |stencilBack|.{{GPUStencilFaceState/depthFailOp}} 或 |stencilBack|.{{GPUStencilFaceState/failOp}} 中的任何一个不是 {{GPUStencilOperation/“keep”}}：
                            1. 将|pipeline|.{{GPURenderPipeline/[[writesStencil]]}}设置为true。
                1. 将|pipeline|.{{GPUPipelineBase/[[layout]]}}设置为|layout|。
            </div>

            问题：需要渲染状态的描述。
        </div>

    : <dfn>createRenderPipelineAsync(descriptor)</dfn>
    ::
        创建一个使用 [=异步管道创建=] 的 {{GPURenderPipeline}}。
        当创建的管道准备好使用且无需额外延迟时，返回的 {{Promise}} 将解析。


        如果管道创建失败，返回的 {{Promise}} 将以 {{GPUPipelineError}} 拒绝。

        注：只要可能，就优先使用此方法，因为它可以防止在管道编译上阻塞 [=队列时间线=] 工作。

        <div algorithm=GPUDevice.createRenderPipelineAsync>
            <div data-timeline=content>
                **Called on:** {{GPUDevice}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUDevice/createRenderPipelineAsync(descriptor)">
                    |descriptor|: Description of the {{GPURenderPipeline}} to create.
                </pre>

                **Returns:** {{Promise}}&lt;{{GPURenderPipeline}}&gt;

                [=内容时间线=] 步骤：

                1. 让 <var data-timeline=content>contentTimeline</var> 是当前的[=Content timeline=]。
                1. 让 |promise| 是一个[=新的 promise=]。
                1. 在 |this| 的 [=设备时间线=] 上发布 |initialization steps|。
                1. 返回 |promise|。
            </div>
            <div data-timeline=device>
                [=设备时间线=] |initialization steps|:

                1. 让 |pipeline| 成为一个新的{{GPURenderPipeline}}，就像调用 |this|.{{GPUDevice/createRenderPipeline()}} 并使用 |descriptor| 一样;

                1. 当 |pipeline| 准备好使用或者变为 [=无效=] 时，在 <var data-timeline=content>contentTimeline</var> 上发出后续步骤。
            </div>
            <div data-timeline=content>
                [=内容时间线=] 步骤：

                1. 如果 |pipeline| 为...
                    <dl class=switch>
                        : [=有效=]
                        :: 将 |pipeline| 作为结果解决 |promise|。
                        : [=无效=] due to an [$internal error$]
                        :: [=拒绝=] |promise| ，并使用{{GPUPipelineError}}，其中{{GPUPipelineErrorInit/reason}} 为{{GPUPipelineErrorReason/“internal”}}。
                        : [=无效=] due to an [$validation error$]
                        :: [=拒绝=] |promise|，并带有一个 {{GPUPipelineError}}，其 {{GPUPipelineErrorInit/reason}} 为 {{GPUPipelineErrorReason/“validation”}}。
                    </dl>
            </div>
        </div>
</dl>

<div algorithm data-timeline=device>
    <dfn abstract-op>validating GPURenderPipelineDescriptor</dfn>(descriptor, layout, device)

    **Arguments:**

    - {{GPURenderPipelineDescriptor}} |descriptor|
    - {{GPUPipelineLayout}} |layout|
    - {{GPUDevice}} |device|

    如果满足以下所有条件，则返回 true：


    - [$验证 GPUProgrammableStage$](GPUShaderStage/VERTEX)，使用 |descriptor|.GPURenderPipelineDescriptor/vertex 和 |layout|，操作成功。
    - [$验证 GPUVertexState$](|device|, |descriptor|.GPURenderPipelineDescriptor/vertex， |descriptor|.GPURenderPipelineDescriptor/vertex) 操作成功。
    - 如果提供了 |descriptor|.GPURenderPipelineDescriptor/fragment：
        - [$验证 GPUProgrammableStage$](GPUShaderStage/FRAGMENT)，使用 |descriptor|.GPURenderPipelineDescriptor/fragment 和 |layout|，操作成功。
        - [验证 GPUFragmentState](|device|, |descriptor|.GPURenderPipelineDescriptor/fragment) 操作成功。
        - 如果 [=builtin/sample_mask=] 是 |descriptor|.GPURenderPipelineDescriptor/fragment 的 [=shader stage output=]：
            - |descriptor|.GPURenderPipelineDescriptor/multisample.GPUMultisampleState/alphaToCoverageEnabled 的值为 `false`。
        - 如果 [=builtin/frag_depth=] 是 |descriptor|.GPURenderPipelineDescriptor/fragment 的 [=shader stage output=]：
            - 必须提供 |descriptor|.GPURenderPipelineDescriptor/depthStencil，并且 |descriptor|.GPURenderPipelineDescriptor/depthStencil.GPUDepthStencilState/format 必须具有一个 [=aspect/depth=] 层面。
    - [$验证 GPUPrimitiveState$](|descriptor|.GPURenderPipelineDescriptor/primitive, |device|) 操作成功。
    - 如果提供了 |descriptor|.GPURenderPipelineDescriptor/depthStencil：
        - [验证 GPUDepthStencilState](|descriptor|.GPURenderPipelineDescriptor/depthStencil) 操作成功。
    - [$验证 GPUMultisampleState$](|descriptor|.GPURenderPipelineDescriptor/multisample) 操作成功。
    - 如果 |descriptor|.GPURenderPipelineDescriptor/multisample.GPUMultisampleState/alphaToCoverageEnabled 的值为 `true`：
        1. 必须提供 |descriptor|.GPURenderPipelineDescriptor/fragment。
        1. |descriptor|.GPURenderPipelineDescriptor/fragment.GPUFragmentState/targets[0] 必须存在且非空。
        1. |descriptor|.GPURenderPipelineDescriptor/fragment.GPUFragmentState/targets[0].GPUColorTargetState/format 必须是具有 alpha 通道的 GPUTextureFormat。
    - 必须存在至少一个附件，如下所示：
        - |descriptor|.GPURenderPipelineDescriptor/fragment.GPUFragmentState/targets 中的非 `null` 值，或者
        - |descriptor|.GPURenderPipelineDescriptor/depthStencil。
    - [$验证 inter-stage interfaces$]（|device|，|descriptor|）返回 `真`。
</div>

<div algorithm>
    <dfn abstract-op>validating inter-stage interfaces</dfn>(|device|, |descriptor|)

    **Arguments:**

    - {{GPUDevice}} |device|
    - {{GPURenderPipelineDescriptor}} |descriptor|

    **Returns:** {{boolean}}

    1. 令 |maxVertexShaderOutputComponents| 为 |device|.limits.{{supported limits/maxInterStageShaderComponents}}.
        1. 如果 |descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/topology}} 为 {{GPUPrimitiveTopology/“point-list”}}：
            1. |maxVertexShaderOutputComponents| 减 1。
    1. 如果不满足以下任一要求，则返回 false：
        - |descriptor|.{{GPURenderPipelineDescriptor/vertex}} 的所有用户自定义输出的标量组件总数不能超过 |maxVertexShaderOutputComponents|。 （例如，f32 输出占用1个组件，vec3<f32> 输出占用3个组件。）
        - |descriptor|.{{GPURenderPipelineDescriptor/vertex}} 的每个用户自定义输出的 [=location=] 必须 小于 |device|.limits.{{supported limits/maxInterStageShaderVariables}}.
    1. 如果 |descriptor|.{{GPURenderPipelineDescriptor/fragment}} [=map/exist|存在=]：
        1. 令 |maxFragmentShaderInputComponents| 为 |device|.limits.{{supported limits/maxInterStageShaderComponents}}.
            1. 如果 front_facing [=builtin=] 是 |descriptor|.{{GPURenderPipelineDescriptor/fragment}} 的输入：
                1. |maxFragmentShaderInputComponents| 减 1。
            1. 如果 sample_index [=builtin=] 是 |descriptor|.{{GPURenderPipelineDescriptor/fragment}} 的输入：
                1. |maxFragmentShaderInputComponents| 减 1。
            1. 如果 sample_mask [=builtin=] 是 |descriptor|.{{GPURenderPipelineDescriptor/fragment}} 的输入：
                1. |maxFragmentShaderInputComponents| 减 1。
        1. 如果不满足以下任一要求，则返回 false：
            - |descriptor|.{{GPURenderPipelineDescriptor/fragment}} 的所有用户自定义输入的标量组件总数不能超过 |maxFragmentShaderInputComponents|。

            - 对于 |descriptor|.{{GPURenderPipelineDescriptor/fragment}} 的每个用户自定义输入，|descriptor|.{{GPURenderPipelineDescriptor/vertex}} 的用户自定义输出必须具有与输入相同的 [=location=]、类型和插值（[=interpolation=]）。

            注：仅顶点的管道可以在顶点阶段具有用户自定义输出； 它们的值将被丢弃。

        1. [=Assert=] |descriptor|.{{GPURenderPipelineDescriptor/fragment}} 的每个用户自定义输入的 [=location=] 小于 |device|.limits.{{supported limits/maxInterStageShaderVariables}} （由上述规则得到结果）
    1. 返回 `true`。
</div>

<div class=example>
    Creating a simple {{GPURenderPipeline}}:

    <pre highlight=js>
        const renderPipeline = gpuDevice.createRenderPipeline({
            layout: pipelineLayout,
            vertex: {
                module: shaderModule,
                entryPoint: 'vertexMain'
            },
            fragment: {
                module: shaderModule,
                entryPoint: 'fragmentMain',
                targets: [{
                    format: 'bgra8unorm',
                }],
            }
        });
    </pre>
</div>

### 原始状态 ### {#primitive-state}

<script type=idl>
dictionary GPUPrimitiveState {
    GPUPrimitiveTopology topology = "triangle-list";
    GPUIndexFormat stripIndexFormat;
    GPUFrontFace frontFace = "ccw";
    GPUCullMode cullMode = "none";

    // Requires "depth-clip-control" feature.
    boolean unclippedDepth = false;
};
</script>

{{GPUPrimitiveState}}具有以下成员，它们描述了{{GPURenderPipeline}}如何从其顶点输入构造和光栅化图元：

<dl dfn-type=dict-member dfn-for=GPUPrimitiveState>
    : <dfn>topology</dfn>
    ::
        要从顶点输入构造的图元类型。

    : <dfn>stripIndexFormat</dfn>
    ::
        对于具有条带拓扑的管道
        （{{GPUPrimitiveTopology/“line-strip”}} 或 {{GPUPrimitiveTopology/“triangle-strip”}}），
        这决定了索引缓冲格式和原始重启值
        ({{GPUIndexFormat/“uint16”}}/0xFFFF 或 {{GPUIndexFormat/“uint32”}}/0xFFFFFFFF)。
        不允许在具有非条带拓扑的管道上使用。


        注：某些实现需要知道原始重启值以编译管道状态对象。

        要将带有条带拓扑的管道与索引绘制调用一起使用
        （{{GPURenderCommandsMixin/drawIndexed()}} 或 {{GPURenderCommandsMixin/drawIndexedIndirect()}}），
        必须设置这个值，并且它必须与绘制调用使用的索引缓冲格式匹配
        （设置在 {{GPURenderCommandsMixin/setIndexBuffer()}} 中）。

        有关更多细节，请参阅[[#primitive-assembly]]。

    : <dfn>frontFace</dfn>
    ::
        定义哪些多边形被视为 [=front-facing=]。

    : <dfn>cullMode</dfn>
    ::
        定义将剔除哪个多边形方向（如果有）。

    : <dfn>unclippedDepth</dfn>
    ::
        如果为真，则表示 [=depth clipping=] 已禁用。

         需要启用 {{GPUFeatureName/"depth-clip-control"}} 功能。
</dl>

<div algorithm>
    <dfn abstract-op>validating GPUPrimitiveState</dfn>(|descriptor|, |device|)
        **Arguments:**

        - {{GPUPrimitiveState}} |descriptor|
        - {{GPUDevice}} |device|

        如果满足以下所有条件返回 `true`：

        - 如果 |descriptor| .{{GPUPrimitiveState/topology}} 不是
            {{GPUPrimitiveTopology/"line-strip"}} 或 {{GPUPrimitiveTopology/"triangle-strip"}}：
            - |descriptor| .{{GPUPrimitiveState/stripIndexFormat}} 不能是 [=map/exist|provided=]。
        - 如果 |descriptor| .{{GPUPrimitiveState/unclippedDepth}} 是 `true`：
            - {{GPUFeatureName/"depth-clip-control"}} 必须在 |device| 上已经 [=enabled for=]。
</div>

<script type=idl>
enum GPUPrimitiveTopology {
    "point-list",
    "line-list",
    "line-strip",
    "triangle-list",
    "triangle-strip"
};
</script>

{{GPUPrimitiveTopology}} 定义使用 {{GPURenderPipeline}} 进行的原始类型绘制调用。 有关更多详细信息，请参见 [[#rasterization]]：

<dl dfn-type=enum-value dfn-for=GPUPrimitiveTopology>
    : <dfn>"point-list"</dfn>
    ::
        每个顶点定义一个点基元。

    : <dfn>"line-list"</dfn>
    ::
        每对连续的两个顶点定义一个线基元。

    : <dfn>"line-strip"</dfn>
    ::
        每对连续的两个顶点定义一个线图元。第一个顶点之后的每个顶点定义它和前一个顶点之间的线图元。

    : <dfn>"triangle-list"</dfn>
    ::
        三个顶点的每个连续三元组定义一个三角形基元。

    : <dfn>"triangle-strip"</dfn>
    ::
        前两个顶点之后的每个顶点在它和前两个顶点之间定义一个三角形基元。
</dl>

<script type=idl>
enum GPUFrontFace {
    "ccw",
    "cw"
};
</script>

{{GPUFrontFace}} 定义哪些多边形被 {{GPURenderPipeline}} 视为 [=front-facing=]。
有关更多详细信息，请参见 [[#polygon-rasterization]]：

<dl dfn-type=enum-value dfn-for=GPUFrontFace>
    : <dfn>"ccw"</dfn>
    ::
        顶点的帧缓冲区坐标按逆时针顺序给出的多边形被认为是 [=front-facing=]。

    : <dfn>"cw"</dfn>
    ::
        顶点的帧缓冲区坐标按顺时针顺序给出的多边形被认为是 [=front-facing=]。
</dl>

<script type=idl>
enum GPUCullMode {
    "none",
    "front",
    "back"
};
</script>

{{GPUPrimitiveTopology}} 定义哪些多边形将被使用 {{GPURenderPipeline}} 进行的绘制调用剔除。 有关更多详细信息，请参见 [[#polygon-rasterization]]：

<dl dfn-type=enum-value dfn-for=GPUCullMode>
    : <dfn>"none"</dfn>
    ::
        没有多边形被丢弃。

    : <dfn>"front"</dfn>
    ::
        [=Front-facing=] 多边形被丢弃。

    : <dfn>"back"</dfn>
    ::
        [=Back-facing=] 多边形被丢弃。
</dl>

注：{{GPUFrontFace}} 和 {{GPUCullMode}} 对 {{GPUPrimitiveTopology/"point-list"}}、{{GPUPrimitiveTopology/"line-list"}} 或 {{GPUPrimitiveTopology/"line-strip"}} 拓扑没有影响。

### 多样本状态 ### {#multisample-state}

<script type=idl>
dictionary GPUMultisampleState {
    GPUSize32 count = 1;
    GPUSampleMask mask = 0xFFFFFFFF;
    boolean alphaToCoverageEnabled = false;
};
</script>

{{GPUMultisampleState}}具有以下成员，这些成员描述了{{GPURenderPipeline}}如何与渲染传递的多重采样附件进行交互。

<dl dfn-type=dict-member dfn-for=GPUMultisampleState>
    : <dfn>count</dfn>
    ::
        每像素的样本数量。这个 {{GPURenderPipeline}} 只与具有匹配 {{GPUTextureDescriptor/sampleCount}} 的附件纹理（{{GPURenderPassDescriptor/colorAttachments}} 和 {{GPURenderPassDescriptor/depthStencilAttachment}}）兼容。

    : <dfn>mask</dfn>
    ::
        掩码确定要写入的样本。

    : <dfn>alphaToCoverageEnabled</dfn>
    ::
        当 `true` 表示应使用片段的 alpha 通道生成样本覆盖遮罩。
</dl>

<div algorithm>
    <dfn abstract-op>validating GPUMultisampleState</dfn>(|descriptor|)
        **Arguments:**

        - {{GPUMultisampleState}} |descriptor|

        如果满足以下所有条件，则返回 `true`：
            - 如果 |descriptor|.{{GPUMultisampleState/alphaToCoverageEnabled}} 为 `true`:
                - |descriptor|.{{GPUMultisampleState/count}} &gt; 1.
</div>

### 片元状态 ### {#fragment-state}

<script type=idl>
dictionary GPUFragmentState
         : GPUProgrammableStage {
    required sequence<GPUColorTargetState?> targets;
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUFragmentState</dfn>({{GPUDevice}} |device|, {{GPUFragmentState}} |descriptor|)

    如果满足以下所有要求，则返回 `true`：


    - |descriptor|.{{GPUFragmentState/targets}}.length 必须 &le； |device|.{{device/[[limits]]}}.{{supported limits/maxColorAttachments}}。
    - [=list/对于每一个=] |descriptor|.{{GPUFragmentState/targets}} 的 [=list/indices=] 的 |index| 包含非空值 |colorState|：
        - |colorState|.{{GPUColorTargetState/format}} 必须在 [[#plain-color-formats]] 中列出 具有 {{GPUTextureUsage/RENDER_ATTACHMENT}} 功能。

        - 如果 |colorState|.{{GPUColorTargetState/blend}} 是 [=map/exist|provided=] 的：

            - |colorState|.{{GPUColorTargetState/format}} 必须是 [=blendable=]。
            - |colorState|.{{GPUColorTargetState/blend}}.{{GPUBlendState/color}} 必须是一个 [=valid GPUBlendComponent=]。
            - |colorState|.{{GPUColorTargetState/blend}}.{{GPUBlendState/alpha}} 必须是一个 [=valid GPUBlendComponent=]。
        - |colorState|.{{GPUColorTargetState/writeMask}} 必须 < 16。

        - 如果 |descriptor|.{{GPUProgrammableStage/entryPoint}} 具有 [=location=] 属性 等于 |index| 的 [=shader stage output=] 值 |output|：

            - 对于 |colorState|.{{GPUColorTargetState/format}} 中的每个组件，必须在 |output| 中有一个 对应的组件。 (即，RGBA 需要 vec4，RGB 需要 vec3 或 vec4，RG 需要 vec2 或 vec3 或 vec4。)
            - 如果 |colorState|.{{GPUColorTargetState/blend}} 是 [=map/exist|provided=] 的 |colorState|.{{GPUColorTargetState/blend}}.{{GPUBlendState/color}}.{{GPUBlendComponent/srcFactor}} 或 .{{GPUBlendComponent/dstFactor}} 使用源 alpha (是 {{GPUBlendFactor/“src-alpha”}} 的任何一个， 或 {{GPUBlendFactor/“one-minus-src-alpha”}}, 或 {{GPUBlendFactor/“src-alpha-saturated”}})，那么：
                - |output| 必须具有 alpha 通道 (即，它必须是一个 vec4)。
                    否则，因为没有 shader 输出用于 attachment：

            - |colorState|.{{GPUColorTargetState/writeMask}} 必须为 0。
    - 在 |device| 和 |descriptor|.{{GPUFragmentState/targets}} 上执行 [$Validating GPUFragmentState’s color attachment bytes per sample$] 成功。
</div>

<div algorithm>
    <dfn abstract-op>Validating GPUFragmentState's color attachment bytes per sample</dfn>({{GPUDevice}} |device|, [=sequence=]&lt;{{GPUColorTargetState}}?&gt; |targets|)

    1. 让 |formats| 成为空的 [=list=]<{{GPUTextureFormat}}?>
    1. 对于 |targets| 中的每个 |target|: 
        1. 如果 |target| 为 undefined，则继续。
        1. 将 |target|.{{GPUColorTargetState/format}} [=list/追加=] 到 |formats|。
    1. [$计算每个采样的颜色附件字节数$] 必须 &le; |device|.{{device/[[limits]]}}.{{supported limits/maxColorAttachmentBytesPerSample}}。
</div>

Note:
注：
片元着色器输出的值可能比管线使用的值多。如果出现这种情况，多余的值将被忽略。

<div algorithm>
    如果满足以下要求，|component| 就是一个 <dfn>有效的 GPUBlendComponent</dfn>：


    - 如果 |component|.{{GPUBlendComponent/operation}} 是 {{GPUBlendOperation/“min”}} 或 {{GPUBlendOperation/“max”}}：
        - |component|.{{GPUBlendComponent/srcFactor}} 和 |component|.{{GPUBlendComponent/dstFactor}} 必须都是 {{GPUBlendFactor/“one”}}。
</div>

### 颜色目标状态 ### {#color-target-state}

<script type=idl>
dictionary GPUColorTargetState {
    required GPUTextureFormat format;

    GPUBlendState blend;
    GPUColorWriteFlags writeMask = 0xF;  // GPUColorWrite.ALL
};
</script>

<script type=idl>
dictionary GPUBlendState {
    required GPUBlendComponent color;
    required GPUBlendComponent alpha;
};
</script>

<script type=idl>
typedef [EnforceRange] unsigned long GPUColorWriteFlags;
[Exposed=(Window, DedicatedWorker), SecureContext]
namespace GPUColorWrite {
    const GPUFlagsConstant RED   = 0x1;
    const GPUFlagsConstant GREEN = 0x2;
    const GPUFlagsConstant BLUE  = 0x4;
    const GPUFlagsConstant ALPHA = 0x8;
    const GPUFlagsConstant ALL   = 0xF;
};
</script>

#### 混合状态 #### {#blend-state}

<script type=idl>
dictionary GPUBlendComponent {
    GPUBlendOperation operation = "add";
    GPUBlendFactor srcFactor = "one";
    GPUBlendFactor dstFactor = "zero";
};
</script>

{{GPUBlendComponent}} 有以下成员，它们描述了片段的颜色或 alpha 分量是如何混合的：

<dl dfn-type=dict-member dfn-for=GPUBlendComponent>
    : <dfn>operation</dfn>
    ::
        定义用于计算写入目标附件组件的值的 {{GPUBlendOperation}}。

    : <dfn>srcFactor</dfn>
    ::
        定义要对来自片段着色器的值执行的 {{GPUBlendFactor}} 操作。

    : <dfn>dstFactor</dfn>
    ::
        定义要对目标附件中的值执行的 {{GPUBlendFactor}} 操作。
</dl>

下表使用此表示法来描述给定片段位置的颜色分量：
<table class=data>
    <tbody>
        <tr>
            <td><b><code>RGBA<sub>src</src></code></b>
            <td>Color output by the fragment shader for the color attachment.
                如果着色器不返回 alpha 通道，则不能使用 src-alpha 混合因子。
        <tr>
            <td><b><code>RGBA<sub>dst</src></code></b>
            <td>Color currently in the color attachment.
                缺少绿色/蓝色/alpha 通道分别默认为“0、0、1”。
        <tr>
            <td><b><code>RGBA<sub>const</src></code></b>
            <td>当前 {{RenderState/[[blendConstant]]}}.
        <tr>
            <td><b><code>RGBA<sub>srcFactor</src></code></b>
            <td>源混合因子组件，由 {{GPUBlendComponent/srcFactor}} 定义。
        <tr>
            <td><b><code>RGBA<sub>dstFactor</src></code></b>
            <td>目标混合因子组件，由 {{GPUBlendComponent/dstFactor}} 定义。
    </tbody>
</table>

<script type=idl>
enum GPUBlendFactor {
    "zero",
    "one",
    "src",
    "one-minus-src",
    "src-alpha",
    "one-minus-src-alpha",
    "dst",
    "one-minus-dst",
    "dst-alpha",
    "one-minus-dst-alpha",
    "src-alpha-saturated",
    "constant",
    "one-minus-constant"
};
</script>

{{GPUBlendFactor}} 定义了源或目标混合因子的计算方法：

<table class=data>
    <thead>
        <tr>
            <th>GPUBlendFactor
            <th>Blend factor RGBA components
        </tr>
    </thead>
    <tbody dfn-type=enum-value dfn-for=GPUBlendFactor>
        <tr>
            <td><dfn>"zero"</dfn>
            <td><code>(0, 0, 0, 0)</code>
        <tr>
            <td><dfn>"one"</dfn>
            <td><code>(1, 1, 1, 1)</code>
        <tr>
            <td><dfn>"src"</dfn>
            <td><code>(R<sub>src</sub>, G<sub>src</sub>, B<sub>src</sub>, A<sub>src</sub>)</code>
        <tr>
            <td><dfn>"one-minus-src"</dfn>
            <td><code>(1 - R<sub>src</sub>, 1 - G<sub>src</sub>, 1 - B<sub>src</sub>, 1 - A<sub>src</sub>)</code>
        <tr>
            <td><dfn>"src-alpha"</dfn>
            <td><code>(A<sub>src</sub>, A<sub>src</sub>, A<sub>src</sub>, A<sub>src</sub>)</code>
        <tr>
            <td><dfn>"one-minus-src-alpha"</dfn>
            <td><code>(1 - A<sub>src</sub>, 1 - A<sub>src</sub>, 1 - A<sub>src</sub>, 1 - A<sub>src</sub>)</code>
        <tr>
            <td><dfn>"dst"</dfn>
            <td><code>(R<sub>dst</sub>, G<sub>dst</sub>, B<sub>dst</sub>, A<sub>dst</sub>)</code>
        <tr>
            <td><dfn>"one-minus-dst"</dfn>
            <td><code>(1 - R<sub>dst</sub>, 1 - G<sub>dst</sub>, 1 - B<sub>dst</sub>, 1 - A<sub>dst</sub>)</code>
        <tr>
            <td><dfn>"dst-alpha"</dfn>
            <td><code>(A<sub>dst</sub>, A<sub>dst</sub>, A<sub>dst</sub>, A<sub>dst</sub>)</code>
        <tr>
            <td><dfn>"one-minus-dst-alpha"</dfn>
            <td><code>(1 - A<sub>dst</sub>, 1 - A<sub>dst</sub>, 1 - A<sub>dst</sub>, 1 - A<sub>dst</sub>)</code>
        <tr>
            <td><dfn>"src-alpha-saturated"</dfn>
            <td><code>(min(A<sub>src</sub>, 1 - A<sub>dst</sub>), min(A<sub>src</sub>, 1 - A<sub>dst</sub>), min(A<sub>src</sub>, 1 - A<sub>dst</sub>), 1)</code>
        <tr>
            <td><dfn>"constant"</dfn>
            <td><code>(R<sub>const</sub>, G<sub>const</sub>, B<sub>const</sub>, A<sub>const</sub>)</code>
        <tr>
            <td><dfn>"one-minus-constant"</dfn>
            <td><code>(1 - R<sub>const</sub>, 1 - G<sub>const</sub>, 1 - B<sub>const</sub>, 1 - A<sub>const</sub>)</code>
    </tbody>
</table>

<script type=idl>
enum GPUBlendOperation {
    "add",
    "subtract",
    "reverse-subtract",
    "min",
    "max"
};
</script>

{{GPUBlendOperation}} 定义用于组合源和目标混合因子的算法：

<table class=data>
    <thead>
        <tr>
            <th>GPUBlendOperation
            <th>RGBA Components
        </tr>
    </thead>
    <tbody dfn-type=enum-value dfn-for=GPUBlendOperation>
        <tr>
            <td><dfn>"add"</dfn>
            <td><code>RGBA<sub>src</sub> &times; RGBA<sub>srcFactor</sub> + RGBA<sub>dst</sub> &times; RGBA<sub>dstFactor</sub></code>
        <tr>
            <td><dfn>"subtract"</dfn>
            <td><code>RGBA<sub>src</sub> &times; RGBA<sub>srcFactor</sub> - RGBA<sub>dst</sub> &times; RGBA<sub>dstFactor</sub></code>
        <tr>
            <td><dfn>"reverse-subtract"</dfn>
            <td><code>RGBA<sub>dst</sub> &times; RGBA<sub>dstFactor</sub> - RGBA<sub>src</sub> &times; RGBA<sub>srcFactor</sub></code>
        <tr>
            <td><dfn>"min"</dfn>
            <td><code>min(RGBA<sub>src</sub>, RGBA<sub>dst</sub>)</code>
        <tr>
            <td><dfn>"max"</dfn>
            <td><code>max(RGBA<sub>src</sub>, RGBA<sub>dst</sub>)</code>
    </tbody>
</table>

### 深度/模板状态 ### {#depth-stencil-state}

<script type=idl>
dictionary GPUDepthStencilState {
    required GPUTextureFormat format;

    required boolean depthWriteEnabled;
    required GPUCompareFunction depthCompare;

    GPUStencilFaceState stencilFront = {};
    GPUStencilFaceState stencilBack = {};

    GPUStencilValue stencilReadMask = 0xFFFFFFFF;
    GPUStencilValue stencilWriteMask = 0xFFFFFFFF;

    GPUDepthBias depthBias = 0;
    float depthBiasSlopeScale = 0;
    float depthBiasClamp = 0;
};
</script>

{{GPUDepthStencilState}} 具有以下成员，描述了 {{GPURenderPipeline}} 将如何影响渲染过程的 {{GPURenderPassDescriptor/depthStencilAttachment}}：

<dl dfn-type=dict-member dfn-for=GPUDepthStencilState>
    : <dfn>format</dfn>
    ::
        此 {{GPURenderPipeline}} 将与 {{GPURenderPassDescriptor/depthStencilAttachment}} 的 {{GPUTextureViewDescriptor/format}} 兼容。

    : <dfn>depthWriteEnabled</dfn>
    ::
        指示这个 {{GPURenderPipeline}} 是否可以修改 {{GPURenderPassDescriptor/depthStencilAttachment}} 深度值。

    : <dfn>depthCompare</dfn>
    ::
        用于测试片元深度与 {{GPURenderPassDescriptor/depthStencilAttachment}} 深度值的比较操作。

    : <dfn>stencilFront</dfn>
    ::
        定义了如何为朝前的图元执行模板比较和操作。

    : <dfn>stencilBack</dfn>
    ::
        定义了如何为朝后的图元执行模板比较和操作。

    : <dfn>stencilReadMask</dfn>
    ::
        掩码控制在执行模板比较测试时读取哪些 {{GPURenderPassDescriptor/depthStencilAttachment}} 模板值位。

    : <dfn>stencilWriteMask</dfn>
    ::
        Bitmask controlling which {{GPURenderPassDescriptor/depthStencilAttachment}} stencil value
        bits are written to when performing stencil operations.

    : <dfn>depthBias</dfn>
    ::
        添加到每个片元的恒定深度偏差。有关详细信息，请参阅 [$biased fragment depth$]。

    : <dfn>depthBiasSlopeScale</dfn>
    ::
        与片元的斜率成比例的深度偏差。有关详细信息，请参阅 [$biased fragment depth$]。

    : <dfn>depthBiasClamp</dfn>
    ::
        片元的最大深度偏差。有关详细信息，请参阅 [$biased fragment depth$]。
</dl>

<div algorithm>
    对于正在写入至 {{GPURenderPassDescriptor/depthStencilAttachment}} |附件| 的片段，当使用 {{GPUDepthStencilState}} |状态| 绘制时，<dfn abstract-op>biased fragment depth</dfn> 的计算过程为：


    1. 设 |format| 为 |attachment|.{{GPURenderPassDepthStencilAttachment/view}}.{{GPUTextureViewDescriptor/format}}。
    1. 设 |r| 为在转换为32位浮点值时 |格式| 中最小的正可表示值（大于 0）。
    1. 设 |maxDepthSlope| 为片段深度值的水平和垂直斜率中的最大值。
    1. 如果 |format| 是 unorm 格式：
        1. 设 |bias| 为 <code>(float)|状态|.{{GPUDepthStencilState/depthBias}} * |r| + |state|.{{GPUDepthStencilState/depthBiasSlopeScale}} * |maxDepthSlope|</code>.
    1. 否则，如果 |format| 是一个 float 格式：
        1. 设 |bias| 为 <code>(float)|状态|.{{GPUDepthStencilState/depthBias}} * 2^(exp(原始最大深度) - |r|) + |state|.{{GPUDepthStencilState/depthBiasSlopeScale}} * |maxDepthSlope|</code>。
    1. 如果 |state|.{{GPUDepthStencilState/depthBiasClamp}} &gt; 0：
        1. 将 |bias| 设置为 <code>min(|状态|.{{GPUDepthStencilState/depthBiasClamp}}, |bias|)</code>。
    1. 否则，如果 |state|.{{GPUDepthStencilState/depthBiasClamp}} &lt; 0：
        1. 将 |bias| 设置为 <code>max(|状态|.{{GPUDepthStencilState/depthBiasClamp}}, |bias|)</code>。
    1. 如果 |state|.{{GPUDepthStencilState/depthBias}} &ne; 0 或者 |state|.{{GPUDepthStencilState/depthBiasSlopeScale}} &ne; 0：
        1. 将片元深度值设置为 <code>片段深度值 + |bias|</code>
</div>

<div algorithm>
    <dfn abstract-op>validating GPUDepthStencilState</dfn>(|descriptor|)

    **Arguments:**

    - {{GPUDepthStencilState}} |descriptor|

    只有当满足以下所有条件时，返回 `true`：


    - |descriptor|.{{GPUDepthStencilState/format}} 是一个 [=depth-or-stencil format=].
    - 如果 |descriptor|.{{GPUDepthStencilState/depthWriteEnabled}} 是 `true` 或者 |descriptor|.{{GPUDepthStencilState/depthCompare}} 不是 {{GPUCompareFunction/"always"}}：
        - |descriptor|.{{GPUDepthStencilState/format}} 必须要有一个 depth 分量。
    - 如果 |descriptor|.{{GPUDepthStencilState/stencilFront}} 或者 |descriptor|.{{GPUDepthStencilState/stencilBack}} 不是默认值：
        - |descriptor|.{{GPUDepthStencilState/format}} 必须要有一个 stencil 分量。

    问题：这个算法可以如何支持在扩展中添加的 depth/stencil 格式？
</div>

<script type=idl>
dictionary GPUStencilFaceState {
    GPUCompareFunction compare = "always";
    GPUStencilOperation failOp = "keep";
    GPUStencilOperation depthFailOp = "keep";
    GPUStencilOperation passOp = "keep";
};
</script>

{{GPUStencilFaceState}}具有以下成员，它们描述了模板比较和操作是如何执行的：

<dl dfn-type=dict-member dfn-for=GPUStencilFaceState>
    : <dfn>compare</dfn>
    ::
        在测试片元与 {{GPURenderPassDescriptor/depthStencilAttachment}} 模板值时使用的 {{GPUCompareFunction}}。

    : <dfn>failOp</dfn>
    ::
        如果片元模板比较测试（由 {{GPUStencilFaceState/compare}} 描述）失败，则执行的 {{GPUStencilOperation}}。

    : <dfn>depthFailOp</dfn>
    ::
        如果由 {{GPUDepthStencilState/depthCompare}} 描述的片元深度比较失败，则执行的 {{GPUStencilOperation}}。

    : <dfn>passOp</dfn>
    ::
        如果片元模板比较测试通过，则执行由{{GPUStencilFaceState/compare}}描述的{{GPUStencilOperation}}。
</dl>

<script type=idl>
enum GPUStencilOperation {
    "keep",
    "zero",
    "replace",
    "invert",
    "increment-clamp",
    "decrement-clamp",
    "increment-wrap",
    "decrement-wrap"
};
</script>

{{GPUStencilOperation}} 定义了以下操作：

<dl dfn-type=enum-value dfn-for=GPUStencilOperation>
    : <dfn>"keep"</dfn>
    ::
        保持当前模板值。

    : <dfn>"zero"</dfn>
    ::
        将模板值设置为“0”。

    : <dfn>"replace"</dfn>
    ::
        将模板值设置为 {{RenderState/[[stencilReference]]}}。

    : <dfn>"invert"</dfn>
    ::
        按位反转当前模板值。

    : <dfn>"increment-clamp"</dfn>
    ::
        增加当前模板值，限制为 {{GPURenderPassDescriptor/depthStencilAttachment}} 模板方面的最大可表示值。

    : <dfn>"decrement-clamp"</dfn>
    ::
        减少当前模板值，钳位到 `0`。

    : <dfn>"increment-wrap"</dfn>
    ::
        将当前模板值递增，如果该值超过了 {{GPURenderPassDescriptor/depthStencilAttachment}} 的模板方面可以表示的最大值，则将其回绕至零。

    : <dfn>"decrement-wrap"</dfn>
    ::
        将当前模板值递减，如果该值低于 `0` 则回绕到{{GPURenderPassDescriptor/depthStencilAttachment}}的模板方面的最大可表示值。
</dl>

### 顶点状态 ### {#vertex-state}

<script type=idl>
enum GPUIndexFormat {
    "uint16",
    "uint32"
};
</script>

索引格式决定了缓冲区中索引值的数据类型，以及在带strip原语拓扑结构 ({{GPUPrimitiveTopology/“line-strip”}} 或 {{GPUPrimitiveTopology/“triangle-strip”}}) 中使用时指定原语重启值。<dfn dfn>原语重启值</dfn>指示哪个索引值表示应开始新的原语，而不是继续使用之前索引的顶点构建三角形条带。

指定strip原语拓扑结构的{{GPUPrimitiveState}}必须在用于索引绘制时指定{{GPUPrimitiveState/stripIndexFormat}}，以便在管道创建时知道将用于重启的[=primitive restart value=]。指定列表原语拓扑结构的{{GPUPrimitiveState}}将在进行索引渲染时使用传递给 {{GPURenderCommandsMixin/setIndexBuffer()}} 的索引格式。

<table class=data>
    <thead>
        <tr>
            <th>Index format
            <th>Byte size
            <th>Primitive restart value
    </thead>
    <tbody dfn-type=enum-value dfn-for=GPUIndexFormat>
        <tr>
            <td><dfn>"uint16"</dfn>
            <td>2
            <td>0xFFFF
        <tr>
            <td><dfn>"uint32"</dfn>
            <td>4
            <td>0xFFFFFFFF
    </tbody>
</table>

#### 顶点格式 #### {#vertex-formats}

顶点属性的{{GPUVertexFormat}}指示如何从顶点缓冲区解释数据并将其暴露给着色器。格式名称指定组件的顺序，每个组件的位数以及组件的[=顶点数据类型=]。


每个<dfn dfn>顶点数据类型</dfn>都可以映射到具有相同基本类型的任何[=WGSL标量类型=]，而无论组件的位数如何：

<table class=data>
    <thead>
        <tr>
            <th>Vertex format prefix
            <th>Vertex data type
            <th>Compatible WGSL types
    </thead>
    <tbody>
        <tr>
            <td>`uint`
            <td>unsigned int
            <td>`u32`
        <tr>
            <td>`sint`
            <td>signed int
            <td>`i32`
        <tr>
            <td>`unorm`
            <td>unsigned normalized
            <td rowspan=3>`f16`, `f32`
        <tr>
            <td>`snorm`
            <td>signed normalized
        <tr>
            <td>`float`
            <td>floating point
    </tbody>
</table>

多组件格式在“x”后指定组件的数量。顶点格式和着色器类型之间的组件数量不匹配是允许的，通过丢弃组件或填充默认值来进行补偿。

<div class=example>
   顶点属性具有{{GPUVertexFormat/“unorm8x2”}}格式和字节值 `[0x7F, 0xFF]`，可以通过以下类型在着色器中访问：

    <table class=data>
        <thead>
            <tr>
                <th>Shader type
                <th>Shader value
        </thead>
        <tbody>
            <tr>
                <td><code>f16</code>
                <td><code>0.5h</code>
            <tr>
                <td><code>f32</code>
                <td><code>0.5f</code>
            <tr>
                <td><code>vec2&lt;f16&gt;</code>
                <td><code>vec2(0.5h, 1.0h)</code>
            <tr>
                <td><code>vec2&lt;f32&gt;</code>
                <td><code>vec2(0.5f, 1.0f)</code>
            <tr>
                <td><code>vec3&lt;f16&gt;</code>
                <td><code>vec2(0.5h, 1.0h, 0.0h)</code>
            <tr>
                <td><code>vec3&lt;f32&gt;</code>
                <td><code>vec2(0.5f, 1.0f, 0.0f)</code>
            <tr>
                <td><code>vec4&lt;f16&gt;</code>
                <td><code>vec2(0.5h, 1.0h, 0.0h, 1.0h)</code>
            <tr>
                <td><code>vec4&lt;f32&gt;</code>
                <td><code>vec2(0.5f, 1.0f, 0.0f, 1.0f)</code>
        </tbody>
    </table>
</div>

请参阅[[#vertex-processing]]以获取关于如何在着色器中显示顶点格式的更多信息。

<script type=idl>
enum GPUVertexFormat {
    "uint8x2",
    "uint8x4",
    "sint8x2",
    "sint8x4",
    "unorm8x2",
    "unorm8x4",
    "snorm8x2",
    "snorm8x4",
    "uint16x2",
    "uint16x4",
    "sint16x2",
    "sint16x4",
    "unorm16x2",
    "unorm16x4",
    "snorm16x2",
    "snorm16x4",
    "float16x2",
    "float16x4",
    "float32",
    "float32x2",
    "float32x3",
    "float32x4",
    "uint32",
    "uint32x2",
    "uint32x3",
    "uint32x4",
    "sint32",
    "sint32x2",
    "sint32x3",
    "sint32x4"
};
</script>

<table class=data>
    <thead>
        <tr>
            <th>Vertex format
            <th>Data type
            <th>Components
            <th>Byte size
            <th>Example WGSL type
    </thead>
    <tbody dfn-type=enum-value dfn-for=GPUVertexFormat>
        <tr>
            <td><dfn>"uint8x2"</dfn>
            <td>unsigned int
            <td>2
            <td>2
            <td><code>vec2&lt;u32&gt;</code>
        <tr>
            <td><dfn>"uint8x4"</dfn>
            <td>unsigned int
            <td>4
            <td>4
            <td><code>vec4&lt;u32&gt;</code>
        <tr>
            <td><dfn>"sint8x2"</dfn>
            <td>signed int
            <td>2
            <td>2
            <td><code>vec2&lt;i32&gt;</code>
        <tr>
            <td><dfn>"sint8x4"</dfn>
            <td>signed int
            <td>4
            <td>4
            <td><code>vec4&lt;i32&gt;</code>
        <tr>
            <td><dfn>"unorm8x2"</dfn>
            <td>unsigned normalized
            <td>2
            <td>2
            <td><code>vec2&lt;f32&gt;</code>
        <tr>
            <td><dfn>"unorm8x4"</dfn>
            <td>unsigned normalized
            <td>4
            <td>4
            <td><code>vec4&lt;f32&gt;</code>
        <tr>
            <td><dfn>"snorm8x2"</dfn>
            <td>signed normalized
            <td>2
            <td>2
            <td><code>vec2&lt;f32&gt;</code>
        <tr>
            <td><dfn>"snorm8x4"</dfn>
            <td>signed normalized
            <td>4
            <td>4
            <td><code>vec4&lt;f32&gt;</code>
        <tr>
            <td><dfn>"uint16x2"</dfn>
            <td>unsigned int
            <td>2
            <td>4
            <td><code>vec2&lt;u32&gt;</code>
        <tr>
            <td><dfn>"uint16x4"</dfn>
            <td>unsigned int
            <td>4
            <td>8
            <td><code>vec4&lt;u32&gt;</code>
        <tr>
            <td><dfn>"sint16x2"</dfn>
            <td>signed int
            <td>2
            <td>4
            <td><code>vec2&lt;i32&gt;</code>
        <tr>
            <td><dfn>"sint16x4"</dfn>
            <td>signed int
            <td>4
            <td>8
            <td><code>vec4&lt;i32&gt;</code>
        <tr>
            <td><dfn>"unorm16x2"</dfn>
            <td>unsigned normalized
            <td>2
            <td>4
            <td><code>vec2&lt;f32&gt;</code>
        <tr>
            <td><dfn>"unorm16x4"</dfn>
            <td>unsigned normalized
            <td>4
            <td>8
            <td><code>vec4&lt;f32&gt;</code>
        <tr>
            <td><dfn>"snorm16x2"</dfn>
            <td>signed normalized
            <td>2
            <td>4
            <td><code>vec2&lt;f32&gt;</code>
        <tr>
            <td><dfn>"snorm16x4"</dfn>
            <td>signed normalized
            <td>4
            <td>8
            <td><code>vec4&lt;f32&gt;</code>
        <tr>
            <td><dfn>"float16x2"</dfn>
            <td>float
            <td>2
            <td>4
            <td><code>vec2&lt;f16&gt;</code>
        <tr>
            <td><dfn>"float16x4"</dfn>
            <td>float
            <td>4
            <td>8
            <td><code>vec4&lt;f16&gt;</code>
        <tr>
            <td><dfn>"float32"</dfn>
            <td>float
            <td>1
            <td>4
            <td><code>f32</code>
        <tr>
            <td><dfn>"float32x2"</dfn>
            <td>float
            <td>2
            <td>8
            <td><code>vec2&lt;f32&gt;</code>
        <tr>
            <td><dfn>"float32x3"</dfn>
            <td>float
            <td>3
            <td>12
            <td><code>vec3&lt;f32&gt;</code>
        <tr>
            <td><dfn>"float32x4"</dfn>
            <td>float
            <td>4
            <td>16
            <td><code>vec4&lt;f32&gt;</code>
        <tr>
            <td><dfn>"uint32"</dfn>
            <td>unsigned int
            <td>1
            <td>4
            <td><code>u32</code>
        <tr>
            <td><dfn>"uint32x2"</dfn>
            <td>unsigned int
            <td>2
            <td>8
            <td><code>vec2&lt;u32&gt;</code>
        <tr>
            <td><dfn>"uint32x3"</dfn>
            <td>unsigned int
            <td>3
            <td>12
            <td><code>vec3&lt;u32&gt;</code>
        <tr>
            <td><dfn>"uint32x4"</dfn>
            <td>unsigned int
            <td>4
            <td>16
            <td><code>vec4&lt;u32&gt;</code>
        <tr>
            <td><dfn>"sint32"</dfn>
            <td>signed int
            <td>1
            <td>4
            <td><code>i32</code>
        <tr>
            <td><dfn>"sint32x2"</dfn>
            <td>signed int
            <td>2
            <td>8
            <td><code>vec2&lt;i32&gt;</code>
        <tr>
            <td><dfn>"sint32x3"</dfn>
            <td>signed int
            <td>3
            <td>12
            <td><code>vec3&lt;i32&gt;</code>
        <tr>
            <td><dfn>"sint32x4"</dfn>
            <td>signed int
            <td>4
            <td>16
            <td><code>vec4&lt;i32&gt;</code>
    </tbody>
</table>

<script type=idl>
enum GPUVertexStepMode {
    "vertex",
    "instance"
};
</script>

步进模式配置如何基于当前顶点或实例索引计算顶点缓冲数据的地址：

<dl dfn-type=enum-value dfn-for=GPUVertexStepMode>
    : <dfn>"vertex"</dfn>
    ::
        地址根据每个顶点的{{GPUVertexBufferLayout/arrayStride}}进行递增，并在实例之间重置。

    : <dfn>"instance"</dfn>
    ::
        地址对于每个实例会根据{{GPUVertexBufferLayout/arrayStride}}进行增加。
</dl>

<script type=idl>
dictionary GPUVertexState
         : GPUProgrammableStage {
    sequence<GPUVertexBufferLayout?> buffers = [];
};
</script>

一个<dfn dfn noexport>顶点缓冲区</dfn>在概念上是一个缓冲区内存的视图，作为一个结构数组。
{{GPUVertexBufferLayout/arrayStride}} 是该数组元素之间的字节跨度。
顶点缓冲区的每个元素都类似于一个具有由其 {{GPUVertexBufferLayout/attributes}} 定义的内存布局的结构，该布局描述结构的元素。

每个 {{GPUVertexAttribute}} 都描述了其 {{GPUVertexAttribute/format}} 以及其在结构中的 {{GPUVertexAttribute/offset}}，按字节为单位。

每个属性在顶点着色器中都作为单独的输入，每个输入都由数字 location 绑定，location 由 {{GPUVertexAttribute/shaderLocation}} 指定。
{{GPUVertexState}} 中的每个 location 都必须是唯一的。

<script type=idl>
dictionary GPUVertexBufferLayout {
    required GPUSize64 arrayStride;
    GPUVertexStepMode stepMode = "vertex";
    required sequence<GPUVertexAttribute> attributes;
};
</script>

<dl dfn-type=dict-member dfn-for=GPUVertexBufferLayout>
    : <dfn>arrayStride</dfn>
    ::
        此数组元素之间的跨度（以字节为单位）。

    : <dfn>stepMode</dfn>
    ::
        该数组的每个元素表示每个顶点数据还是每个实例数据

    : <dfn>attributes</dfn>
    ::
        定义每个元素内顶点属性布局的数组。
</dl>

<script type=idl>
dictionary GPUVertexAttribute {
    required GPUVertexFormat format;
    required GPUSize64 offset;

    required GPUIndex32 shaderLocation;
};
</script>

<dl dfn-type=dict-member dfn-for=GPUVertexAttribute>
    : <dfn>format</dfn>
    ::
        属性的 {{GPUVertexFormat}}。

    : <dfn>offset</dfn>
    ::
        从元素开头到属性数据的偏移量（以字节为单位）。

    : <dfn>shaderLocation</dfn>
    ::
        与此属性关联的数字位置，将对应于在 {{GPURenderPipelineDescriptor/vertex}}.{{GPUProgrammableStage/module|module}} 中声明的 <a href="https://gpuweb.github.io/gpuweb/wgsl/#input-output-locations">"@location" 属性</a>。
</dl>

<div algorithm>
    <dfn abstract-op>validating GPUVertexBufferLayout</dfn>(device, descriptor, vertexStage)

    **Arguments:**

    - {{GPUDevice}} |device|
    - {{GPUVertexBufferLayout}} |descriptor|
    - {{GPUProgrammableStage}} |vertexStage|

    仅当满足以下所有条件时返回 `true`：


    - |descriptor|.{{GPUVertexBufferLayout/arrayStride}} &le; |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{支持的限制/maxVertexBufferArrayStride}}。
    - |descriptor|.{{GPUVertexBufferLayout/arrayStride}} 是 4 的倍数。
    - 对于列表 |descriptor|.{{GPUVertexBufferLayout/attributes}} 中的每个属性 |attrib|：
        - 如果 |descriptor|.{{GPUVertexBufferLayout/arrayStride}} 为零：
            - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) &le; |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBufferArrayStride}}。
            
            否则：

            - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) ≤ |descriptor|.{{GPUVertexBufferLayout/arrayStride}}。
        - |attrib|.{{GPUVertexAttribute/offset}} 是 4 和 sizeof(|attrib|.{{GPUVertexAttribute/format}}) 最小值的倍数。

        - |attrib|.{{GPUVertexAttribute/shaderLocation}} 是 < |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexAttributes}}。

    - 对于 |vertexStage| [=静态使用=] 的每个顶点属性 |var|， 应有一个与 |descriptor|.{{GPUVertexBufferLayout/attributes}} 的 |attrib| 元素相对应，且满足以下所有条件：
        - 变量 |T| 的类型与 |attrib|.{{GPUVertexAttribute/format}} 的 [=vertex data type=] 兼容:

            <dl class=switch> ：“unorm”，“snorm” 或 “float” :: |T| 必须是 f32 或 vecN<f32>。 ：“uint” :: |T| 必须是 u32 或 vecN<u32>。 ：“sint” :: |T| 必须是 i32 或 vecN<i32>。 </dl>
        - 着色器位置是 |attrib|.{{GPUVertexAttribute/shaderLocation}}.
</div>

<div algorithm>
    <dfn abstract-op>validating GPUVertexState</dfn>(device, descriptor)

    **Arguments:**

    - {{GPUDevice}} |device|
    - {{GPUVertexState}} |descriptor|

    返回 `true`，当且仅当满足以下所有条件：

    - |descriptor|.{{GPUVertexState/buffers}}.length ≤ |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBuffers}}.
    - 列表 |descriptor|.{{GPUVertexState/buffers}} 中的每个 |vertexBuffer| 布局描述符 通过 [$validating GPUVertexBufferLayout$](|device|, |vertexBuffer|, |descriptor|)
    - 对所有 |vertexBuffer| 的 |vertexBuffer|.{{GPUVertexBufferLayout/attributes}}.length 求和，在 |descriptor|.{{GPUVertexState/buffers}} 中, &le; |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexAttributes}}.
    - 在 |descriptor|.{{GPUVertexState/buffers}} 中的所有 {{GPUVertexAttribute}} 的并集中，每个 |attrib| 都具有一个独特的 |attrib|.{{GPUVertexAttribute/shaderLocation}} 值。
</div>

<pre class=include>
path: sections/copies.bs
</pre>

# 命令缓冲区 # {#command-buffers}

命令缓冲区是可以提交给{{GPUQueue}}执行的预先记录的[=GPU命令=]列表。
每个<dfn dfn>GPU命令</ dfn>代表在GPU上要执行的任务，例如设置状态，绘制，复制资源等。

一个{{GPUCommandBuffer}}只能提交一次，提交后它会变为[=无效=]。 要在多个提交中重复使用渲染命令，请使用{{GPURenderBundle}}。

<h3 id=gpucommandbuffer data-dfn-type=interface>`GPUCommandBuffer`
<span id=command-buffer></span>
</h3>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUCommandBuffer {
};
GPUCommandBuffer includes GPUObjectBase;
</script>

{{GPUCommandBuffer}} 具有以下内部插槽：

<dl dfn-type=attribute dfn-for=GPUCommandBuffer>
    : <dfn>\[[command_list]]</dfn>, of type [=list=]&lt;[=GPU command=]&gt;
    ::
        要在提交此命令缓冲区时在 [=Queue timeline=] 上执行的 [=GPU commands=] 列表。

    : <dfn>\[[renderState]]</dfn>, of type [=RenderState=]
    ::
        当前由任何正在执行的渲染通道命令使用的状态，初始值为 `null`。
</dl>

### 命令缓冲区创建 ### {#command-buffer-creation}

<script type=idl>
dictionary GPUCommandBufferDescriptor
         : GPUObjectDescriptorBase {
};
</script>


# 命令编码 # {#command-encoding}

<h3 id=gpucommandsmixin data-dfn-type=interface>`GPUCommandsMixin`
<span id=commans-mixin></span>
</h3>

{{GPUCommandsMixin}} 定义了所有编码命令接口的公共状态。它没有方法。

<script type=idl>
interface mixin GPUCommandsMixin {
};
</script>

{{GPUCommandsMixin}}将以下内部插槽添加到包含它的接口中:

<dl dfn-type=attribute dfn-for=GPUCommandsMixin>
    : <dfn>\[[state]]</dfn>, 类型为 [=encoder state=]
    ::
        当前编码器的状态，初始设置为“[=encoder state/open=]”。

    : <dfn>\[[commands]]</dfn>, of type [=list=]&lt;[=GPU command=]&gt;
    ::
        要在包含这些命令的{{GPUCommandBuffer}}提交时在[=队列时间线=]上执行的[=GPU command=]列表。
</dl>

<dfn dfn>编码器状态</dfn>可能是以下几种之一：

<dl dfn-type=dfn dfn-for="encoder state">
    : "<dfn>open</dfn>"
    ::
        编码器可以用来编码新的命令。

    : "<dfn>locked</dfn>"
    ::
        编码器无法使用，因为它被子编码器锁定：它是一个 {{GPUCommandEncoder}}，并且 {{GPURenderPassEncoder}} 或 {{GPUComputePassEncoder}} 是活动的。
        当 pass 结束时，编码器再次变为"[=encoder state/open=]"。


        在此状态下发出的任何命令都会使编码器 [=无效=]。

    : "<dfn>ended</dfn>"
    ::
        编码器已经结束，无法再对新命令进行编码。


        在此状态下发出的所有命令都将[$产生验证错误$]。
</dl>

<div algorithm>
    要<dfn abstract-op>验证{{GPUCommandsMixin}} |encoder|的编码器状态</dfn>:

    如果 |encoder|.{{GPUCommandsMixin/[[state]]}} 为:

    <dl class=switch>
        : "[=encoder state/open=]"
        :: 返回 `true`.

        : "[=encoder state/locked=]"
        :: 使 |encoder| [=无效=], 且返回 `false`。

        : "[=encoder state/ended=]"
        :: [$产生一个校验错误$], 且返回 `false`。
    </dl>
</div>

<div algorithm>
    要在 {{GPUCommandsMixin}} |encoder| 上<dfn abstract-op>添加一个命令</dfn>，该命令执行 [=GPU Command=] |command| 的步骤：


    1. 将 |command| 添加到 |encoder|.{{GPUCommandsMixin/[[commands]]}}。
    1. 当 |command| 作为 {{GPUCommandBuffer}} 的一部分执行时：
        1. 执行 |command| 的步骤。
</div>

<h3 id=gpucommandencoder data-dfn-type=interface>`GPUCommandEncoder`
<span id=command-encoder></span>
</h3>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUCommandEncoder {
    GPURenderPassEncoder beginRenderPass(GPURenderPassDescriptor descriptor);
    GPUComputePassEncoder beginComputePass(optional GPUComputePassDescriptor descriptor = {});

    undefined copyBufferToBuffer(
        GPUBuffer source,
        GPUSize64 sourceOffset,
        GPUBuffer destination,
        GPUSize64 destinationOffset,
        GPUSize64 size);

    undefined copyBufferToTexture(
        GPUImageCopyBuffer source,
        GPUImageCopyTexture destination,
        GPUExtent3D copySize);

    undefined copyTextureToBuffer(
        GPUImageCopyTexture source,
        GPUImageCopyBuffer destination,
        GPUExtent3D copySize);

    undefined copyTextureToTexture(
        GPUImageCopyTexture source,
        GPUImageCopyTexture destination,
        GPUExtent3D copySize);

    undefined clearBuffer(
        GPUBuffer buffer,
        optional GPUSize64 offset = 0,
        optional GPUSize64 size);

    undefined writeTimestamp(GPUQuerySet querySet, GPUSize32 queryIndex);

    undefined resolveQuerySet(
        GPUQuerySet querySet,
        GPUSize32 firstQuery,
        GPUSize32 queryCount,
        GPUBuffer destination,
        GPUSize64 destinationOffset);

    GPUCommandBuffer finish(optional GPUCommandBufferDescriptor descriptor = {});
};
GPUCommandEncoder includes GPUObjectBase;
GPUCommandEncoder includes GPUCommandsMixin;
GPUCommandEncoder includes GPUDebugCommandsMixin;
</script>

### 命令编码器创建 ### {#command-encoder-creation}

<script type=idl>
dictionary GPUCommandEncoderDescriptor
         : GPUObjectDescriptorBase {
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createCommandEncoder(descriptor)</dfn>
    ::
        创建一个 {{GPUCommandEncoder}}。

        <div algorithm=GPUDevice.createCommandEncoder>
            <div data-timeline=content>
                **Called on:** {{GPUDevice}} this.

                **Arguments:**

                <pre class=argumentdef for="GPUDevice/createCommandEncoder(descriptor)">
                    descriptor: 要创建的 {{GPUCommandEncoder}} 的描述。
                </pre>

                **Returns:** {{GPUCommandEncoder}}

                [=内容时间线=] 步骤：

                1. 让 |e| 成为一个新的 {{GPUCommandEncoder}} 对象。
                1. 在 |this| 的 [=设备时间线=] 上执行 |initialization steps|。
                1. 返回 |e|。
            </div>
            <div data-timeline=device>
                [=设备时间线=] |initialization steps|：


                1. 如果以下任何条件不满足，[$生成验证错误$]，使 |e| [=无效=]，并停止。

                    <div class=validusage>
                        - | this | 是[=有效=]的。
                    </div>

                问题：描述剩余的 {{GPUDevice/createCommandEncoder()}} 验证和
                算法步骤。
            </div>
        </div>
</dl>

<div class=example>
    创建一个 {{GPUCommandEncoder}}，对一个缓冲区进行清除的命令进行编码，完成编码器以获得一个 {{GPUCommandBuffer}}，然后将其提交给 {{GPUQueue}}。

    <pre highlight=js>
        const commandEncoder = gpuDevice.createCommandEncoder();
        commandEncoder.clearBuffer(buffer);
        const commandBuffer = commandEncoder.finish();
        gpuDevice.queue.submit([commandBuffer]);
    </pre>
</div>

## 通道编码 ## {#command-encoder-pass-encoding}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>beginRenderPass(descriptor)</dfn>
    ::
        开始编码由 |descriptor| 描述的渲染过程。

        <div algorithm=GPUCommandEncoder.beginRenderPass>
            <div data-timeline=content>
                **Called on:** {{GPUCommandEncoder}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUCommandEncoder/beginRenderPass(descriptor)">
                    |descriptor|: 要创建的 {{GPURenderPassEncoder}} 的描述。
                </pre>

                **Returns:** {{GPURenderPassEncoder}}

                [=内容时间线=] 步骤：


                1. 对于 |descriptor| 的 {{GPURenderPassDescriptor/colorAttachments}} 中的每个非 `null` 的 |colorAttachment|：
                    1. 如果 |colorAttachment| 的 {{GPURenderPassColorAttachment/clearValue}} 不是 `null`。
                        1. [=?=] [$验证 GPUColor 形状$](|colorAttachment|.{{GPURenderPassColorAttachment/clearValue}})。
                1. 设 |pass| 为一个新的 {{GPURenderPassEncoder}} 对象。
                1. 在 |this| 的 [=设备时间线=] 上发布 |初始化步骤|。
                1. 返回 |pass|。
            </div>
            <div data-timeline=device>
                [=设备时间轴=] |初始化步骤|：


                1. 检查 |this| 的[$验证编码器状态$]。 如果返回为 false，将 |pass| 设为[=无效=]并返回。
                1. 将 |this|.{{GPUCommandsMixin/[[state]]}} 设置为 “[=编码器状态/锁定=]”。
                1. 如果以下任何要求未满足，则将 |pass| 设为 [=invalid=] 并返回。
                    <div class=validusage>
                        - 设备 |this| 上的 |descriptor| 必须满足 {{GPUObjectBase/[[device]]}} 提供的 [$GPURenderPassDescriptor/有效使用$] 规则。
                    </div>
                1. 对于 |descriptor|.{{GPURenderPassDescriptor/colorAttachments}} 中的每个非“null” |colorAttachment|：
                    1. 在渲染操作期间，由 |colorAttachment|.{{GPURenderPassColorAttachment/view}} 观察到的 [=纹理子资源=] 被视为用作 [=内部使用/附件=]。
                1. 让 |depthStencilAttachment| 成为 |descriptor|.{{GPURenderPassDescriptor/depthStencilAttachment}}，如果没有 [=map/exist|provided=] 则为“null”。
                1. 如果 |depthStencilAttachment| 不是 `null`：
                    1. 让 |depthStencilView| 成为 |depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/view}}。
                    1. 如果 |depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}} 和 {{GPURenderPassDepthStencilAttachment/stencilReadOnly}} 为 true：
                        1. 在渲染操作期间，|depthStencilView| 的 [=GPUTextureView/subresources=} 被视为用作 [=internal usage/attachment-read=]。
                    1. 否则，由 |depthStencilView| 观察到的 [=纹理子资源=] 被视为用作 [=内部使用/附件=]。
                    1. 设置 |pass|.{{GPURenderCommandsMixin/[[depthReadOnly]]}} 为 |depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}}。
                    1. 设置 |pass|.{{GPURenderCommandsMixin/[[stencilReadOnly]]}} 为 |depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/stencilReadOnly}}。
                1. 将 |pass|.{{GPURenderCommandsMixin/[[layout]]}} 设置为 [$从 pass 推导出 render targets layout$](|descriptor|)。
                1. 对于 |descriptor|中的每个{{GPURenderPassDescriptor/timestampWrites}}中的 |timestampWrite|,
                    1. 如果 |timestampWrite|的{{GPURenderPassTimestampWrite/location}}为{{GPURenderPassTimestampLocation/"beginning"}}，
                        在 |this|的{{GPUCommandsMixin/[[commands]]}}中 [=list/append=] 一个 [=GPU command=]
                        将GPU的时间戳值写入 |timestampWrite|的{{GPURenderPassTimestampWrite/querySet}}的
                        |timestampWrite|的{{GPURenderPassTimestampWrite/queryIndex}} 索引处。
                    1. 否则,如果 |timestampWrite|.{{GPURenderPassTimestampWrite/location}}为{{GPURenderPassTimestampLocation/"end"}},
                        [=list/添加=] |timestampWrite|到 |pass|的 {{GPURenderPassEncoder/[[endTimestampWrites]]}}。
                1. 将 |pass|的{{GPURenderCommandsMixin/[[drawCount]]}}设置为0。
                1. 将 |pass|的{{GPURenderPassEncoder/[[maxDrawCount]]}}设置为 |descriptor|的{{GPURenderPassDescriptor/maxDrawCount}}。
                1. 在 |this| 上执行[$Enqueue a command$]，当执行时，在[=Queue timeline=]上执行后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤：

                 1. 让当前正在执行的{{GPUCommandBuffer}}的{{GPUCommandBuffer/[[renderState]]}}成为一个新的[=RenderState=]。
                 1. 问题：执行附件加载/清除。
            </div>

            问题：指定只读深度/模板的行为
        </div>

    : <dfn>beginComputePass(descriptor)</dfn>
    ::
        开始对 |descriptor| 描述的计算过程进行编码。

        <div algorithm=GPUCommandEncoder.beginComputePass>
            <div data-timeline=content>
                **Called on:** {{GPUCommandEncoder}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUCommandEncoder/beginComputePass(descriptor)">
                    descriptor:
                </pre>

                **Returns:** {{GPUComputePassEncoder}}

                [=内容时间线=] 步骤：

                    1.让 |pass| 是一个新的 {{GPUComputePassEncoder}} 对象。
                    1.发出|初始化步骤| 在 |this| 的 [=设备时间线=] 上。
                    1. 返回 |pass|。
            </div>
            <div data-timeline=device>
                [=设备时间线=] |initialization steps|:


                1. 验证 |this| 的编码器状态。 如果返回false，使 |pass| 无效并返回。
                1. 设定 |this|.{{GPUCommandsMixin/[[state]]}} 为 “[=encoder state/locked=]”。
                1. 如果以下任何要求没有得到满足，使 |pass| 无效并返回。
                    <div class=validusage>
                        - 必须返回true的[$验证 timeStampWrites$] (|this|.{{GPUObjectBase/[[device]]}}，|descriptor|.{{GPUComputePassDescriptor/timestampWrites}})。
                    </div>
                1. 对于 |descriptor|.{{GPUComputePassDescriptor/timestampWrites}} 中的每个 |timestampWrite|，遵循以下步骤：
                    1. 如果 |timestampWrite|.{{GPUComputePassTimestampWrite/location}} 是 {{GPUComputePassTimestampLocation/“beginning”}}， 将一个 [=GPU command=] 追加到 |this|.{{GPUCommandsMixin/[[commands]]}} 中，该命令将 GPU 的时间戳值写入 |timestampWrite|.{{GPUComputePassTimestampWrite/querySet}} 的 |timestampWrite|.{{GPUComputePassTimestampWrite/queryIndex}} 索引处。
                    1. 否则，如果 |timestampWrite|.{{GPUComputePassTimestampWrite/location}} 是 {{GPUComputePassTimestampLocation/“end”}}， 将 |timestampWrite| 追加到 |pass|.{{GPUComputePassEncoder/[[endTimestampWrites]]}} 中。
            </div>
        </div>
</dl>

## 缓冲区拷贝命令 ## {#commands-buffer-copies}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size)</dfn>
    ::
        将命令编码到 {{GPUCommandEncoder}} 中，将数据从 {{GPUBuffer}} 的子区域复制到另一个 {{GPUBuffer}} 的子区域。

        <div algorithm=GPUCommandEncoder.copyBufferToBuffer>
            <div data-timeline=content>
                **Called on:** {{GPUCommandEncoder}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUCommandEncoder/copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size)">
                    |source|: 要从中复制的 {{GPUBuffer}}。
                    |sourceOffset|: 以字节为单位的偏移量到|source| 从开始复制。
                    |destination|: 要复制到的 {{GPUBuffer}}。
                    |destinationOffset|: 到 |destination| 的偏移量（以字节为单位） 放置复制的数据。
                    |size|: 要复制的字节数。
                </pre>

                **Returns:** {{undefined}}

                [=内容时间线=] 步骤：

                1. 在 |this|.{{GPUObjectBase/[[device]]}} 的 [=设备时间线=] 上发布后续步骤。
            </div>
            <div data-timeline=device>
               [=设备时间线=] 步骤：

                 1. |this| 的[$验证编码器状态$]。 如果它返回 false，则停止。
                 1. 如果不满足以下任何条件，则制作|this| [=无效=] 并停止。

                    <div class=validusage>
                        - |source| 是 [$valid to use with$] |this|。
                        - |destination| 是 [$valid to use with$] |this|。
                        - |source|.{{GPUBuffer/usage}} 包含 {{GPUBufferUsage/COPY_SRC}}。
                        - |destination|.{{GPUBuffer/usage}} 包含 {{GPUBufferUsage/COPY_DST}}。
                        - |size| 是4的倍数。
                        - |sourceOffset| 是4的倍数。
                        - |destinationOffset| 是4的倍数。
                        - |source|.{{GPUBuffer/size}} &ge; (|sourceOffset| + |size|)。
                        - |destination|.{{GPUBuffer/size}} &ge; (|destinationOffset| + |size|)。
                        - |source| 和|destination| 不一样的 {{GPUBuffer}}。
                    </div>

                1. 在|this|上[$执行一个命令$]，在执行时在[=队列时间线=]上发出后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤:


                1. 将 |source| 中从 |sourceOffset| 开始的 |size| 字节复制到 |destination|，
                    从 |destinationOffset| 开始。
            </div>
        </div>

    : <dfn>clearBuffer(buffer, offset, size)</dfn>
    ::
        将一个命令编码到 {{GPUCommandEncoder}} 中，该命令将{{GPUBuffer}} 的子区域填充为零。

        <div algorithm=GPUCommandEncoder.clearBuffer>
            <div data-timeline=content>
                **Called on:** {{GPUCommandEncoder}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUCommandEncoder/clearBuffer(buffer, offset, size)">
                    |buffer|: 要清除的{{GPUBuffer}}。
                    |offset|: 偏移字节到|buffer| 要清除的子区域开始的地方。
                    |size|: 要清除的子区域的大小（以字节为单位）。默认为缓冲区大小减去 |offset|。
                </pre>

                **Returns:** {{undefined}}

                [=内容时间线=] 步骤：

                1. 在 |this|.{{GPUObjectBase/[[device]]}} 的 [=Device timeline=] 上发布后续步骤。
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤:


                1. 验证|this|的编码器状态。如果返回 false， 停止。
                1. 如果 |size| 丢失， 将 |size| 设置为 `max(0, |buffer|.{{GPUBuffer/size}} - |offset|)`。
                1. 如果以下任何条件不满足,则使 |this| [=无效=] 并停止。
                
                    <div class=validusage>
                        - |buffer| 对于 |this| 是[$有效的$]。
                        - |buffer|.{{GPUBuffer/usage}} 包含 {{GPUBufferUsage/COPY_DST}}。
                        - |size| 是4的倍数。
                        - |offset| 是4的倍数。
                        - |buffer|.{{GPUBuffer/size}} &ge; (|offset| + |size|)。
                    </div>

                1. 在 |this| 上执行[$入队命令$]，当执行时在[=Queue timeline=] 上发布后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间轴=]步骤：


                1. 从 |offset| 开始将 |buffer| 的 |size| 字节设置为 `0`。
            </div>

        </div>
</dl>

## 图像复制命令 ## {#commands-image-copies}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>copyBufferToTexture(source, destination, copySize)</dfn>
    ::
        将一个命令编码到{{GPUCommandEncoder}}中，将数据从{{GPUBuffer}}的子区域复制到一个或多个连续的[=纹理子资源=]的子区域。

        <div algorithm=GPUCommandEncoder.copyBufferToTexture>
            <div data-timeline=content>
                **Called on:** {{GPUCommandEncoder}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUCommandEncoder/copyBufferToTexture(source, destination, copySize)">
                    |source|: 结合|copySize|，定义源缓冲区的区域。
                    |destination|: 结合|copySize|，定义目标区域[=texture subresource=]。
                    |copySize|:
                </pre>

                **Returns:** {{undefined}}

                [=内容时间线=] 步骤：


                1. [=？=] [$验证 GPUOrigin3D 形状$](|destination|.{{GPUImageCopyTexture/origin}})。
                1. [=？=] [$验证 GPUExtent3D 形状$](|copySize|)。
                1. 在 |this|.{{GPUObjectBase/[[device]]}} 的 [=设备时间线=] 上发布后续步骤：
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. |this| 的[$验证编码器状态$]。 如果它返回 false，则停止。
                1. 如果不满足以下任何条件，则制作|this| [=无效=] 并停止。

                    <div class=validusage>
                        - 让 |dstTexture| 是 |destination|.{{GPUImageCopyTexture/texture}}.
                        - [$验证GPUImageCopyBuffer$] 返回 true.
                        - |source|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/usage}} 包含 {{GPUBufferUsage/COPY_SRC}}.
                        - [$验证GPUImageCopyTexture$](|destination|, |copySize|) 返回 true.
                        - |dstTexture|.{{GPUTexture/usage}} 包含 {{GPUTextureUsage/COPY_DST}}.
                        - |dstTexture|.{{GPUTexture/sampleCount}} 是 1.
                        - 让 |aspectSpecificFormat| = |dstTexture|.{{GPUTexture/format}}.
                        - 如果 |dstTexture|.{{GPUTexture/format}} 是一个 [=深度或模板格式=]:
                        - |destination|.{{GPUImageCopyTexture/aspect}} 必须引用
                            |dstTexture|.{{GPUTexture/format}}的单个方面.
                        - 那个方面必须是根据 [[#depth-formats]] 的有效图像拷贝目标。
                        - 将 |aspectSpecificFormat| 设置为根据 [[#depth-formats]] 的 [=方面特定格式=].
                        - [=验证纹理拷贝范围=](|destination|, |copySize|) 返回 true.
                        - 如果 |dstTexture|.{{GPUTexture/format}} 不是 [=深度或模板格式=]:
                        - |source|.{{GPUImageDataLayout/offset}} 是
                            |dstTexture|.{{GPUTexture/format}} 的
                            [=texel block copy footprint=] 的倍数。
                        - 如果 |dstTexture|.{{GPUTexture/format}} 是一个 [=深度或模板格式=]:
                        - |source|.{{GPUImageDataLayout/offset}} 是 4 的倍数。
                        - [$验证线性纹理数据$](|source|,
                            |source|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/size}},
                            |aspectSpecificFormat|,
                            |copySize|) 成功。
                    </div>

                1. 将一个命令加入队列，当执行时，在[=Queue timeline=]上执行后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤:


                问题：定义副本，包括对snorm的规定。
            </div>

        </div>

    : <dfn>copyTextureToBuffer(source, destination, copySize)</dfn>
    ::
        将一个命令编码到 {{GPUCommandEncoder}} 中，该命令从一个或多个连续的 [=texture subresources=] 子区域中复制数据到 {{GPUBuffer}} 的子区域。

        <div algorithm=GPUCommandEncoder.copyTextureToBuffer>
            <div data-timeline=content>
                **Called on:** {{GPUCommandEncoder}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUCommandEncoder/copyTextureToBuffer(source, destination, copySize)">
                    |source|: 结合 |copySize|，定义源[=texture subresources=]的区域。
                    |destination|: 结合 |copySize|，定义目标缓冲区的区域。
                    |copySize|: 定义所需复制区域的大小。
                </pre>

                **Returns:** {{undefined}}

               [=内容时间线=] 步骤：


                1. [=?=] [$验证 GPUOrigin3D 形状$](|source|.{{GPUImageCopyTexture/origin}})。
                1. [=?=] [$验证 GPUExtent3D 形状$](|copySize|)。
                1. 在 |this|.{{GPUObjectBase/[[device]]}} 的 [=设备时间线=] 上发布后续步骤：
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：


                1. 验证|this|的[=编码器状态$]。如果返回 false，则停止。
                1. 如果以下任何条件不满足，使|this|变为[=无效=]并停止。

                    <div class=validusage>
                        - 让 |srcTexture| 为 |source|.{{GPUImageCopyTexture/texture}}。
                        - [$验证 GPUImageCopyTexture$](|source|, |copySize|) 返回 true。
                        - |srcTexture|.{{GPUTexture/usage}} 包含 {{GPUTextureUsage/COPY_SRC}}。
                        - |srcTexture|.{{GPUTexture/sampleCount}} 是 1。
                        - 让 |aspectSpecificFormat| = |srcTexture|.{{GPUTexture/format}}。
                        - 如果 |srcTexture|.{{GPUTexture/format}} 是一个 [=depth-or-stencil format=]格式：
                            - |source|.{{GPUImageCopyTexture/aspect}} 必须引用 |srcTexture|.{{GPUTexture/format}} 的单个方面。
                            - 根据 [[#depth-formats]]，该方面必须是有效的图像复制源。
                            - 将 |aspectSpecificFormat| 设置为根据 [[#depth-formats]] 的 [=aspect-specific format=]。
                        - $验证 GPUImageCopyBuffer$ 返回 true。
                        - |destination|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/usage}} 包含 {{GPUBufferUsage/COPY_DST}}。
                        - [=验证纹理复制范围=](|source|, |copySize|) 返回 true。
                        - 如果 |srcTexture|.{{GPUTexture/format}} 不是 [=depth-or-stencil format=]：
                            - |destination|.{{GPUImageDataLayout/offset}} 是 |srcTexture|.{{GPUTexture/format}} 的 [=texel block copy footprint=] 的倍数。
                        - 如果 |srcTexture|.{{GPUTexture/format}} 是 [=depth-or-stencil format=]：
                                - |destination|.{{GPUImageDataLayout/offset}} 是 4 的倍数。
                        - [$ 验证线性纹理数据 $](|destination|, |destination|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/size}}, |aspectSpecificFormat|, |copySize|) 成功。
                    </div>

                1. 在 |this| 上 [$Enqueue a command$]，执行时会在 [=队列时间线=] 上发出后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤：
                
                问题：定义副本，包括 snorm 的规定。
            </div>

        </div>

    : <dfn>copyTextureToTexture(source, destination, copySize)</dfn>
    ::
        将一个命令编码到{{GPUCommandEncoder}}中，该命令用于将数据从一个或多个连续的[=texture subresources=]的子区域复制到另一个或多个连续的[=texture subresources=]的子区域。

        <div algorithm=GPUCommandEncoder.copyTextureToTexture>
            <div data-timeline=content>
                **Called on:** {{GPUCommandEncoder}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUCommandEncoder/copyTextureToTexture(source, destination, copySize)">
                    |source|: 结合|copySize|，定义源[=纹理子资源=]的区域。
                    |destination|: 结合|copySize|，定义目标[=纹理子资源=]的区域。
                    |copySize|: 复制尺寸。
                </pre>

                **Returns:** {{undefined}}

                [=内容时间线=] 步骤：


                1. [=?=] [$验证 GPUOrigin3D 形状$](|source|.{{GPUImageCopyTexture/origin}}).
                1. [=?=] [$验证 GPUOrigin3D 形状$](|destination|.{{GPUImageCopyTexture/origin}}).
                1. [=?=] [$验证 GPUExtent3D 形状$](|copySize|).
                1. 在 |this|.{{GPUObjectBase/[[device]]}} 的 [=设备时间线=] 上执行后续步骤：
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：


                1.验证|this|的[$编码器状态$]。如果返回结果为false，则停止。
                1.如果以下任何条件不满足，则使|this|变为[=无效=]并停止。

                    <div class=validusage>
                        - 让 |srcTexture| 是 |source|.{{GPUImageCopyTexture/texture}}。
                        - 让 |dstTexture| 是 |destination|.{{GPUImageCopyTexture/texture}}。
                        - [$validating GPUImageCopyTexture$](|source|, |copySize|) 返回 true。
                        - |srcTexture|.{{GPUTexture/usage}} 包含 {{GPUTextureUsage/COPY_SRC}}。
                        - [$validating GPUImageCopyTexture$](|destination|, |copySize|) 返回 true。
                        - |dstTexture|.{{GPUTexture/usage}} 包含 {{GPUTextureUsage/COPY_DST}}。
                        - |srcTexture|.{{GPUTexture/sampleCount}} 等于 |dstTexture|.{{GPUTexture/sampleCount}}。
                        - |srcTexture|.{{GPUTexture/format}} 和 |dstTexture|.{{GPUTexture/format}} 必须是 [=copy-compatible=]。
                        - 如果 |srcTexture|.{{GPUTexture/format}} 是深度模板格式：
                            - |source|.{{GPUImageCopyTexture/aspect}} 和 |destination|.{{GPUImageCopyTexture/aspect}} 必须分别引用 |srcTexture|.{{GPUTexture/format}} 和 |dstTexture|.{{GPUTexture/format}} 的所有方面。
                        - [=validating texture copy range=](|source|, |copySize|) 返回 true。
                        - [=validating texture copy range=](|destination|, |copySize|) 返回 true。
                        - [$set of subresources for texture copy$](|source|, |copySize|) 和 [$set of subresources for texture copy$](|destination|, |copySize|) 是不相交的。
                    </div>

                1. [$Enqueue a command$] on |this| which issues the subsequent steps on the
                    [=Queue timeline=] when executed.
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤：

                问题：定义副本，包括 snorm 的规定。
            </div>

        </div>
</dl>

## 请求 ## {#command-encoder-queries}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>writeTimestamp(querySet, queryIndex)</dfn>
    ::
        当所有先前的命令都已完成执行时，将时间戳值写入 querySet。

        <div algorithm=GPUCommandEncoder.writeTimestamp>
            <div data-timeline=content>
                **Called on:** {{GPUCommandEncoder}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUCommandEncoder/writeTimestamp(querySet, queryIndex)">
                    |querySet|: 将存储时间戳值的查询集。
                    |queryIndex|: 查询在查询集中的索引。
                </pre>

                **Returns:** {{undefined}}

                [=内容时间线=] 步骤：

                1. 如果 {{GPUFeatureName/"timestamp-query"}} 不是 [=enabled for=] |this|：
                1. 抛出一个{{TypeError}}。
                1. 在 |this| 的 [=Device timeline=] 上发布后续步骤。{{GPUObjectBase/[[device]]}}：
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. |this| 的[$验证编码器状态$]。如果它返回 false，则停止。
                1. 如果不满足以下任何条件，则制作|this| [=无效=] 并停止。

                     <div 类=有效使用>
                         - |querySet| 是 [$valid to use with$] |this|。
                         - |querySet|.{{GPUQuerySet/type}} 是 {{GPUQueryType/"timestamp"}}。
                         - |queryIndex| &lt; |querySet|.{{GPUQuerySet/count}}。
                     </div>

                 1. 将一个命令插入|this|，当该命令执行时，在[=队列时间线=]上进行后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤:


                1. 将当前的[=队列时间线=]时间戳（单位：纳秒）写入索引为 |queryIndex| 的 |querySet| 中。
            </div>
        </div>

    : <dfn>resolveQuerySet(querySet, firstQuery, queryCount, destination, destinationOffset)</dfn>
    ::
        将{{GPUQuerySet}}中的查询结果解析到{{GPUBuffer}}的一定范围内。

        <div algorithm=GPUCommandEncoder.resolveQuerySet>
            <div data-timeline=content>
                **Called on:** {{GPUCommandEncoder}} this.

                **Arguments:**

                <pre class=argumentdef for="GPUCommandEncoder/resolveQuerySet(querySet, firstQuery, queryCount, destination, destinationOffset)">
                    querySet:
                    firstQuery:
                    queryCount:
                    destination:
                    destinationOffset:
                </pre>

                **Returns:** {{undefined}}

                [=内容时间线=] 步骤：


                1. 在|this|.{{GPUObjectBase/[[device]]}} 的 [=设备时间线=] 上发布后续步骤。
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：


                1.验证|this|的[$编码器状态$]。如果返回false，则停止。
                1.如果任何以下条件不满足，将|this|设为[=无效=]并停止。

                    <div class=validusage>
                        - |querySet| 可以与 |this| [$一起使用$]。
                        - |destination| 可以与 |this| [$一起使用$]。
                        - |destination|.{{GPUBuffer/usage}} 包含 {{GPUBufferUsage/QUERY_RESOLVE}}。
                        - |firstQuery| &lt;在 |querySet| 中的查询数量。
                        - (|firstQuery| + |queryCount|) &le; 在 |querySet| 中的查询数量。
                        - |destinationOffset| 是256的倍数。
                        - |destinationOffset| + 8 × |queryCount| &le; |destination|.{{GPUBuffer/size}}。
                    </div>

                1.在|this|上[$入队一个命令$]，执行后在[=队列时间线=]上执行后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤：

                1. 使 |queryIndex| 为 |firstQuery|.
                1. 使 |offset| 为 |destinationOffset|.
                1. |queryIndex| &lt; |firstQuery| + |queryCount|:
                    1. 设置 8 个字节的 |destination|，从 |offset| 开始，作为在 |queryIndex| |querySet| 的值。
                    1. 设置 |queryIndex| 为 |queryIndex| + 1.
                    1. 设置 |offset| 为 |offset| + 8.
            </div>
        </div>
</dl>

## 最终 ## {#command-encoder-finalization}

一个包含{{GPUCommandEncoder}}记录的命令的{{GPUCommandBuffer}}可以通过调用{{GPUCommandEncoder/finish()}}来创建。一旦调用了{{GPUCommandEncoder/finish()}}，该命令编码器将不再可用。

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>finish(descriptor)</dfn>
    ::
        完成命令序列的记录并返回相应的 {{GPUCommandBuffer}}。

        <div algorithm=GPUCommandEncoder.finish>
            <div data-timeline=content>
                **Called on:** {{GPUCommandEncoder}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUCommandEncoder/finish(descriptor)">
                    descriptor:
                </pre>

                **Returns:** {{GPUCommandBuffer}}

                [=Content timeline=] steps:

                1. 让 |commandBuffer| 是一个新的 {{GPUCommandBuffer}}。
                1. 在 |this|.{{GPUObjectBase/[[设备]]}} 的 [=设备时间轴=] 上发出 |finish steps|。
                1. 返回 |commandBuffer|。
            </div>
            <div data-timeline=device>
                [=设备时间线=] |finish steps|:


                1. 如果满足以下所有要求，那么将 |validationSucceeded| 设置为“true”，否则设置为“false”。

                    <div class=validusage>
                        - |this| 必须是 [=有效的=]。
                        - |this|.{{GPUCommandsMixin/[[state]]}} 必须是"[=编码器状态/打开=]"。
                        - |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}} 必须 [=list/is empty|为空=]。
                        - |this| 中包含的每个 [=使用范围=] 必须满足 [=使用范围验证=]。
                    </div>
                1. 将 |this|.{{GPUCommandsMixin/[[state]]}} 设置为 "[=编码器状态/结束=]"。
                1. 如果 |validationSucceeded| 为 `false`，那么：
                    1. [$生成验证错误$]。
                    1. 返回一个新的 [=无效的=] {{GPUCommandBuffer}}。
                1. 将 |commandBuffer|.{{GPUCommandBuffer/[[command_list]]}} 设置为
                    |this|.{{GPUCommandsMixin/[[commands]]}}。
            </div>
        </div>
</dl>

# 可编程通道 # {#programmable-passes}

<script type=idl>
interface mixin GPUBindingCommandsMixin {
    undefined setBindGroup(GPUIndex32 index, GPUBindGroup? bindGroup,
        optional sequence<GPUBufferDynamicOffset> dynamicOffsets = []);

    undefined setBindGroup(GPUIndex32 index, GPUBindGroup? bindGroup,
        Uint32Array dynamicOffsetsData,
        GPUSize64 dynamicOffsetsDataStart,
        GPUSize32 dynamicOffsetsDataLength);
};
</script>

{{GPUBindingCommandsMixin}}假定在同一个对象上存在{{GPUObjectBase}}和{{GPUCommandsMixin}}成员。它只能被同时包含这些mixin的接口所包含。


{{GPUBindingCommandsMixin}}具有以下内部插槽数：

<dl dfn-type=attribute dfn-for=GPUBindingCommandsMixin>
    : <dfn>\[[bind_groups]]</dfn>, 类型为 [=ordered map=]&lt;{{GPUIndex32}}, {{GPUBindGroup}}&gt;
    ::
        当前的{{GPUBindGroup}}用于每个索引，初始为空。

    : <dfn>\[[dynamic_offsets]]</dfn>, 类型为 [=ordered map=]&lt;{{GPUIndex32}}, [=sequence=]&gt;{{GPUBufferDynamicOffset}}>&gt;
    ::
        当前每个 {{GPUBindingCommandsMixin/[[bind_groups]]}} 条目的动态偏移量，初始为空。
</dl>

## 绑定组 ## {#programmable-passes-bind-groups}

<dfn dfn for=GPUBindingCommandsMixin>setBindGroup()</dfn> has two overloads:

<dl dfn-type=method dfn-for=GPUBindingCommandsMixin>
    : <dfn>setBindGroup(index, bindGroup, dynamicOffsets)</dfn>
    ::
        为给定的索引设置当前的 {{GPUBindGroup}}。

        <div algorithm=GPUBindingCommandsMixin.setBindGroup>
            <div data-timeline=content>
                **Called on:** {{GPUBindingCommandsMixin}} this.

                **Arguments:**

                <!-- TODO(tabatkins/bikeshed#1740, plinss/widlparser#56):
                The argumentdef feature doesn't work with overloaded functions, and it ends up
                expecting this to define the arguments for the 5-arg variant of the method, despite
                the "for" explicitly pointing at the 3-arg variant.
                So, we don't use argumentdef for this method. -->

                <dl dfn-type=argument dfn-for="GPUBindingCommandsMixin/setBindGroup(index, bindGroup, dynamicOffsets)">
                    : <dfn>|index|</dfn>, 类型为 {{GPUIndex32}}, non-nullable, required
                    ::
                        设置绑定组的索引。

                    : <dfn>|bindGroup|</dfn>, 类型为 {{GPUBindGroup}}, nullable, required
                    ::
                        绑定组以用于后续渲染或计算命令。

                    : <dfn>|dynamicOffsets|</dfn>, of type [=sequence=]&lt;{{GPUBufferDynamicOffset}}&gt;, non-nullable, defaulting to `[]`
                    ::
                        包含每个标记为 {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}} 的 |bindGroup| 项的字节缓冲区偏移量的数组。
                </dl>

                **Returns:** {{undefined}}

                注：
                |dynamicOffsets|[|i|] 用于绑定组中第 |i| 个动态缓冲区绑定，
                当按照 {{GPUBindGroupLayoutEntry}}.{{GPUBindGroupLayoutEntry/binding}} 的顺序排序绑定时。
                换句话说，|dynamicOffsets| 的顺序与动态缓冲区绑定的 {{GPUBindGroupLayoutEntry}}.{{GPUBindGroupLayoutEntry/binding}} 相同。


                [=内容时间线=] 步骤：

                1. 在 |this|.{{GPUObjectBase/[[device]]}} 的 [=设备时间线=] 上执行后续步骤。
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：


                1. 验证 |this| 的编码器状态[$Validate the encoder state$]。如果返回 false，则停止。
                1. 如果 `bindGroup` 是 `null`，则让 |dynamicOffsetCount| 为 0，否则为
                    |bindGroup|.{{GPUBindGroup/[[layout]]}}.{{GPUBindGroupLayout/[[dynamicOffsetCount]]}}。
                1. 如果以下任何要求没有得到满足，使 |this| 变为[=invalid=]并停止。

                    <div class=validusage>
                        - |index| 必须小于
                            |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxBindGroups}}.
                        - |dynamicOffsets|.length 必须等于 |dynamicOffsetCount|.
                    </div>
                1. 如果 |bindGroup| 是 `null`：
                    1. 在 |this|.{{GPUBindingCommandsMixin/[[bind_groups]]}}[|index|] 中 [=map/Remove=]。
                    1. 在 |this|.{{GPUBindingCommandsMixin/[[dynamic_offsets]]}}[|index|] 中 [=map/Remove=]。

                    否则：
                    1. 如果以下任何要求未得到满足，请使|this| [=invalid=] 并停止。

                        <div class=validusage>
                            - |bindGroup| 必须与 |this|一起[$有效使用$]。
                            - [$对每个动态绑定偏移量进行遍历|对于动态绑定的每一个$]
                                (|bufferBinding|, |bufferLayout|, |dynamicOffsetIndex|) in |bindGroup|:
                                - |bufferBinding|.{{GPUBufferBinding/offset}} + |dynamicOffsets|[|dynamicOffsetIndex|] +
                                    |bufferLayout|.{{GPUBufferBindingLayout/minBindingSize}} 必须 <=;
                                    |bufferBinding|.{{GPUBufferBinding/buffer}}.{{GPUBuffer/size}}.
                                - 如果 |bufferLayout|.{{GPUBufferBindingLayout/type}} 是 {{GPUBufferBindingType/"uniform"}}:

                                    - |dynamicOffset| 必须是 {{supported limits/minUniformBufferOffsetAlignment}} 的倍数。

                                - 如果 |bufferLayout|.{{GPUBufferBindingLayout/type}} 是 {{GPUBufferBindingType/"storage"}}
                                    或 {{GPUBufferBindingType/"read-only-storage"}}:

                                    - |dynamicOffset| 必须是 {{supported limits/minStorageBufferOffsetAlignment}} 的倍数。
                        </div>
                    1. 将 |this|.{{GPUBindingCommandsMixin/[[bind_groups]]}}[|index|] 设置为 |bindGroup|。
                    1. 将 |this|.{{GPUBindingCommandsMixin/[[dynamic_offsets]]}}[|index|] 设置为 |dynamicOffsets| 的副本。
            </div>
        </div>

    : <dfn>setBindGroup(index, bindGroup, dynamicOffsetsData, dynamicOffsetsDataStart, dynamicOffsetsDataLength)</dfn>
    ::
        为给定索引设置当前 {{GPUBindGroup}}，将动态偏移量指定为 {{Uint32Array}} 的子集。

        <div algorithm=GPUBindingCommandsMixin.setBindGroup2>
            <div data-timeline=content>
                **Called on:** {{GPUBindingCommandsMixin}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUBindingCommandsMixin/setBindGroup(index, bindGroup, dynamicOffsetsData, dynamicOffsetsDataStart, dynamicOffsetsDataLength)">
                    |index|: 设置绑定组的索引。
                    |bindGroup|: 绑定组以用于后续渲染或计算命令。
                    |dynamicOffsetsData|: 包含 |bindGroup| 中每个条目的缓冲区偏移量的数组（以字节为单位） 标记为 {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}}。
                    |dynamicOffsetsDataStart|: 元素中的偏移到|dynamicOffsetsData| 缓冲区偏移数据开始的地方。
                    |dynamicOffsetsDataLength|: 要从 |dynamicOffsetsData| 中读取的缓冲区偏移量的数量。
                </pre>

                **Returns:** {{undefined}}

                [=内容时间线=] 步骤：

                1. 如果以下任何要求未满足，请抛出一个 {{RangeError}} 并停止。

                    <div class=validusage>
                        - |dynamicOffsetsDataStart| 必须为 &ge; 0。
                        - |dynamicOffsetsDataStart| + |dynamicOffsetsDataLength| 必须为 &le;
                            |dynamicOffsetsData|.`length`。
                    </div>
                1. 让 |dynamicOffsets| 成为一个 [=list=]，其中包含从索引
                    |dynamicOffsetsDataStart| 开始，|dynamicOffsetsDataLength| 个元素的范围
                    [=获取缓冲区源的副本|副本=] |dynamicOffsetsData|。
                1. 调用 |this|.{{GPUBindingCommandsMixin/setBindGroup(index,
                    bindGroup, dynamicOffsets)|setBindGroup}}(|index|, |bindGroup|, |dynamicOffsets|)。
            </div>
        </div>
</dl>

<div algorithm>
    要在给定的{{GPUBindGroup}} |bindGroup|中<dfn abstract-op>遍历每个动态绑定偏移</dfn>，
    并为每个动态偏移执行一系列|steps|:


    1. 设 |dynamicOffsetIndex| 为 0。
    1. 设 |layout| 为 |bindGroup|.{{GPUBindGroup/[[layout]]}}。
    1. 对于按 |entry|.{{GPUBindGroupEntry/binding}} 的递增值排序的 |bindGroup|.{{GPUBindGroup/[[entries]]}} 中的每个 {{GPUBindGroupEntry}} |entry|: 
        1. 设 |bindingDescriptor| 为|layout|.{{GPUBindGroupLayout/[[entryMap]]}}[|entry|.{{GPUBindGroupEntry/binding}}] 的 {{GPUBindGroupLayoutEntry}}。
        1. 如果 |bindingDescriptor|.{{GPUBindGroupLayoutEntry/buffer}}? .{{GPUBufferBindingLayout/hasDynamicOffset }} 为 true：
            1. 设 |bufferBinding| 为 |entry|.{{GPUBindGroupEntry/resource}}。
            1. 设 |bufferLayout| 为 |bindingDescriptor|.{{GPUBindGroupLayoutEntry/buffer}}。
            1. 使用 |bufferBinding|、|bufferLayout| 和 |dynamicOffsetIndex| 调用 |steps|。
            1. 设 |dynamicOffsetIndex| 为 |dynamicOffsetIndex| + `1`
</div>

<div algorithm>
    <dfn abstract-op>Validate encoder bind groups</dfn>(encoder, pipeline)

    **Arguments:**

    : {{GPUBindingCommandsMixin}} |encoder|
    :: 正在验证其绑定组的编码器。
    : {{GPUPipelineBase}} |pipeline|
    :: 验证 |encoder|s 绑定组兼容的管道。

    1. 如果不满足以下任何条件，则返回 `false`：

        <div class=validusage>
            - |pipeline| 不能为空。
            - 管线使用的所有绑定组必须设置并且与管线布局兼容：
                对于|pipeline|.{{GPUPipelineBase/[[layout]]}}.{{GPUPipelineLayout/[[bindGroupLayouts]]}} 中的({{GPUIndex32}} |index|, {{GPUBindGroupLayout}} |bindGroupLayout|) 对：
                - 让 |bindGroup| 是 |encoder|.{{GPUBindingCommandsMixin/[[bind_groups]]}}[|index|]。
                - |bindGroup| 不能为空。
                - |bindGroup|.{{GPUBindGroup/[[layout]]}} 必须与 |bindGroupLayout| 群组等效。
            - 对于没有使用 {{GPUBufferBindingLayout/minBindingSize}} 预验证的缓冲区绑定，绑定范围必须足够大以容纳 [=minimum buffer binding size=]。

                问题：形式化此检查。

            - [$Encoder 绑定组别名为可写资源$](|encoder|, |pipeline|) 必须为’false’。
        </div>

    否则返回 `true`.
</div>

<div algorithm>
    <dfn abstract-op>编码器绑定组别名可写资源</dfn>（|encoder|，|pipeline|）
    如果任何可写缓冲区绑定范围与相同缓冲区的其他绑定范围重叠，
    或者任何可写纹理绑定在 [=纹理子资源=] 中与任何其他纹理绑定重叠
    （可以使用相同或不同的 {{GPUTextureView}} 对象）。

    **Arguments:**

    : {{GPUBindingCommandsMixin}} |encoder|
    :: 正在验证其绑定组的编码器。
    : {{GPUPipelineBase}} |pipeline|
    :: 验证 |encoder|s 绑定组兼容的管道。

    1. 对于[{{GPUShaderStage/VERTEX}}, {{GPUShaderStage/FRAGMENT}}, {{GPUShaderStage/COMPUTE}}]中的每个|stage|: 
        1. 设|bufferBindings|为({{GPUBufferBinding}}, `boolean`)对的[=列表=]，其中后者表示资源是否被用作可写。
        1. 设|textureViews|为（{{GPUTextureView}}，`boolean`）对的[=列表=]，其中后者表示资源是否被用作可写。
        1. 对于|pipeline|.{{GPUPipelineBase/[[layout]]}}.{{GPUPipelineLayout/[[bindGroupLayouts]]}}中的每对({{GPUIndex32}} |index|, {{GPUBindGroupLayout}} |bindGroupLayout|)：
            1. 让 |bindGroupEntries| 为 |encoder|.{{GPUBindingCommandsMixin/[[bind_groups]]}}[|index|].{{GPUBindGroupDescriptor/entries}}。
            1. 让 |bindGroupLayoutEntries| 为 |bindGroupLayout|.{{GPUBindGroupLayout/[[descriptor]]}}.{{GPUBindGroupLayoutDescriptor/entries}}。
            1. 对于 |bindGroupLayoutEntries| 中的每个 {{GPUBindGroupEntry}} |bindGroupLayoutEntry| 其中 |bindGroupLayoutEntry|.{{GPUBindGroupLayoutEntry/visibility}} 包含 |stage|: 
                1. 令 {{GPUBufferBinding}} |resource| 为 |bindGroupEntry|.{{GPUBindGroupEntry/resource}}. 1. 令 |resourceWritable| 为 (|bindGroupLayoutEntry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/type}} == {{GPUBufferBindingType/“storage”}}). 1. 对于 |bufferBindings| 中的每一对 ({{GPUBufferBinding}} |pastResource|, boolean |pastResourceWritable|)： 1. 如果 (|resourceWritable| 或 |pastResourceWritable|) 为真，并且 |pastResource| 和 |resource| 是 [=buffer-binding-aliasing=]，返回 true。 1. 将 ([|resource|], |resourceWritable|) 附加到 |bufferBindings|。

                否则，如果 |bindGroupEntry|.{{GPUBindGroupEntry/resource}} 是 {{GPUTextureView}}：

                1. 令 {{GPUTextureView}} |resource| 为 |bindGroupEntry|.{{GPUBindGroupEntry/resource}}.
                1. 令 |resourceWritable| 为 (|bindGroupLayoutEntry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/access}} == {{GPUStorageTextureAccess/"write-only"}}).
                1. 如果 |bindGroupLayoutEntry|.{{GPUBindGroupLayoutEntry/storageTexture}} 没有 [=map/exist|provided=]，则 **继续**.
                1. 对于 |textureViews| 中的每一对 ({{GPUTextureView}} |pastResource|, `boolean` |pastResourceWritable|)，
                    1. 如果 (|resourceWritable| 或 |pastResourceWritable|) 为真，并且
                        |pastResource| 和 |resource| 是 [=texture-view-aliasing=]，返回 `true`。
                1. 将 ([|resource|], |resourceWritable|) 附加到 |textureViews|。

                否则，继续。
    1. 返回 `false`。

    注：
    强烈建议实现优化此算法。
</div>

# 调试标记 # {#debug-markers}

<dfn interface> GPUDebugCommandsMixin </dfn> 提供了将调试标签应用于命令组或将单个标签插入到命令序列的方法。


调试组可以嵌套以创建标记命令的层次结构，且必须具有良好的平衡。


与 {{GPUObjectBase/label|object labels}} 一样，这些标签没有必需的行为，但可以显示在错误消息和浏览器开发者工具中，并且可以传递给本地API后端。

<script type=idl>
interface mixin GPUDebugCommandsMixin {
    undefined pushDebugGroup(USVString groupLabel);
    undefined popDebugGroup();
    undefined insertDebugMarker(USVString markerLabel);
};
</script>

{{GPUDebugCommandsMixin}}假定同一对象上具有{{GPUObjectBase}}和{{GPUCommandsMixin}}成员。它只能被那些也包含这些混入的接口引入。

{{GPUDebugCommandsMixin}}将以下内部插槽添加到包含它的接口中:

<dl dfn-type=attribute dfn-for=GPUDebugCommandsMixin>
    : <dfn>\[[debug_group_stack]]</dfn>, 类型为 [=stack=]&lt;{{USVString}}&gt;
    ::
        一个包含激活调试组标签的堆。
</dl>

{{GPUDebugCommandsMixin}} 将以下方法添加到包含它的接口中：

<dl dfn-type=method dfn-for=GPUDebugCommandsMixin>
    : <dfn>pushDebugGroup(groupLabel)</dfn>
    ::
        开始包含后续命令的标记调试组。

        <div algorithm=GPUDebugCommandsMixin.pushDebugGroup>
            <div data-timeline=content>
                **Called on:** {{GPUDebugCommandsMixin}} |this|.

                **Arguments:**

                <pre class=argumentdef for="GPUDebugCommandsMixin/pushDebugGroup(groupLabel)">
                    |groupLabel|: 命令组的标签。
                </pre>

                **Returns:** {{undefined}}

                [=内容时间线=] 步骤：

                 1. 在 |this|.{{GPUObjectBase/[[设备]]}} 的 [=设备时间线=] 上发布后续步骤。
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. 验证 |this| 的 [$编码器状态$]。如果返回 false，则停止。
                1. 将 |groupLabel| 压入 |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}}之中。
            </div>
        </div>

    : <dfn>popDebugGroup()</dfn>
    ::
        Ends the labeled debug group most recently started by {{GPUDebugCommandsMixin/pushDebugGroup()}}.

        <div algorithm=GPUDebugCommandsMixin.popDebugGroup>
            <div data-timeline=content>
                **Called on:** {{GPUDebugCommandsMixin}} |this|.

                **Returns:** {{undefined}}

                [=内容时间线=] 步骤：


                1. 在 |this|.{{GPUObjectBase/[[device]]}}的[=设备时间线=]上发布后续步骤。
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：


                1. 验证 |this| 的编码器状态[$Validate the encoder state$]。如果返回 false，则停止。
                1. 如果以下任何要求未满足，将 |this| 设为 [=invalid=]，并停止。

                    <div class=validusage>
                        - |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}} 不能为空 [=list/is empty|be empty=]。
                    </div>
                1. 从 |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}} 中[=stack/Pop=] 弹出一个条目。
            </div>
        </div>

    : <dfn>insertDebugMarker(markerLabel)</dfn>
    ::
        用标签标记命令流中的一个点。

        <div algorithm=GPUDebugCommandsMixin.insertDebugMarker>
            <div data-timeline=content>
                **Called on:** {{GPUDebugCommandsMixin}} this.

                **Arguments:**

                <pre class=argumentdef for="GPUDebugCommandsMixin/insertDebugMarker(markerLabel)">
                    markerLabel: 要插入的标签。
                </pre>

                **Returns:** {{undefined}}

                [=内容时间线=] 步骤：

                1. 在 |this|.{{GPUObjectBase/[[device]]}} 的 [=设备时间线=] 上发布后续步骤。
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. |this| 的[$验证编码器状态$]。 如果它返回 false，则停止。
            </div>
        </div>
</dl>

# 计算通道 # {#compute-passes}

<h3 id=gpucomputepassencoder data-dfn-type=interface>`GPUComputePassEncoder`
<span id=compute-pass-encoder></span>
</h3>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUComputePassEncoder {
    undefined setPipeline(GPUComputePipeline pipeline);
    undefined dispatchWorkgroups(GPUSize32 workgroupCountX, optional GPUSize32 workgroupCountY = 1, optional GPUSize32 workgroupCountZ = 1);
    undefined dispatchWorkgroupsIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);

    undefined end();
};
GPUComputePassEncoder includes GPUObjectBase;
GPUComputePassEncoder includes GPUCommandsMixin;
GPUComputePassEncoder includes GPUDebugCommandsMixin;
GPUComputePassEncoder includes GPUBindingCommandsMixin;
</script>

{{GPUComputePassEncoder}} 有以下内部槽位：

<dl dfn-type=attribute dfn-for=GPUComputePassEncoder>
    : <dfn>\[[command_encoder]]</dfn>，类型为 {{GPUCommandEncoder}}, 只读
    ::
        创建此计算传递编码器的 {{GPUCommandEncoder}} 

    : <dfn>\[[pipeline]]</dfn>，类型为 {{GPUComputePipeline}}, 只读
    ::
        当前的 {{GPUComputePipeline}}，最初为 `null`

    : <dfn>\[[endTimestampWrite]]</dfn>，类型为 [=GPU command=]?，只读，默认为 `null`
    ::
        [=GPU command=], 如果有, 在传递结束时写入一个时间戳。
</dl>

### 计算过程编码器创建 ### {#compute-pass-encoder-creation}

<script type=idl>
dictionary GPUComputePassTimestampWrites {
    required GPUQuerySet querySet;
    GPUSize32 beginningOfPassWriteIndex;
    GPUSize32 endOfPassWriteIndex;
};
</script>

<dl dfn-type=dict-member dfn-for=GPUComputePassTimestampWrites>
    : <dfn>querySet</dfn>
    ::
        {{GPUQuerySet}}，类型为{{GPUQueryType/"timestamp"}}，查询结果将写入于此。

    : <dfn>beginningOfPassWriteIndex</dfn>
    ::
        如果已定义，则指示{{GPURenderPassTimestampWrites/querySet}}中的查询索引，计算过程开始时的时间戳将写入该索引。

    : <dfn>endOfPassWriteIndex</dfn>
    ::
        如果已定义，则指示{{GPURenderPassTimestampWrites/querySet}} 中的查询索引，计算过程结束时的时间戳将写入该索引。
</dl>

<script type=idl>
dictionary GPUComputePassDescriptor
         : GPUObjectDescriptorBase {
    GPUComputePassTimestampWrites timestampWrites;
};
</script>

<dl dfn-type=dict-member dfn-for=GPUComputePassDescriptor>
    : <dfn>timestampWrites</dfn>
    ::
        定义将为此过程写入哪些时间戳值，以及将它们写入到何处。
</dl>

### 调度 ### {#compute-pass-encoder-dispatch}

<dl dfn-type=method dfn-for=GPUComputePassEncoder>
    : <dfn>setPipeline(管道)</dfn>
    ::
        设置当前{{GPUComputePipeline}}.

        <div algorithm=GPUComputePassEncoder.setPipeline>
            <div data-timeline=content>
                **调用：** {{GPUComputePassEncoder}} this.

                **参数：**

                <pre class=argumentdef for="GPUComputePassEncoder/setPipeline(pipeline)">
                    |pipeline|: 用于后续调度命令的计算管道。
                </pre>

                **Returns:** {{undefined}}

                [=内容时间线=] 步骤：

                1. 在 [=设备时间轴=] 上发布后续步骤。{{GPUObjectBase/[[device]]}}.
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. [$验证此的编码器状态$] 如果返回false，请停止。
                1. 如果不满足以下任何条件，则使 |this| [=无效=] 并停止。

                    <div class=validusage>
                        - |pipeline| 与此一起使用 [$是有效的$] 。
                    </div>
                1. 设置 |this|.{{GPUComputePassEncoder/[[pipeline]]}} 为 |管道|。
            </div>
        </div>

    : <dfn>dispatchWorkgroups(workgroupCountX, workgroupCountY, workgroupCountZ)</dfn>
    ::
        要使用当前 {{GPUComputePipeline}}。
        详情参见 [[#computing-operations]] 。

        <div algorithm=GPUComputePassEncoder.dispatch>
            <div data-timeline=content>
                **调用：** {{GPUComputePassEncoder}} this.

                **参数：**

                <pre class=argumentdef for="GPUComputePassEncoder/dispatchWorkgroups(workgroupCountX, workgroupCountY, workgroupCountZ)">
                    |workgroupCountX|: 要调度的工作组网格的X维度。
                    |workgroupCountY|: 要调度的工作组网格的Y维度。
                    |workgroupCountZ|: 要调度的工作组网格的Z维度。
                </pre>

                <div class=note>
                    注意：
                    传递给 {{GPUComputePassEncoder/dispatchWorkgroups()}}
                    和 {{GPUComputePassEncoder/dispatchWorkgroupsIndirect()}} 的 `x`， `y`和 `z` 值是要为每个维度调度的工作组数， *而不是* 而不是要在每个维度上执行的着色器调用数。这与现代原生GPU API的行为相匹配，但与OpenCL的行为不同。
                    这意味着，如果一个 {{GPUShaderModule}} 用
                    `@workgroup_size(4, 4)`定义了一个入口点，并且通过调用
                    `computePass.dispatchWorkgroups(8, 8);` 将工作分派给它；
                    入口点将被调用1024次：沿X轴和Y轴调度4x4工作组8次。
                </div>

                **返回：** {{未定义}}

                [=内容时间线=] 步骤：

                1. 在 [=设备时间轴=] 上发布后续步骤。{{GPUObjectBase/[[device]]}}.
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. [$验证此的编码器状态$] 。如果返回false，请停止。
                1. 如果不满足以下任何条件，则使 |this| [=无效=] 并停止。

                    <div class=validusage>
                        - [$验证编码器绑定组$](|this|, |this|.{{GPUComputePassEncoder/[[pipeline]]}})
                            是否为 `true`.
                        - 所有 |workgroupCountX|, |workgroupCountY| and |workgroupCountZ| 均 &le;
                            |this|.device.limits.{{supported limits/maxComputeWorkgroupsPerDimension}}.
                    </div>

                1. 将 |passState| 作为INDIRECT添加到使用范围中。
                1. 对此[$执行一个命令$] ，该命令将在
                    [=队列时间线=]上发出后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤：

                1. 使用 |passState|执行维度为 [|workgroupCountX|, |workgroupCountY|,
                    |workgroupCountZ|] .{{GPUComputePassEncoder/[[pipeline]]}} using
                    |passState|的工作组网格。{{GPUBindingCommandsMixin/[[bind_groups]]}}.
            </div>
        </div>

    : <dfn>dispatchWorkgroupsIndirect(indirectBuffer, indirectOffset)</dfn>
    ::
        使用从 {{GPUBuffer}}读取的参数，使用当前 {{GPUComputePipeline}} 执行调度工作。
        详情参见 [[#computing-operations]] 。

         <dfn dfn for="">缓冲区中编码的间接调度参数必须是一个由 **三个32位无符号整数值（总共12个字节）**,
        组成的紧密压缩块，其顺序与 {{GPUComputePassEncoder/dispatchWorkgroups()}}的参数相同。
        例如：

        <pre highlight=js>
            let dispatchIndirectParameters = new Uint32Array(3);
            dispatchIndirectParameters[0] = workgroupCountX;
            dispatchIndirectParameters[1] = workgroupCountY;
            dispatchIndirectParameters[2] = workgroupCountZ;
        </pre>

        <div algorithm=GPUComputePassEncoder.dispatchIndirect>
            <div data-timeline=content>
                **调用：** {{GPUComputePassEncoder}} this.

                **参数：**

                <pre class=argumentdef for="GPUComputePassEncoder/dispatchWorkgroupsIndirect(indirectBuffer, indirectOffset)">
                    |indirectBuffer|: 包含 [=间接调度参数=]的缓冲区。
                    |indirectOffset|: 以字节为单位偏移到调度数据开始的 |indirectBuffer| 。
                </pre>

                **返回：** {{undefined}}

                [=内容时间线=] 步骤：

                1. 在 [=设备时间轴=] 上发布后续步骤。
                    {{GPUObjectBase/[[device]]}}.
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. [$验证此的编码器状态$] 。如果返回false，请停止。
                1. 如果不满足以下任何条件，则使 |this| [=无效=] 并停止。

                    <div class=validusage>
                        - [$验证编码器绑定组$](|this|, |this|.{{GPUComputePassEncoder/[[pipeline]]}})
                            是否为 `true`。
                        - |indirectBuffer| [$与此一起使用是有效的$] 。
                        - |indirectBuffer|.{{GPUBuffer/usage}} 包含 {{GPUBufferUsage/INDIRECT}}.
                        - |indirectOffset| + sizeof([=indirect dispatch parameters=]) &le;
                            |indirectBuffer|.{{GPUBuffer/size}}.
                        - |indirectOffset| 是4的倍数。
                    </div>
                1. 将 |indirectBuffer|添加到 [=使用范围=] 中作为 {{GPUBufferUsage/INDIRECT}}.

                1. 让 |passState| 成为当前状态的快照。
                1. 对此[$执行一个命令$] ，该命令将在[=队列时间线=]上发出后续步骤。  
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤：

                1. 让 |workgroupCountX| 是一个从 |indirectBuffer| 读取的32位无符号整数，位于
                    |indirectOffset| 字节。
                1. 让 |workgroupCountY| 是一个无符号的32位整数，从 |indirectBuffer| 读取
                    (|indirectOffset| + 4) 字节。
                1. 让 |workgroupCountZ| 是一个无符号的32位整数，从 |indirectBuffer| 读取
                    (|indirectOffset| + 8) 字节。
                1. 如果 |workgroupCountX|, |workgroupCountY|, or |workgroupCountZ| 大于
                    |this|.device.limits.{{supported limits/maxComputeWorkgroupsPerDimension}}，请停止。
                1. 使用 |passState|执行维度为 [|workgroupCountX|, |workgroupCountY|,
                    |workgroupCountZ|] 的工作组网格。{{GPUComputePassEncoder/[[pipeline]]}} 使用
                    |passState|.{{GPUBindingCommandsMixin/[[bind_groups]]}}.
            </div>
        </div>
</dl>

### 最终确定 ### {#compute-pass-encoder-finalization}

一旦用户完成了对过程的命令记录，就可以通过调用 {{GPUComputePassEncoder/end()}} 来
结束计算过程编码器。一旦调用了 {{GPUComputePassEncoder/end()}} ，就不能再使用计算过程编码器了。

<dl dfn-type=method dfn-for=GPUComputePassEncoder>
    : <dfn>end()</dfn>
    ::
        完成计算过程命令序列的记录。

        <div algorithm=GPUComputePassEncoder.end>
            <div data-timeline=content>
                **调用：** {{GPUComputePassEncoder}} |this|.

                **返回：** {{undefined}}

                [=内容时间线=] 步骤：

                1. 在设备时间轴上发布后续步骤。{{GPUObjectBase/[[device]]}}.
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. 让 |parentEncoder| 是 |this|.{{GPURenderPassEncoder/[[command_encoder]]}}.
                1. 如果以下任何要求未得到满足，则
                    [$生成一个验证错误$] 并停止。

                    <div class=validusage>
                        - |this|.{{GPUCommandsMixin/[[state]]}} 必须为 "[=encoder state/open=]".
                        - |parentEncoder|.{{GPUCommandsMixin/[[state]]}} 必须 "[=encoder state/locked=]".
                    </div>
                1. 设置 |this|.{{GPUCommandsMixin/[[state]]}} 改为 "[=encoder state/ended=]".
                1. 设置 |parentEncoder|.{{GPUCommandsMixin/[[state]]}} 变为 "[=encoder state/open=]".
                1. 如果未满足以下任何要求，请使
                    |parentEncoder| [=无效=] 并停止。

                    <div class=validusage>
                        - |this| 必须是 [=有效=]。
                        - |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}} 必须 [=list/is empty|be empty=].
                    </div>
                1. [=list/Extend=] |parentEncoder|.{{GPUCommandsMixin/[[commands]]}}
                    with |this|.{{GPUCommandsMixin/[[commands]]}}.
                1. 如果 |this|.{{GPUComputePassEncoder/[[endTimestampWrite]]}} 不为 `null`:
                    1. [=list/Extend=] |parentEncoder|.{{GPUCommandsMixin/[[commands]]}}
                        with |this|.{{GPUComputePassEncoder/[[endTimestampWrite]]}}.
            </div>
        </div>
</dl>

# 渲染过程 # {#render-passes}

<h3 id=gpurenderpassencoder data-dfn-type=interface>`GPURenderPassEncoder`
<span id=render-pass-encoder></span>
</h3>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderPassEncoder {
    undefined setViewport(float x, float y,
        float width, float height,
        float minDepth, float maxDepth);

    undefined setScissorRect(GPUIntegerCoordinate x, GPUIntegerCoordinate y,
                        GPUIntegerCoordinate width, GPUIntegerCoordinate height);

    undefined setBlendConstant(GPUColor color);
    undefined setStencilReference(GPUStencilValue reference);

    undefined beginOcclusionQuery(GPUSize32 queryIndex);
    undefined endOcclusionQuery();

    undefined executeBundles(sequence<GPURenderBundle> bundles);
    undefined end();
};
GPURenderPassEncoder includes GPUObjectBase;
GPURenderPassEncoder includes GPUCommandsMixin;
GPURenderPassEncoder includes GPUDebugCommandsMixin;
GPURenderPassEncoder includes GPUBindingCommandsMixin;
GPURenderPassEncoder includes GPURenderCommandsMixin;
</script>

{{GPURenderPassEncoder}} 具有以下内部插槽，用于在编码时进行验证：

<dl dfn-type=attribute dfn-for=GPURenderPassEncoder>
    : <dfn>\[[command_encoder]]</dfn>，类型为 {{GPUCommandEncoder}}，只读
    ::
        创建此渲染过程编码器的{{GPUCommandEncoder}} 。

    : <dfn>\[[attachment_size]]</dfn>，只读
    ::
        设置为以下范围：

        - `width, height` = 过程渲染附件的尺寸

    : <dfn>\[[occlusion_query_set]]</dfn>，类型为 {{GPUQuerySet}}，只读
    ::
        用于存储过程的遮挡查询结果的 {{GPUQuerySet}} ，该过程在过程创建时使用
        {{GPURenderPassDescriptor}}.{{GPURenderPassDescriptor/occlusionQuerySet}} 初始化。

    : <dfn>\[[occlusion_query_active]]</dfn>，类型为 {{boolean}}
    ::
        是否正在写入过程的 {{GPURenderPassEncoder/[[occlusion_query_set]]}} 。

    : <dfn>\[[endTimestampWrite]]</dfn>，类型为 [=GPU command=]?，只读，默认为 `null`
    ::
        [=GPU command=]（如果有），在过程结束时写入时间戳。

    : <dfn>\[[maxDrawCount]]</dfn> 类型为 {{GPUSize64}}，只读
    ::
        此过程中允许的最大平局次数。
</dl>

当作为 {{GPUCommandBuffer}}的一部分执行编码的渲染过程命令时，内部
<dfn dfn>RenderState</dfn> 对象用于跟踪渲染所需的当前状态。

[=RenderState=] 包含以下用于执行渲染命令的内部插槽：

<dl dfn-type=attribute dfn-for=RenderState>
    : <dfn>\[[occlusionQueryIndex]]</dfn>，类型为 {{GPUSize32}}
    ::
        存储遮挡查询结果的 {{GPURenderPassEncoder/[[occlusion_query_set]]}} 索引。

    : <dfn>\[[viewport]]</dfn>
    ::  当前视口矩形和深度范围。最初设置为以下值：
        - `x, y` = `0.0, 0.0`
        - `width, height` = 过程渲染目标的尺寸
        - `minDepth, maxDepth` = `0.0, 1.0`

    : <dfn>\[[scissorRect]]</dfn>
    ::  当前剪刀形矩形。最初设置为以下值：
        - `x, y` = `0, 0`
        - `width, height` = 过程渲染目标的尺寸

    : <dfn>\[[blendConstant]]</dfn>,，类型为 {{GPUColor}}
    ::  当前混合常数值，最初为 `[0, 0, 0, 0]`。

    : <dfn>\[[stencilReference]]</dfn>，类型为 {{GPUStencilValue}}
    ::  当前模具引用值，最初为 `0`。
</dl>

### 渲染过程编码器创建 ### {#render-pass-encoder-creation}

<script type=idl>
dictionary GPURenderPassTimestampWrites {
    required GPUQuerySet querySet;
    GPUSize32 beginningOfPassWriteIndex;
    GPUSize32 endOfPassWriteIndex;
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassTimestampWrites>
    : <dfn>querySet</dfn>
    ::
        {{GPUQuerySet}}，类型为 {{GPUQueryType/"timestamp"}}查询结果将写入于此。

    : <dfn>beginningOfPassWriteIndex</dfn>
    ::
        如果已定义，则指示 {{GPURenderPassTimestampWrites/querySet}} 中的查询索引，渲染过程开始时的时间戳将写入该索引。

    : <dfn>endOfPassWriteIndex</dfn>
    ::
        如果已定义，则指示 {{GPURenderPassTimestampWrites/querySet}} 中的查询索引，渲染过程结束时的时间戳将写入该索引。
</dl>

<script type=idl>
dictionary GPURenderPassDescriptor
         : GPUObjectDescriptorBase {
    required sequence<GPURenderPassColorAttachment?> colorAttachments;
    GPURenderPassDepthStencilAttachment depthStencilAttachment;
    GPUQuerySet occlusionQuerySet;
    GPURenderPassTimestampWrites timestampWrites;
    GPUSize64 maxDrawCount = 50000000;
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassDescriptor>
    : <dfn>colorAttachments</dfn>
    ::
        此序列中的一组 {{GPURenderPassColorAttachment}} 值定义了执行此渲染过程时将输出到哪些颜色附件。

        由于 [=使用兼容性=]的原因，任何颜色附件都不能别名其他附件或渲染过程中使用的任何资源。

    : <dfn>depthStencilAttachment</dfn>
    ::
        {{GPURenderPassDepthStencilAttachment}} 值，用于定义执行此渲染过程时将输出到并测试的深度/模具附件。

        由于 [=使用兼容性=]，任何可写的深度/模具附件都不能别名为另一个附件或渲染过程中使用的任何资源。

    : <dfn>occlusionQuerySet</dfn>
    ::
        、{{GPUQuerySet}} 值定义了此过程的遮挡查询结果的存储位置。

    : <dfn>timestampWrites</dfn>
    ::
        定义将为此过程写入哪些时间戳值，以及将它们写入到何处。

    : <dfn>maxDrawCount</dfn>
    ::
        将在渲染过程中执行的最大绘制调用数。某些实现用于调整渲染过程之前注入的工作的大小。保持默认值是一个很好的默认值，除非已知将执行更多的绘制调用。
</dl>

<div algorithm class=validusage dfn-for=GPURenderPassDescriptor data-timeline=device>
    <dfn abstract-op>有效用途</dfn>

    给定 {{GPUDevice}} |device| 和 {{GPURenderPassDescriptor}} |this|，以下验证规则适用：

    1. |this|.{{GPURenderPassDescriptor/colorAttachments}}.length 必须 &le;
        |device|.{{device/[[limits]]}}.{{supported limits/maxColorAttachments}}.

    1. 对于每个非空 |colorAttachment| {{GPURenderPassDescriptor/colorAttachments}}:

        1. |colorAttachment| 必须符合 [$GPURenderPassColorAttachment/GPURenderPassColorAttachment Valid Usage$] 规则。

    1. 如果 |this|.{{GPURenderPassDescriptor/depthStencilAttachment}} 是 [=map/exist|provided=]:

        1. |this|.{{GPURenderPassDescriptor/depthStencilAttachment}} 必须符合 [$GPURenderPassDepthStencilAttachment/GPURenderPassDepthStencilAttachment Valid Usage$] 规则。

    1. 必须至少存在一个附件，或者：
        - 、|this|.{{GPURenderPassDescriptor/colorAttachments}}中的非null值，或
        - 、|this|.{{GPURenderPassDescriptor/depthStencilAttachment}}.

    1. [$验证 GPURenderPassDescriptor的每个样本的颜色附件字节数$](|device|, |this|.{{GPURenderPassDescriptor/colorAttachments}}) 成功。

    1. 所有 {{GPURenderPassColorAttachment/view}}的非null成员{{GPURenderPassDescriptor/colorAttachments}},
        和 |this|.{{GPURenderPassDescriptor/depthStencilAttachment}}.{{GPURenderPassDepthStencilAttachment/view}}
        必须具有相等的 {{GPUTexture/sampleCount}}s.

    1. 对于 {{GPURenderPassColorAttachment/view}} 的非null成员。{{GPURenderPassDescriptor/colorAttachments}}
        和 |this|.{{GPURenderPassDescriptor/depthStencilAttachment}}.{{GPURenderPassDepthStencilAttachment/view}},
        如果存在，则 {{GPUTextureView/[[renderExtent]]}} 必须匹配。

    1. 如果 |this|.{{GPURenderPassDescriptor/occlusionQuerySet}} 不为 `null`:

        1. |this|.{{GPURenderPassDescriptor/occlusionQuerySet}}.{{GPUQuerySet/type}}
            必须是 {{GPUQueryType/occlusion}}.

    1. 如果 |this|.{{GPURenderPassDescriptor/timestampWrites}} 是 [=map/exist|provided=]:
        - [$Validate timestampWrites$](|device|, |this|.{{GPURenderPassDescriptor/timestampWrites}})
            必须返回 true。
</div>

<div algorithm>
    <dfn abstract-op>验证 GPURenderPassDescriptor的每个样本的颜色附件字节数、</dfn>({{GPUDevice}} |device|, [=sequence=]&lt;{{GPURenderPassColorAttachment}}?&gt; |colorAttachments|)

    1. 让 |formats| 为空 [=列表=]&lt;{{GPUTextureFormat}}?&gt;
    1. 对于每种 |colorAttachment| 在 |colorAttachments|:
        1. 如果 |colorAttachment| 是 `undefined`，请继续。
        1. [=list/Append=] |colorAttachment|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}} 到 |formats|.
    1. [$计算每个样本$](|formats|) 的颜色附件字节数必须 &le; |device|.{{device/[[limits]]}}.{{supported limits/maxColorAttachmentBytesPerSample}}.
</div>

#### 颜色附件 #### {#color-attachments}

<script type=idl>
dictionary GPURenderPassColorAttachment {
    required GPUTextureView view;
    GPUTextureView resolveTarget;

    GPUColor clearValue;
    required GPULoadOp loadOp;
    required GPUStoreOp storeOp;
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassColorAttachment>
    : <dfn>view</dfn>
    ::
        描述将为此颜色附件输出到的[=纹理子资源=]的{{GPUTextureView}} 。

    : <dfn>resolveTarget</dfn>
    ::
        描述[=纹理子资源=]的{{GPUTextureView}} ，如果{{GPURenderPassColorAttachment/view}}是多采样的，该纹理子资源将接收此颜色附件的解析输出。

    : <dfn>clearValue</dfn>
    ::
        指示在执行渲染过程之前要清除{{GPURenderPassColorAttachment/view}} 的值。
        如果未 [=map/exist|provided=]，则默认为 `{r: 0, g: 0, b: 0, a: 0}`。如果 {{GPURenderPassColorAttachment/loadOp}} 未 {{GPULoadOp/"clear"}}，则忽略。

        {{GPURenderPassColorAttachment/clearValue}}的组成部分都是双值。 
        它们将转换为。 [$与渲染附件匹配的纹理格式的texel值$] ，
        如果转换失败，将生成验证错误。

    : <dfn>loadOp</dfn>
    ::
        指示在执行渲染过程之前要对 {{GPURenderPassColorAttachment/view}} 执行的加载操作。

        注意：建议首选清除；有关详细信息，请参见 {{GPULoadOp/"clear"}} 。

    : <dfn>storeOp</dfn>
    ::
        在执行渲染过程之后要对 {{GPURenderPassColorAttachment/view}}
        执行的存储操作。
</dl>

<div class=validusage dfn-for=GPURenderPassColorAttachment data-timeline=device>
    <dfn abstract-op>GPURenderPassColorAttachment 有效用法</dfn>

    给定 {{GPURenderPassColorAttachment}} |this|:

    1. 让 |renderViewDescriptor| 是 |this|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[descriptor]]}}.
    1. 让 |resolveViewDescriptor| 是 |this|.{{GPURenderPassColorAttachment/resolveTarget}}.{{GPUTextureView/[[descriptor]]}}.
    1. 让 |renderTexture| 是 |this|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[texture]]}}.
    1. 让 |resolveTexture| 是 |this|.{{GPURenderPassColorAttachment/resolveTarget}}.{{GPUTextureView/[[texture]]}}.

    以下验证规则适用：

    - |renderViewDescriptor|.{{GPUTextureViewDescriptor/format}} 必须是 [=彩色可渲染格式=]。
    - |this|.{{GPURenderPassColorAttachment/view}} 必须是 [$可渲染的纹理视图$]。
    - 如果 |this|.{{GPURenderPassColorAttachment/loadOp}} 是 {{GPULoadOp/"clear"}}:
        - 将IDL值t |this|.{{GPURenderPassColorAttachment/clearValue}}
            [$转换为纹理格式$] |renderViewDescriptor|.{{GPUTextureViewDescriptor/format}}
            不得引发 {{TypeError}}。

            注意：如果值超出格式的范围，但在相应的WGSL基元类型 (`f32`, `i32`, 或 `u32`)的范围内，则不会引发错误。
    - 如果 |this|.{{GPURenderPassColorAttachment/resolveTarget}} [=map/exist|provided=]:
        - |renderTexture|.{{GPUTexture/sampleCount}} 必须 &gt; 1.
        - |resolveTexture|.{{GPUTexture/sampleCount}} 必须为 1.
        - |this|.{{GPURenderPassColorAttachment/resolveTarget}} 必须是 [$可渲染的纹理视图$].
        - |this|.{{GPURenderPassColorAttachment/resolveTarget}}
            和 |this|.{{GPURenderPassColorAttachment/view}}看到的 [=子资源=]的大小必须匹配。
        - |resolveViewDescriptor|.{{GPUTextureViewDescriptor/format}} 必须等于
            |renderViewDescriptor|.{{GPUTextureViewDescriptor/format}}.
        - |resolveTexture|.{{GPUTextureDescriptor/format}} 必须等于
            |renderTexture|.{{GPUTextureDescriptor/format}}.
        - |resolveViewDescriptor|.{{GPUTextureViewDescriptor/format}} 必须支持根据 [[#plain-color-formats]]进行解析。
</div>

<div algorithm>
    如果满足以下要求，则 {{GPUTextureView}} |view| 是 <dfn abstract-op>renderable texture view</dfn>：

    - |view|.{{GPUTextureView/[[texture]]}}.{{GPUTexture/usage}}
        必须包含 {{GPUTextureUsage/RENDER_ATTACHMENT}}.
    - |descriptor|.{{GPUTextureViewDescriptor/dimension}} 必须是 {{GPUTextureViewDimension/"2d"}}.
    - |descriptor|.{{GPUTextureViewDescriptor/mipLevelCount}} 必须是 1.
    - |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须是 1.
    - |descriptor|.{{GPUTextureViewDescriptor/aspect}} 必须引用|view|.{{GPUTextureView/[[texture]]}}的所有 [=方面=] 。

    其中 |descriptor| 是 |view|.{{GPUTextureView/[[descriptor]]}}.
</div>

<div algorithm>
    <dfn abstract-op>计算每个样本的颜色附件字节数</dfn>(|formats|)

    **参数：**

    - [=序列=]&lt;{{GPUTextureFormat}}?&gt; |formats|

    **返回：** {{GPUSize32}}

    1. 让 |total| 为 0.
    1. 对于|formats|中的每个非空|format|
        1. [=Assert=]: |format| 是一种 [=颜色可渲染的格式=]。
        1. 让 |renderTargetPixelByteCost| 是|format|的 [=渲染目标像素字节成本=] 。
        1. 让 |renderTargetComponentAlignment| 是|format|的 [=渲染目标组件对齐方式=] 。
        1. 将 |total| 四舍五入到 |renderTargetComponentAlignment| 的最小倍数，该倍数大于或等于 |total|。
        1. 将 |renderTargetPixelByteCost| 添加到 |total|。
    1. 返回 |total|。

</div>

#### 深度/模板附件 #### {#depth-stencil-attachments}

<script type=idl>
dictionary GPURenderPassDepthStencilAttachment {
    required GPUTextureView view;

    float depthClearValue;
    GPULoadOp depthLoadOp;
    GPUStoreOp depthStoreOp;
    boolean depthReadOnly = false;

    GPUStencilValue stencilClearValue = 0;
    GPULoadOp stencilLoadOp;
    GPUStoreOp stencilStoreOp;
    boolean stencilReadOnly = false;
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassDepthStencilAttachment>
    : <dfn>view</dfn>
    ::
        {{GPUTextureView}} ，描述将为此深度/模具附件输出和读取的纹理[=子源=] 。

    : <dfn>depthClearValue</dfn>
    ::
        指示在执行渲染过程之前清除 {{GPURenderPassDepthStencilAttachment/view}}的深度组件的值。
        如果 {{GPURenderPassDepthStencilAttachment/depthLoadOp}}
        不是 {{GPULoadOp/"clear"}}，则忽略。必须介于0.0和1.0之间（包括0.0和1.0）。
        <!-- POSTV1(unrestricted-depth): unless unrestricted depth is enabled -->

    : <dfn>depthLoadOp</dfn>
    ::
        指示在执行渲染过程之前要对 {{GPURenderPassDepthStencilAttachment/view}}的深度组件执行的加载操作。

        注意：建议首选清除；有关详细信息，请参见 {{GPULoadOp/"clear"}} for details.

    : <dfn>depthStoreOp</dfn>
    ::
        在执行渲染过程之后对 {{GPURenderPassDepthStencilAttachment/view}}的深度组件执行的存储操作。

    : <dfn>depthReadOnly</dfn>
    ::
        指示 {{GPURenderPassDepthStencilAttachment/view}}
        的深度组件是只读的。

    : <dfn>stencilClearValue</dfn>
    ::
        指示在执行渲染过程之前清除 {{GPURenderPassDepthStencilAttachment/view}}的模具组件的值。如果 {{GPURenderPassDepthStencilAttachment/stencilLoadOp}}
        未 {{GPULoadOp/"clear"}}，则忽略该值。

        该值将通过采用与一个纹素 |view| 的模版方面中的位数相同的LSB数量来转换为 |view|的模版方面的类型。

    : <dfn>stencilLoadOp</dfn>
    ::
        指示在执行渲染过程之前要对 {{GPURenderPassDepthStencilAttachment/view}}的模具组件执行的加载操作。

        注意：建议首选清除；有关详细信息，请参见 {{GPULoadOp/"clear"}} for details.

    : <dfn>stencilStoreOp</dfn>
    ::
        在执行渲染过程后对 {{GPURenderPassDepthStencilAttachment/view}}的模具组件执行的存储操作。

    : <dfn>stencilReadOnly</dfn>
    ::
        指示 {{GPURenderPassDepthStencilAttachment/view}}
        的模具组件是只读的。
</dl>

<div class=validusage dfn-for=GPURenderPassDepthStencilAttachment>
    <dfn abstract-op>GPURenderPassDepthStencilAttachment 有效用法</dfn>

    给定 {{GPURenderPassDepthStencilAttachment}} |this|，以下验证规则适用：

    - |this|.{{GPURenderPassDepthStencilAttachment/view}} 必须具有 [=深度或模具格式=].
    - |this|.{{GPURenderPassDepthStencilAttachment/view}} 必须是 [$可渲染的纹理视图$].
    - 让 |format| 是 |this|.{{GPURenderPassDepthStencilAttachment/view}}.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}}.
    - 如果 |this|.{{GPURenderPassDepthStencilAttachment/depthLoadOp}} is {{GPULoadOp/"clear"}},
        |this|.{{GPURenderPassDepthStencilAttachment/depthClearValue}} 必须 [=map/exist|be provided=] ，并且必须介于0.0和1.0之间（包括0.0和1.0）。
        <!-- POSTV1(unrestricted-depth): unless unrestricted depth is enabled -->
    - 如果 |format| 是 [=组合深度模具格式=]:
        - |this|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}} 必须等于 |this|.{{GPURenderPassDepthStencilAttachment/stencilReadOnly}}
    - 如果 |format| 有深度方面，而 |this|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}} 不为 `true`:
        - |this|.{{GPURenderPassDepthStencilAttachment/depthLoadOp}} 必须 [=map/exist|be provided=].
        - |this|.{{GPURenderPassDepthStencilAttachment/depthStoreOp}} 必须 [=map/exist|be provided=].

        否则:

        - |this|.{{GPURenderPassDepthStencilAttachment/depthLoadOp}} 不得 [=map/exist|be provided=].
        - |this|.{{GPURenderPassDepthStencilAttachment/depthStoreOp}} 不得 [=map/exist|be provided=].
    - 如果 |format| 具有模具方面，并且 |this|.{{GPURenderPassDepthStencilAttachment/stencilReadOnly}} 不为 `true`:
        - |this|.{{GPURenderPassDepthStencilAttachment/stencilLoadOp}} 必须 [=map/exist|be provided=].
        - |this|.{{GPURenderPassDepthStencilAttachment/stencilStoreOp}} 必须 [=map/exist|be provided=].

        否则:

        - |this|.{{GPURenderPassDepthStencilAttachment/stencilLoadOp}} 不得 [=map/exist|be provided=].
        - |this|.{{GPURenderPassDepthStencilAttachment/stencilStoreOp}} 不得 [=map/exist|be provided=].
</div>

#### 装载和储存操作 #### {#load-and-store-ops}

<script type=idl>
enum GPULoadOp {
    "load",
    "clear",
};
</script>

<dl dfn-type=enum-value dfn-for=GPULoadOp>
    : <dfn>"load"</dfn>
    ::
        将此附件的现有值加载到渲染过程中。

    : <dfn>"clear"</dfn>
    ::
        将此附件的清除值加载到渲染过程中。

        注意：
        在一些GPU硬件（主要是移动设备）上， {{GPULoadOp/"clear"}} 要便宜得多，
        因为它可以避免将数据从主内存加载到瓦片本地内存。
        在其他GPU硬件上，没有显著差异。 因此，在初始值无关紧要的情况下
        （例如，渲染目标将使用skybox清除），建议使用 {{GPULoadOp/"clear"}} 而不是 {{GPULoadOp/"load"}} 。
</dl>

<script type=idl>
enum GPUStoreOp {
    "store",
    "discard",
};
</script>

<dl dfn-type=enum-value dfn-for=GPUStoreOp>
    : <dfn>"store"</dfn>
    ::
        存储此附件的渲染过程的结果值。

    : <dfn>"discard"</dfn>
    ::
        丢弃此附件的渲染过程的结果值。
</dl>


#### 渲染通道布局 #### {#render-pass-layout}

{{GPURenderPassLayout}} 声明 {{GPURenderBundle}}.
的渲染目标的布局。它也在内部用于描述
{{GPURenderPassEncoder}} 布局和
{{GPURenderPipeline}} 布局。它确定渲染过程、渲染束和渲染管道之间的兼容性。

<script type=idl>
dictionary GPURenderPassLayout
         : GPUObjectDescriptorBase {
    required sequence<GPUTextureFormat?> colorFormats;
    GPUTextureFormat depthStencilFormat;
    GPUSize32 sampleCount = 1;
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassLayout>
    : <dfn>colorFormats</dfn>
    ::
        此过程或捆绑包的颜色附件的 {{GPUTextureFormat}}列表。

    : <dfn>depthStencilFormat</dfn>
    ::
        此通道或束的深度/模板附件的{{GPUTextureFormat}} 。

    : <dfn>sampleCount</dfn>
    ::
        此过程或束的附件中每个像素的样本数。
</dl>

<div algorithm=gpurenderpasslayout-equal>
    以下情况下，两个 {{GPURenderPassLayout}} 值 <dfn dfn for="render pass layout" lt="equals|equal">equal</dfn> ：

    - 它们的 {{GPURenderPassLayout/depthStencilFormat}} 和 {{GPURenderPassLayout/sampleCount}} 相等，并且
    - 它们的 {{GPURenderPassLayout/colorFormats}} 是相等的，忽略任何尾随的 `null`。
</div>

<div algorithm>
    <dfn abstract-op>从过程派生渲染目标布局</dfn>

    **参数：**

    - {{GPURenderPassDescriptor}} |descriptor|

    **返回：** {{GPURenderPassLayout}}

    1. 让 |layout| 成为一个新的 {{GPURenderPassLayout}} 对象。
    1. 对于 |descriptor|.{{GPURenderPassDescriptor/colorAttachments}} 中的每种|colorAttachment| ：
        1. 如果 |colorAttachment| 不为 `null`:
            1. 将 |colorAttachment|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[texture]]}}.{{GPUTexture/sampleCount}}设置为 |layout|.{{GPURenderPassLayout/sampleCount}} 
            1. 附加 |colorAttachment|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}} 到 |layout|.{{GPURenderPassLayout/colorFormats}}.
        1. 否则：
            1. 附加 `null` 到 |layout|.{{GPURenderPassLayout/colorFormats}}.
    1. 让 |depthStencilAttachment| 为 |descriptor|.{{GPURenderPassDescriptor/depthStencilAttachment}},
        或者为 `null` 如果未 [=map/exist|provided=]。
    1. 如果 |depthStencilAttachment| 不为 `null`:
        1. 让 |view| 为 |depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/view}}.
        1. 设置 |layout|.{{GPURenderPassLayout/sampleCount}} 为 |view|.{{GPUTextureView/[[texture]]}}.{{GPUTexture/sampleCount}}.
        1. 设置 |layout|.{{GPURenderPassLayout/depthStencilFormat}} 为 |view|.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}}.
    1. 返回 |layout|.
</div>

<div algorithm>
    <dfn abstract-op>从管道派生渲染目标布局</dfn>

    **参数**

    - {{GPURenderPipelineDescriptor}} |descriptor|

    **返回：** {{GPURenderPassLayout}}

    1. 让 |layout| 成为一个新的 {{GPURenderPassLayout}} 对象。
    1. 设置 |layout|.{{GPURenderPassLayout/sampleCount}} 为 |descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}}.
    1. 如果 |descriptor|.{{GPURenderPipelineDescriptor/depthStencil}} 是 [=map/exist|provided=]:
        1. 设置 |layout|.{{GPURenderPassLayout/depthStencilFormat}} 设置 |descriptor|.{{GPURenderPipelineDescriptor/depthStencil}}.{{GPUDepthStencilState/format}}.
    1. 如果 |descriptor|.{{GPURenderPipelineDescriptor/fragment}} 是 [=map/exist|provided=]:
        1.  对于 |descriptor|.{{GPURenderPipelineDescriptor/fragment}}.{{GPUFragmentState/targets}}中的每种 |colorTarget|:
            1. 附加 |colorTarget|.{{GPUColorTargetState/format}} 到 |layout|.{{GPURenderPassLayout/colorFormats}}
                如果 |colorTarget| 不为 `null`，否则附加 `null` 。
    1. 返回 |layout|.
</div>

### 最终确定 ### {#render-pass-encoder-finalization}

一旦用户完成对过程的命令录制，就可以通过调用 {{GPURenderPassEncoder/end()}} 
来结束渲染过程编码器。一旦调用了 {{GPURenderPassEncoder/end()}} ，就不能再使用渲染过程编码器了。

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>end()</dfn>
    ::
        完成渲染过程命令序列的记录。

        <div algorithm=GPURenderPassEncoder.end>
            <div data-timeline=content>
                **调用:** {{GPURenderPassEncoder}} |this|.

                **返回：** {{undefined}}

                [=内容时间线=] 步骤：

                1. 在[=设备时间轴=]上发布后续步骤。
                    |this|.{{GPUObjectBase/[[device]]}}.
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. 让 |parentEncoder| 为 |this|.{{GPURenderPassEncoder/[[command_encoder]]}}.
                1. 如果以下任何要求未得到满足，则
                    [$generate a validation error$] 并停止。

                    <div class=validusage>
                        - |this|.{{GPUCommandsMixin/[[state]]}} 必须是 "[=encoder state/open=]".
                        - |parentEncoder|.{{GPUCommandsMixin/[[state]]}} 必须是 "[=encoder state/locked=]".
                    </div>
                1. 设置 |this|.{{GPUCommandsMixin/[[state]]}} 为 "[=encoder state/ended=]".
                1. 设置 |parentEncoder|.{{GPUCommandsMixin/[[state]]}} 为 "[=encoder state/open=]".
                1. 如果未满足以下任何要求，请使
                    |parentEncoder| [=无效=] 并停止。

                    <div class=validusage>
                        - |this| 必须是 [=valid=].
                        - |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}} 必须 [=list/is empty|be empty=].
                        - |this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}} 必须为 `false`.
                        - |this|.{{GPURenderCommandsMixin/[[drawCount]]}} 必须 &le; |this|.{{GPURenderPassEncoder/[[maxDrawCount]]}}.
                    </div>
                1. [=list/Extend=] |parentEncoder|.{{GPUCommandsMixin/[[commands]]}}
                    with |this|.{{GPUCommandsMixin/[[commands]]}}.
                1. 如果 |this|.{{GPURenderPassEncoder/[[endTimestampWrite]]}} 不为 `null`:
                    1. [=list/Extend=] |parentEncoder|.{{GPUCommandsMixin/[[commands]]}}
                        with |this|.{{GPURenderPassEncoder/[[endTimestampWrite]]}}.
                1. 在 |this|上[$Enqueue a render command$]  ，该命令在执行时在
                    [=队列时间轴=] 上发出带有|renderState|的后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤：

                1. 问题：执行附件存储/丢弃。
                1. 让 |renderState| 为 `null`.
            </div>
            </div>
        </div>
</dl>

<h3 id=gpurendercommandsmixin data-dfn-type=interface>`GPURenderCommandsMixin`
<span id=render-commands></span>
</h3>

{{GPURenderCommandsMixin}} 定义了 {{GPURenderPassEncoder}}
和 {{GPURenderBundleEncoder}}通用的渲染命令。

<script type=idl>
interface mixin GPURenderCommandsMixin {
    undefined setPipeline(GPURenderPipeline pipeline);

    undefined setIndexBuffer(GPUBuffer buffer, GPUIndexFormat indexFormat, optional GPUSize64 offset = 0, optional GPUSize64 size);
    undefined setVertexBuffer(GPUIndex32 slot, GPUBuffer? buffer, optional GPUSize64 offset = 0, optional GPUSize64 size);

    undefined draw(GPUSize32 vertexCount, optional GPUSize32 instanceCount = 1,
        optional GPUSize32 firstVertex = 0, optional GPUSize32 firstInstance = 0);
    undefined drawIndexed(GPUSize32 indexCount, optional GPUSize32 instanceCount = 1,
        optional GPUSize32 firstIndex = 0,
        optional GPUSignedOffset32 baseVertex = 0,
        optional GPUSize32 firstInstance = 0);

    undefined drawIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);
    undefined drawIndexedIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);
};
</script>

{{GPURenderCommandsMixin}} 假定在同一对象上存在
{{GPUObjectBase}}, {{GPUCommandsMixin}}, 和 {{GPUBindingCommandsMixin}} 成员。它必须仅由同样包含这些mixin的接口包含。

{{GPURenderCommandsMixin}} 具有以下内部插槽：

<dl dfn-type=attribute dfn-for=GPURenderCommandsMixin>
    : <dfn>\[[layout]]</dfn>，类型为 {{GPURenderPassLayout}}，只读
    ::
        渲染过程的布局。

    : <dfn>\[[depthReadOnly]]</dfn>，布尔型，只读
    ::
        如果为 `true`，则表示深度分量未被修改。

    : <dfn>\[[stencilReadOnly]]</dfn>，布尔型，只读
    ::
        如果为 `true`，则表示未修改模具组件。

    : <dfn>\[[pipeline]]</dfn>，类型为 {{GPURenderPipeline}}
    ::
        当前的 {{GPURenderPipeline}}，最初为 `null`.

    : <dfn>\[[index_buffer]]</dfn>，类型为 {{GPUBuffer}}
    ::
        从中读取索引数据的当前缓冲区，最初为 `null`.

    : <dfn>\[[index_format]]</dfn>，类型为 {{GPUIndexFormat}}
    ::
        {{GPURenderCommandsMixin/[[index_buffer]]}}中索引数据的格式。

    : <dfn>\[[index_buffer_offset]]</dfn>，类型为 {{GPUSize64}}
    ::
        当前设置的{{GPURenderCommandsMixin/[[index_buffer]]}} 部分的偏移量（以字节为单位）。

    : <dfn>\[[index_buffer_size]]</dfn>，类型为 {{GPUSize64}}
    ::
        当前设置的 {{GPURenderCommandsMixin/[[index_buffer]]}} 的部分的字节大小，
        最初为 `0`.

    : <dfn>\[[vertex_buffers]]</dfn>，类型为 [=ordered map=]&lt;slot, {{GPUBuffer}}&gt;
    ::
        要从中读取每个插槽的顶点数据的当前 {{GPUBuffer}}，最初为空。

    : <dfn>\[[vertex_buffer_sizes]]</dfn>，类型为 [=ordered map=]&lt;slot, {{GPUSize64}}&gt;
    ::
        当前为每个插槽设置的 {{GPUBuffer}} 部分的大小（以字节为单位），最初为空。

    : <dfn>\[[drawCount]]</dfn>，类型为 {{GPUSize64}}
    ::
        此编码器中记录的绘制命令数。
</dl>

<div algorithm>
    要在{{GPURenderCommandsMixin}}编码器上 <dfn abstract-op>排队渲染命令</dfn> ，该 |encoder| 使用
    [=RenderState=] |renderState|发出 [=GPU 命令=] |command| 的步骤： 

        1. [=list/Append=] |command| 到 |encoder|.{{GPUCommandsMixin/[[commands]]}}.
        1. 当 |command| 作为{{GPUCommandBuffer}} |commandBuffer|命令缓冲区的一部分执行时：
            1. 使用 |commandBuffer|.{{GPUCommandBuffer/[[renderState]]}} 作为 |renderState|发出|command|的步骤。
</div>

### 绘图 ### {#render-pass-encoder-drawing}

<dl dfn-type=method dfn-for=GPURenderCommandsMixin>
    : <dfn>setPipeline(pipeline)</dfn>
    ::
        Sets the current {{GPURenderPipeline}}.

        <div algorithm=GPURenderCommandsMixin.setPipeline>
            <div data-timeline=content>
                **调用：** {{GPURenderCommandsMixin}} this.

                **参数：**

                <pre class=argumentdef for="GPURenderCommandsMixin/setPipeline(pipeline)">
                    |pipeline|: 用于后续绘图命令的渲染管道。
                </pre>

                **返回：** {{undefined}}

                [=内容时间线=] 步骤：

                1. 在 [=设备时间轴=] 上发布后续步骤。
                    |this|.{{GPUObjectBase/[[device]]}}.
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. [$验证此的编码器状态$] ，如果返回 false，请停止。
                1. 让 |pipelineTargetsLayout| 为 [$derive render targets layout from pipeline$](|pipeline|.{{GPURenderPipeline/[[descriptor]]}}).
                1. 如果不满足以下任何条件，则使 |this| [=无效=] 并停止。

                    <div class=validusage>
                        - |pipeline| 是 [$valid to use with$] |this|.
                        - |this|.{{GPURenderCommandsMixin/[[layout]]}} [=render pass layout/equals=] |pipelineTargetsLayout|.
                        - 如果 |pipeline|.{{GPURenderPipeline/[[writesDepth]]}}:
                            |this|.{{GPURenderCommandsMixin/[[depthReadOnly]]}} 必须是 `false`.
                        - 如果 |pipeline|.{{GPURenderPipeline/[[writesStencil]]}}:
                            |this|.{{GPURenderCommandsMixin/[[stencilReadOnly]]}} 必须是 `false`.
                    </div>
                1. 设置 |this|.{{GPURenderCommandsMixin/[[pipeline]]}} 为 |pipeline|.
            </div>
        </div>

    : <dfn>setIndexBuffer(buffer, indexFormat, offset, size)</dfn>
    ::
        设置当前索引缓冲区。

        <div algorithm=GPURenderCommandsMixin.setIndexBuffer>
            **调用：** {{GPURenderCommandsMixin}} this.

            **参数：**

            <pre class=argumentdef for="GPURenderCommandsMixin/setIndexBuffer(buffer, indexFormat, offset, size)">
                |buffer|: 包含用于后续绘图命令的索引数据的缓冲区。
                |indexFormat|: |buffer|中包含的索引数据的格式。
                |offset|: 索引数据开始的 |buffer| 中的偏移量（以字节为单位）。默认值为 `0`。
                |size|:  |buffer|中索引数据的大小（以字节为单位）。
                    默认为缓冲区的大小减去偏移量。
            </pre>

            **返回：** {{undefined}}

            在 [=设备时间线=] 上发布以下步骤。 |this|.{{GPUObjectBase/[[device]]}}:

            <div class=device-timeline>
                1. [$验证此的编码器状态$] 如果返回false，请停止。
                1. 如果 |size| 缺失, 设置 |size| 为 max(0, |buffer|.{{GPUBuffer/size}} - |offset|).
                1. 如果不满足以下任何条件，则使 |this| [=无效=] 并停止。

                    <div class=validusage>
                        - |buffer|  [$与此一起使用是有效的$] 
                        - |buffer|.{{GPUBuffer/usage}} 包含 {{GPUBufferUsage/INDEX}}.
                        - |offset| 是 |indexFormat|字节大小的倍数。
                        - |offset| + |size| &le; |buffer|.{{GPUBuffer/size}}.
                    </div>
                1. 添加 |buffer| 到 [=使用范围=] 作为 [=internal usage/input=].
                1. 设置 |this|.{{GPURenderCommandsMixin/[[index_buffer]]}} 到 |buffer|.
                1. 设置 |this|.{{GPURenderCommandsMixin/[[index_format]]}} 到 |indexFormat|.
                1. 设置 |this|.{{GPURenderCommandsMixin/[[index_buffer_offset]]}} 到 |offset|.
                1. 设置 |this|.{{GPURenderCommandsMixin/[[index_buffer_size]]}} 到 |size|.
            </div>
        </div>

    : <dfn>setVertexBuffer(slot, buffer, offset, size)</dfn>
    ::
        设置给定插槽的当前顶点缓冲区。

        <div algorithm=GPURenderCommandsMixin.setVertexBuffer>
            **调用：** {{GPURenderCommandsMixin}} this.

            **参数：:**

            <pre class=argumentdef for="GPURenderCommandsMixin/setVertexBuffer(slot, buffer, offset, size)">
                |slot|: 要为其设置顶点缓冲区的顶点缓冲区插槽。
                |buffer|: 包含顶点数据的缓冲区，用于后续绘图命令。
                |offset|: 以字节为单位偏移到顶点数据开始的 |buffer| 中。默认值为 `0`。
                |size|:  |buffer|中顶点数据的大小（以字节为单位）。
                    默认为缓冲区的大小减去偏移量。
            </pre>

            **返回：** {{undefined}}

            在 [=设备时间表=] 上发布以下步骤 |this|.{{GPUObjectBase/[[device]]}}:

            <div class=device-timeline>
                1. [$验证此的编码器状态$] 。如果返回false，请停止。
                1. 让 |bufferSize| 为 0 如果 |buffer| 为 `null`, 否则为 |buffer|.{{GPUBuffer/size}} 。
                1. 如果 |size| 缺失，则设置 |size| 为 max(0, |bufferSize| - |offset|).
                1. 如果以下任何要求未得到满足，则使 |this| [=无效=] 并停止。

                    <div class=validusage>
                        - |slot| 必须 &lt;
                            |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBuffers}}.
                        - |offset| 必须是4的倍数。
                        - |offset| + |size| 必须 &le; |bufferSize|.
                    </div>
                1. 如果 |buffer| 是 `null`:
                    1. [=map/Remove=] |this|.{{GPURenderCommandsMixin/[[vertex_buffers]]}}[|slot|].
                    1. [=map/Remove=] |this|.{{GPURenderCommandsMixin/[[vertex_buffer_sizes]]}}[|slot|].

                    否则：

                    1. 如果以下任何要求未得到满足，则使 |this| [=无效=] 并停止。

                        <div class=validusage>
                            - |buffer| 必须 [$有效才能与此一起使用$] 。
                            - |buffer|.{{GPUBuffer/usage}} 必须包含 {{GPUBufferUsage/VERTEX}}.
                        </div>
                    1. 添加 |buffer| 到 [=使用范围=] 作为 [=internal usage/input=].
                    1. 设置 |this|.{{GPURenderCommandsMixin/[[vertex_buffers]]}}[|slot|] 为 |buffer|.
                    1. 设置 |this|.{{GPURenderCommandsMixin/[[vertex_buffer_sizes]]}}[|slot|] 为 |size|.
            </div>
        </div>

    : <dfn>draw(vertexCount, instanceCount, firstVertex, firstInstance)</dfn>
    ::
        绘制基本体。
        详情参见 [[#rendering-operations]] 。

        <div algorithm=GPURenderCommandsMixin.draw>
            **调用：** {{GPURenderCommandsMixin}} this.

            **参数：**

            <pre class=argumentdef for="GPURenderCommandsMixin/draw(vertexCount, instanceCount, firstVertex, firstInstance)">
                |vertexCount|: 要绘制的顶点数。
                |instanceCount|: 要绘制的实例数。
                |firstVertex|: 偏移到顶点缓冲区中，以顶点为单位，开始绘制。
                |firstInstance|: 第一个要绘制的实例。
            </pre>

            **返回：** {{undefined}}

            在上 [=设备时间表=] 发布以下步骤。 |this|.{{GPUObjectBase/[[device]]}}:

            <div class=device-timeline>
                1. [$验证此的编码器状态。$] 如果返回false，请停止。
                1. 如果不满足以下任何条件，则使 |this| [=无效=] 并停止。

                    <div class=validusage>
                        - 与之一起使用 [$是有效的$] 。
                        - 让 |buffers| 为 |this|.{{GPURenderCommandsMixin/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.
                        - 对于每一个 {{GPUIndex32}} |slot| 从 `0` 到 |buffers|.length (non-inclusive):
                            - 如果 |buffers|[|slot|] 是 `null`, [=iteration/continue=].
                            - 让 |bufferSize| 为 |this|.{{GPURenderCommandsMixin/[[vertex_buffer_sizes]]}}[|slot|].
                            - 让 |stride| 为 |buffers|[|slot|].{{GPUVertexBufferLayout/arrayStride}}.
                            - 让 |lastStride| 为 max(|attribute|.{{GPUVertexAttribute/offset}} &plus; sizeof(|attribute|.{{GPUVertexAttribute/format}}))
                                对于每个 |attribute| 位于 |buffers|[|slot|].{{GPUVertexBufferLayout/attributes}}.
                            - 让 |strideCount| 计算，基于 |buffers|[|slot|].{{GPUVertexBufferLayout/stepMode}}:

                                <dl class=switch>
                                    : {{GPUVertexStepMode/"vertex"}}
                                    :: |firstVertex| &plus; |vertexCount|
                                    : {{GPUVertexStepMode/"instance"}}
                                    :: |firstInstance| &plus; |instanceCount|
                                </dl>
                            - 如果 |strideCount| &ne; `0`
                                - 确保 (|strideCount| &minus; `1`) &times; |stride| &plus; |lastStride| &le; |bufferSize|.
                    </div>
                1. 增加 |this|.{{GPURenderCommandsMixin/[[drawCount]]}} by 1.

                1. 让 |passState| 成为 |this|状态的快照。
                1. 在此上[$排队一个渲染命令$] ，该命令在执行时在
                    [=队列时间轴=] 上发出带有 |renderState| 的后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤：

                1. 绘制 |instanceCount| 实例，从实例 |firstInstance|开始，由
                     |vertexCount| 垂直组成的基本体，从顶点 |firstVertex|,
                    开始，状态来自 |passState| 和 |renderState|.
            </div>
        </div>

    : <dfn>drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance)</dfn>
    ::
        绘制索引基元。
        详情参见 [[#rendering-operations]] 。

        <div algorithm=GPURenderCommandsMixin.drawIndexed>
            **调用：** {{GPURenderCommandsMixin}} this.

            **参数：**

            <pre class=argumentdef for="GPURenderCommandsMixin/drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance)">
                |indexCount|: 要绘制的索引数。
                |instanceCount|: 要绘制的实例数。
                |firstIndex|: 偏移到索引缓冲区，在索引中，从开始绘制。
                |baseVertex|: 在索引到顶点缓冲区之前添加到每个索引值。
                |firstInstance|: 第一个要绘制的实例。
            </pre>

            **返回：** {{undefined}}

            在 [=设备时间表=] 上发布以下步骤。 |this|.{{GPUObjectBase/[[device]]}}:

            <div class=device-timeline>
                1. [$验证此的编码器状态。$] 如果返回false，请停止。
                1. 如果不满足以下任何条件，则使 |this| [=无效=] 并停止。

                    <div class=validusage>
                        - [$使用此绘制索引是有效的。$] 
                        - |firstIndex| + |indexCount| &le; |this|.{{GPURenderCommandsMixin/[[index_buffer_size]]}}
                            &div; |this|.{{GPURenderCommandsMixin/[[index_format]]}}的字节大小；
                        - 让 |buffers| 是 |this|.{{GPURenderCommandsMixin/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.
                        - 对于每一个 {{GPUIndex32}} |slot| 从 `0` 到 |buffers|.length (non-inclusive):
                            - 如果 |buffers|[|slot|] 是 `null`, [=iteration/continue=].
                            - 让 |bufferSize| 为 |this|.{{GPURenderCommandsMixin/[[vertex_buffer_sizes]]}}[|slot|].
                            - 让 |stride| 为 |buffers|[|slot|].{{GPUVertexBufferLayout/arrayStride}}.
                            - 让 |lastStride| 为 max(|attribute|.{{GPUVertexAttribute/offset}} &plus; sizeof(|attribute|.{{GPUVertexAttribute/format}}))
                                对于每一个 |attribute| in |buffers|[|slot|].{{GPUVertexBufferLayout/attributes}}.
                            - 让 |strideCount| 为 |firstInstance| &plus; |instanceCount|.
                            - 如果 |buffers|[|slot|].{{GPUVertexBufferLayout/stepMode}} is {{GPUVertexStepMode/"instance"}} 和 |strideCount| &ne; `0`:
                                - Ensure (|strideCount| &minus; `1`) &times; |stride| &plus; |lastStride| &le; |bufferSize|.
                    </div>
                1. 增加 |this|.{{GPURenderCommandsMixin/[[drawCount]]}}  1.

                1. 让 |passState| 成为 |this|状态的快照。
                1. 在|this|上[$排队一个渲染命令$] ，该命令在执行时在队列时间轴上发出带有 |renderState| 的后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤：

                1. 绘制 |instanceCount| 实例，从实例 |firstInstance|开始，由
                     |indexCount| 索引的垂直图元组成，从|baseVertex|的顶点的索引
                    |firstIndex| 开始，状态从
                     |passState| 和 |renderState|开始。
            </div>

            注意：一个有效的程序也不应该将顶点索引与超出界限
            {{GPUVertexStepMode/"vertex"|GPUVertexStepMode."vertex"}} 一起使用。
            WebGPU 实现有不同的处理方式，因此允许一系列行为。要么放弃整个绘制调用，要
            么通过WGSL的[=无效内存引用=]来描述对越界属性的访问。 
        </div>

    : <dfn>drawIndirect(indirectBuffer, indirectOffset)</dfn>
    ::
        使用从 {{GPUBuffer}}读取的参数绘制基本体。
        详情参见 [[#rendering-operations]] 。

        缓冲区中编码的 <dfn dfn for="">indirect draw parameters</dfn> 必须是一个由
         **四个32位无符号整数值（总共16字节）**组成的紧密压缩块，其顺序与
         {{GPURenderCommandsMixin/draw()}}的参数相同。例如：
        
        <pre highlight=js>
            let drawIndirectParameters = new Uint32Array(4);
            drawIndirectParameters[0] = vertexCount;
            drawIndirectParameters[1] = instanceCount;
            drawIndirectParameters[2] = firstVertex;
            drawIndirectParameters[3] = firstInstance;
        </pre>

        除非启用了{{GPUFeatureName/"indirect-first-instance"}}[=feature=]功能，否则与 `firstInstance` 对应的值必须为0。
        如果未启用 {{GPUFeatureName/"indirect-first-instance"}} [=feature=] 且
        `firstInstance` 不为零，则 {{GPURenderCommandsMixin/drawIndirect()}} 调用将被视为 no-op。

        <div algorithm=GPURenderCommandsMixin.drawIndirect>
            **调用：** {{GPURenderCommandsMixin}} this.

            **参数：**

            <pre class=argumentdef for="GPURenderCommandsMixin/drawIndirect(indirectBuffer, indirectOffset)">
                |indirectBuffer|: 包含 [=间接绘制参数=]的缓冲区。
                |indirectOffset|: 以字节为单位偏移到图形数据开始的 |indirectBuffer| 中。
            </pre>

            **返回：** {{undefined}}

            在 [=设备时间表=] 上发布以下步骤。 |this|.{{GPUObjectBase/[[device]]}}:

            <div class=device-timeline>
                1. [$验证此的编码器状态。$] 如果返回false，请停止。
                1. 如果不满足以下任何条件，则使 |this| [=无效=] 并停止。

                    <div class=validusage>
                        - 用 |this| [$绘制是有效的$] 。
                        - |indirectBuffer|  [$与此一起使用是有效的$] 
                        - |indirectBuffer|.{{GPUBuffer/usage}} 包含 {{GPUBufferUsage/INDIRECT}}.
                        - |indirectOffset| + sizeof([=indirect draw parameters=]) &le;
                            |indirectBuffer|.{{GPUBuffer/size}}.
                        - |indirectOffset| 是4的倍数。
                    </div>
                1. 添加 |indirectBuffer| 到 [=usage scope=] 作为 [=internal usage/input=].
                1. 增加 |this|.{{GPURenderCommandsMixin/[[drawCount]]}} by 1.

                1. 让 |passState| 成为 |this|状态的快照。
                1. 在 |this|上[$排队一个渲染命令$]  ，该命令在执行时在[=队列时间轴=]上发出带有
                     |renderState| 的后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤：

                1. 让 |vertexCount| 是一个从 |indirectBuffer| 取的无符号32位整数，位于
                    |indirectOffset| 字节。
                1. 让 |instanceCount| 是一个无符号的32位整数，从 |indirectBuffer| 读取
                    (|indirectOffset| + 4) 字节。
                1. 让 |firstVertex| 是一个无符号的32位整数，从 |indirectBuffer| 读取
                    (|indirectOffset| + 8) 字节。
                1. 让 |firstInstance| 是一个无符号的32位整数，从 |indirectBuffer| 读取
                    (|indirectOffset| + 12) 字节。
                1. 绘制 |instanceCount| 实例，从实例 |firstInstance|开始，由
                     |vertexCount| 垂直组成的基本体，从顶点 |firstVertex|开始，状态来自
                     |passState| 和 |renderState|。
            </div>
        </div>

    : <dfn>drawIndexedIndirect(indirectBuffer, indirectOffset)</dfn>
    ::
        使用从{{GPUBuffer}}读取的参数绘制索引基元。
        详情参见 [[#rendering-operations]] 。

        缓冲区中编码的<dfn dfn for="">indirect drawIndexed parameters</dfn> 必须是一个由 
        **五个32位无符号整数值（总共20字节）**组成的紧密压缩块，其顺序与
         {{GPURenderCommandsMixin/drawIndexed()}}的参数相同。例如：

        <pre highlight=js>
            let drawIndexedIndirectParameters = new Uint32Array(5);
            drawIndexedIndirectParameters[0] = indexCount;
            drawIndexedIndirectParameters[1] = instanceCount;
            drawIndexedIndirectParameters[2] = firstIndex;
            drawIndexedIndirectParameters[3] = baseVertex;
            drawIndexedIndirectParameters[4] = firstInstance;
        </pre>

        除非启用了 {{GPUFeatureName/"indirect-first-instance"}}
        [=feature=] 功能，否则与 `firstInstance` 对应的值必须为0。如果 {{GPUFeatureName/"indirect-first-instance"}} [=feature=] 未启用且
        `firstInstance` 不为零，则 {{GPURenderCommandsMixin/drawIndexedIndirect()}} 调用将被视为 no-op。

        <div algorithm=GPURenderCommandsMixin.drawIndexedIndirect>
            **调用：** {{GPURenderCommandsMixin}} this.

            **参数：**

            <pre class=argumentdef for="GPURenderCommandsMixin/drawIndexedIndirect(indirectBuffer, indirectOffset)">
                |indirectBuffer|: 包含 [=间接drawIndexed参数=]的缓冲区。
                |indirectOffset|: 以字节为单位偏移到图形数据开始的 |indirectBuffer| 中。
            </pre>

            **返回：** {{undefined}}

            在[=设备时间表=]上发布以下步骤 |this|.{{GPUObjectBase/[[device]]}}:

            <div class=device-timeline>
                1. [$验证此的编码器状态。$] 如果返回false，请停止。
                1. 如果不满足以下任何条件，则使 |this| [=无效=] 并停止。

                    <div class=validusage>
                        -  [$使用此绘制索引是有效的。$] 
                        - |indirectBuffer|  与|this|[$一起使用是有效的。$] 
                        - |indirectBuffer|.{{GPUBuffer/usage}} 包含 {{GPUBufferUsage/INDIRECT}}.
                        - |indirectOffset| + sizeof([=indirect drawIndexed parameters=]) &le;
                            |indirectBuffer|.{{GPUBuffer/size}}.
                        - |indirectOffset| 是4的倍数。
                    </div>
                1. 添加 |indirectBuffer| 发 [=使用范围=] 作为 [=internal usage/input=].
                1. 增加 |this|.{{GPURenderCommandsMixin/[[drawCount]]}} by 1.

                1. 让 |passState| 成为 |this|状态的快照。
                1. 在 |this|上[$排队一个渲染命令$]  ，该命令在执行时在[=队列时间轴=]上发出带有
                     |renderState| 的后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤：

                1. 让 |indexCount| 是一个无符号的32位整数，从 |indirectBuffer| 读取，位置为
                    |indirectOffset| 字节。
                1. 让 |instanceCount| 是一个无符号的32位整数，从 |indirectBuffer| 读取，位置为
                    (|indirectOffset| + 4) 字节。
                1. 让 |firstIndex| 是一个无符号的32位整数，从 |indirectBuffer| 读取，位置为
                    (|indirectOffset| + 8) b字节。
                1. 让 |baseVertex| 是一个无符号的32位整数，从 |indirectBuffer| 读取，位置为
                    (|indirectOffset| + 12) 字节。
                1. 让 |firstInstance| 是一个无符号的32位整数，从 |indirectBuffer| 读取，位置为
                    (|indirectOffset| + 16) 字节。
                1. 绘制 |instanceCount| 实例，从实例 |firstInstance|开始，由
                     |indexCount| 索引的垂直图元组成，从|baseVertex|的顶点的索引
                    |firstIndex| 开始，状态从
                     |passState| 和 |renderState|开始。
            </div>
        </div>
</dl>

<div algorithm>
    要确定使用 {{GPURenderCommandsMixin}} |encoder|编码器是否 <dfn abstract-op>valid to draw</dfn> 
    请运行以下步骤：

    1. 如果不满足以下任何条件，则返回 `false`:

        <div class=validusage>
            - [$验证编码器绑定组$](|encoder|, |encoder|.{{GPURenderCommandsMixin/[[pipeline]]}})
                必须为 `true`.
            - 让 |pipelineDescriptor| 为 |encoder|.{{GPURenderCommandsMixin/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.
            - 对于每一个{{GPUIndex32}} |slot| `0` 到
                |pipelineDescriptor|.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.length:
                - 如果 |pipelineDescriptor|.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}[|slot|] 不为 `null`,
                    |encoder|.{{GPURenderCommandsMixin/[[vertex_buffers]]}} 必须 [=map/contain=] |slot|.
            - 验证 {{supported limits/maxBindGroupsPlusVertexBuffers}}:
                1. 让 |bindGroupSpaceUsed| 为
                    (the maximum key in |encoder|.{{GPUBindingCommandsMixin/[[bind_groups]]}}) + 1.
                1. 让 |vertexBufferSpaceUsed| 为
                    (the maximum key in |encoder|.{{GPURenderCommandsMixin/[[vertex_buffers]]}}) + 1.
                1. |bindGroupSpaceUsed| + |vertexBufferSpaceUsed| 必须是 &le;
                    |encoder|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxBindGroupsPlusVertexBuffers}}.
        </div>
    1. 否则返回 `true`.
</div>

<div algorithm>
    要确定使用 {{GPURenderCommandsMixin}} |encoder| <dfn abstract-op>valid to draw indexed</dfn> 
    请运行以下步骤：

    1. 如果不满足以下任何条件，则返回 `false`:

        <div class=validusage>
            -  使用 |encoder|[$绘制必须有效。$] 
            - |encoder|.{{GPURenderCommandsMixin/[[index_buffer]]}} 必须不为 `null`.
            - 让 |topology| 为 |encoder|.{{GPURenderCommandsMixin/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/topology}}.
            - 如果 |topology| 是 {{GPUPrimitiveTopology/"line-strip"}} 或 {{GPUPrimitiveTopology/"triangle-strip"}}:
                - |encoder|.{{GPURenderCommandsMixin/[[index_format]]}} must equal
                    |encoder|.{{GPURenderCommandsMixin/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/stripIndexFormat}}.
        </div>
    1. 否则返回 `true`.
</div>

### 光栅化状态 ### {#render-pass-encoder-rasterization-state}

{{GPURenderPassEncoder}} 有几种方法会影响绘制命令如何光栅化到此编码器使用的附件。

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>setViewport(x, y, width, height, minDepth, maxDepth)</dfn>
    ::
        将光栅化阶段使用的视口设置为从标准化设备坐标线性映射到视口坐标。

        <div algorithm=GPURenderPassEncoder.setViewport>
            <div data-timeline=content>
                **调用：** {{GPURenderPassEncoder}} |this|.

                **参数：**

                <pre class=argumentdef for="GPURenderPassEncoder/setViewport(x, y, width, height, minDepth, maxDepth)">
                    |x|: 视口的最小X值（以像素为单位）。
                    |y|: 视口的最小Y值（以像素为单位）。
                    |width|: 口的宽度（以像素为单位）。
                    |height|: 视口的高度（以像素为单位）。
                    |minDepth|: 视口的最小深度值。
                    |maxDepth|: 视口的最大深度值。
                </pre>

                **返回：** {{undefined}}

                [=内容时间线=] 步骤：

                1. 在 [=设备时间轴=] 上发布后续步骤。
                    |this|.{{GPUObjectBase/[[device]]}}.
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. [$验证此的编码器状态。$] 如果返回false，请停止。
                1. 如果不满足以下任何条件，则使 |this| [=无效=]并停止。

                    <div class=validusage>
                        - |x| &ge; `0`
                        - |y| &ge; `0`
                        - |width| &ge; `0`
                        - |height| &ge; `0`
                        - |x| + |width| &le; |this|.{{GPURenderPassEncoder/[[attachment_size]]}}.width
                        - |y| + |height| &le; |this|.{{GPURenderPassEncoder/[[attachment_size]]}}.height
                        - 0.0 &le; |minDepth| &le; 1.0
                        - 0.0 &le; |maxDepth| &le; 1.0
                        - |minDepth| &lt; |maxDepth|
                    </div>

                1. 在 |this|上[$排队一个渲染命令$]  ，该命令在执行时在[=队列时间轴=]上发出带有
                     |renderState| 的后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤：

                1. 将 |x|, |y|, |width|, 和 |height| 舍入到某种统一的精度，精度不亚于整数舍入。
                1. 设置 |renderState|.{{RenderState/[[viewport]]}} 到范围 |x|, |y|, |width|, |height|, |minDepth|, 和 |maxDepth|.
            </div>
        </div>

    : <dfn>setScissorRect(x, y, width, height)</dfn>
    ::
        设置光栅化阶段中使用的剪刀形矩形。转换到视口坐标后，落在剪刀形矩形之外的任何片段都将被丢弃。

        <div algorithm=GPURenderPassEncoder.setScissorRect>
            <div data-timeline=content>
                **调用：** {{GPURenderPassEncoder}} |this|.

                **参数：**

                <pre class=argumentdef for="GPURenderPassEncoder/setScissorRect(x, y, width, height)">
                    |x|: 剪刀形矩形的最小X值（以像素为单位）。
                    |y|: 剪刀形矩形的最小Y值（以像素为单位）。
                    |width|: 剪刀形矩形的宽度（以像素为单位）。
                    |height|: 剪刀形矩形的高度（以像素为单位）。
                </pre>

                **返回：** {{undefined}}

                [=内容时间线=] 步骤：

                1. 在 [=设备时间轴=] 上发布后续步骤。
                    |this|.{{GPUObjectBase/[[device]]}}.
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. [$验证此的编码器状态。$] 如果返回false，请停止。
                1. 如果不满足以下任何条件，则使 |this| [=无效=]
                    并停止。

                    <div class=validusage>
                        - |x|+|width| &le;
                            |this|.{{GPURenderPassEncoder/[[attachment_size]]}}.width.
                        - |y|+|height| &le;
                            |this|.{{GPURenderPassEncoder/[[attachment_size]]}}.height.
                    </div>

                1. [$在此上排队一个渲染命令$] ，该命令在执行时在
                    [=队列时间轴=] 上发出带有 |renderState| 的后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤：

                1. 设置 |renderState|.{{RenderState/[[scissorRect]]}} 到范围 |x|, |y|, |width|, 和 |height|.
            </div>
        </div>

    : <dfn>setBlendConstant(color)</dfn>
    ::
        设置与 {{GPUBlendFactor/"constant"}}
        和 {{GPUBlendFactor/"one-minus-constant"}} {{GPUBlendFactor}}一起使用的常量混合颜色和alpha值。

        <div algorithm=GPURenderPassEncoder.setBlendConstant>
            <div data-timeline=content>
                **调用：** {{GPURenderPassEncoder}} this.

                **参数：**

                <pre class=argumentdef for="GPURenderPassEncoder/setBlendConstant(color)">
                    |color|: 混合时要使用的颜色。
                </pre>

                **返回：** {{undefined}}

                [=内容时间线=] 步骤：

                1. [=?=] [$验证GPU颜色形状$](|color|).
                1. 在 [=设备时间轴=] 上发布后续步骤。
                    |this|.{{GPUObjectBase/[[device]]}}.
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. [$验证此的编码器状态。$] 如果返回false，请停止。
                1. 在 |this|上[$排队一个渲染命令$]  该命令在执行时在
                    [=队列时间轴=] 上发出带有 |renderState| 的后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤：

                1. 设置 |renderState|.{{RenderState/[[blendConstant]]}} 到 |color|.
            </div>
        </div>

    : <dfn>setStencilReference(reference)</dfn>
    ::
        使用 {{GPUStencilOperation/"replace"}} {{GPUStencilOperation}}设置模具测试期间使用的 {{RenderState/[[stencilReference]]}} 值。

        <div algorithm=GPURenderPassEncoder.setStencilReference>
            <div data-timeline=content>
                **调用：** {{GPURenderPassEncoder}} this.

                **参数：**

                <pre class=argumentdef for="GPURenderPassEncoder/setStencilReference(reference)">
                    |reference|: 新的模具引用值。
                </pre>

                **返回：** {{undefined}}

                [=内容时间线=] 步骤：

                1. 在 [=设备时间轴=]上发布后续步骤。
                    |this|.{{GPUObjectBase/[[device]]}}.
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. [$验证此的编码器状态。$] 如果返回false，请停止。
                1. 在 |this|上[$排队一个渲染命令$]  ，该命令在执行时在
                    [=队列时间轴=] 上发出带有 |renderState| 的后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤：

                1. 设置 |renderState|.{{RenderState/[[stencilReference]]}} 到 |reference|.
            </div>
        </div>
</dl>

### 查询 ### {#render-pass-encoder-queries}

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>beginOcclusionQuery(queryIndex)</dfn>
    ::
        <div algorithm=GPURenderPassEncoder.beginOcclusionQuery>
            <div data-timeline=content>
                **调用：** {{GPURenderPassEncoder}} |this|.

                **参数：**

                <pre class=argumentdef for="GPURenderPassEncoder/beginOcclusionQuery(queryIndex)">
                    |queryIndex|: 查询集中查询的索引。
                </pre>

                **返回：** {{undefined}}

                [=Content timeline=] steps:

                1. Issue the subsequent steps on the [=Device timeline=] of
                    在 [=设备时间轴=] 上发布后续步骤。
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. [$验证此的编码器状态。$] 如果返回false，请停止。
                1. 如果不满足以下任何条件，则使 |this| [=无效=] 并停止。

                    <div class=validusage>
                        |this|.{{GPURenderPassEncoder/[[occlusion_query_set]]}} 不是 `null`.
                        - |queryIndex| &lt; |this|.{{GPURenderPassEncoder/[[occlusion_query_set]]}}.{{GPUQuerySet/count}}.
                        - 在同一个 |queryIndex| 的查询不能在此渲染通道中先前写入过。
                        - |this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}} 为 `false`.
                    </div>
                1. 设置 |this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}} 为 `true`.

                1. 在 |this|上[$排队一个渲染命令$] ，该命令在执行时在
                    [=队列时间轴=] 上发出带有 |renderState| 的后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤：

                1. 设置 |renderState|.{{RenderState/[[occlusionQueryIndex]]}} 为 |queryIndex|.
            </div>
        </div>

    : <dfn>endOcclusionQuery()</dfn>
    ::
        <div algorithm=GPURenderPassEncoder.endOcclusionQuery>
            <div data-timeline=content>
                **调用：** {{GPURenderPassEncoder}} this.

                **返回：** {{undefined}}

                [=Content timeline=] steps:

                1. 在 [=设备时间轴=] 上发布后续步骤。
            </div>
            <div data-timeline=device>
                1. [=设备时间线=] 步骤：

                1. [$验证此的编码器状态。$] 如果返回false，请停止。
                1. 如果不满足以下任何条件，则使 |this| [=无效=] 并停止。

                    <div class=validusage>
                        - |this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}} 为 `true`.
                    </div>
                1. 设置 |this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}} 为 `false`.

                1. 在 |this|上[$排队一个渲染命令$] ，该命令在执行时在
                    [=队列时间轴=] 上发出带有 |renderState| 的后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤：

                1. 如果自相应的 {{GPURenderPassEncoder/beginOcclusionQuery()}}
                    命令执行以来，任何片段样本都通过了所有片段测试，则 |passingFragments| 为非零，否则为零。

                    注意：如果没有发生绘制调用，则 |passingFragments| 为零。
                1. 将 |passingFragments| 写入
                    |this|.{{GPURenderPassEncoder/[[occlusion_query_set]]}} 的索引
                    |renderState|.{{RenderState/[[occlusionQueryIndex]]}}.
            </div>
        </div>
</dl>

### 包 ### {#render-pass-encoder-bundles}

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>executeBundles(bundles)</dfn>
    ::
        执行先前记录到给定的 {{GPURenderBundle}} 中的命令，作为此渲染通道的一部分。

        执行 {{GPURenderBundle}} 时，它不会继承渲染通道的管道、绑定组或顶点和索引缓冲区。
        执行 {{GPURenderBundle}} 后，渲染通道的管道、绑定组和顶点/索引缓冲区状态被清除（到初始的空值）。

        注意：状态被清除，而不是恢复到先前的状态。
        即使执行了零个 {{GPURenderBundle|GPURenderBundles}}，也会发生这种情况。

        <div algorithm=GPURenderPassEncoder.executeBundles>
            <div data-timeline=content>
                **调用** {{GPURenderPassEncoder}} this.

                **参数：**

                <pre class=argumentdef for="GPURenderPassEncoder/executeBundles(bundles)">
                    |bundles|: 要执行的渲染包的列表。
                </pre>

                **返回：** {{undefined}}

                [=内容时间线=] 步骤：

                1. 在 [=设备时间轴=] 上发布后续步骤。
                    |this|.{{GPUObjectBase/[[device]]}}.
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. [$验证此的编码器状态。$] 如果返回false，请停止。
                1. 如果不满足以下任何条件，则使 |this| [=无效=] 并停止。

                    <div class=validusage>
                        - 对于 |bundles| 中的每个 |bundle|：
                            - |bundle| 必须 [$与此一起使用有效$]。
                            - |this|.{{GPURenderCommandsMixin/[[layout]]}} 必须等于 |bundle|.{{GPURenderBundle/[[layout]]}}.
                            - 如果 |this|.{{GPURenderCommandsMixin/[[depthReadOnly]]}} 为真, |bundle|.{{GPURenderBundle/[[depthReadOnly]]}} 必须为真。
                            - 如果 |this|.{{GPURenderCommandsMixin/[[stencilReadOnly]]}} 为真, |bundle|.{{GPURenderBundle/[[stencilReadOnly]]}} 必须为真。
                    </div>

                1. 对于 |bundles| 中的每个 |bundle|：
                    1. 将 |this|.{{GPURenderCommandsMixin/[[drawCount]]}} 增加 |bundle|.{{GPURenderBundle/[[drawCount]]}}。

                1. [=map/Clear=] |this|.{{GPUBindingCommandsMixin/[[bind_groups]]}}.
                1. 设置 |this|.{{GPURenderCommandsMixin/[[pipeline]]}} 为 `null`.
                1. 设置 |this|.{{GPURenderCommandsMixin/[[index_buffer]]}} 为 `null`.
                1. [=map/Clear=] |this|.{{GPURenderCommandsMixin/[[vertex_buffers]]}}.

                1. 让 |passState| 成为 |this|状态的快照。
                1. 在 |this|上[$排队一个渲染命令$] ，该命令在执行时在
                    [=队列时间轴=] 上发出带有 |renderState| 的后续步骤。
            </div>
            <div data-timeline=queue>
                1. [=队列时间线=] 步骤：

                1. 对于 |bundles| 中的每个 |bundle|：
                    1. 使用 |passState| 和 |renderState| 执行 |bundle|.{{GPURenderBundle/[[command_list]]}} 中的每个命令。

                        注意：执行渲染包不能更改 |renderState|。
                        还要注意，渲染包看不到可变的 |passState| 状态。
            </div>

        </div>
</dl>

# 包 # {#bundles}

包是一种部分的、有限的通道，它只编码一次，然后可以作为未来通道编码器的一部分多次执行，而不像典型的命令缓冲区那样在使用后过期。
这可以减少重复发出而不改变的命令的编码和提交的开销。

<h3 id=gpurenderbundle data-dfn-type=interface>`GPURenderBundle`
<span id=render-bundle></span>
</h3>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderBundle {
};
GPURenderBundle includes GPUObjectBase;
</script>

<dl dfn-type=attribute dfn-for=GPURenderBundle>
    : <dfn>\[[command_list]]</dfn>, of type [=list=]&lt;[=GPU command=]&gt;
    ::
        要在执行 {{GPURenderBundle}} 时提交给 {{GPURenderPassEncoder}} 的 [=GPU commands=] 的 [=list=]。

    : <dfn>\[[layout]]</dfn>, of type {{GPURenderPassLayout}}
    ::
        渲染包的布局。

    : <dfn>\[[depthReadOnly]]</dfn>, of type boolean
    ::
        如果为 `true`，则表示执行此渲染包不会修改深度分量。

    : <dfn>\[[stencilReadOnly]]</dfn>, of type boolean
    ::
        如果为 `true`，则表示执行此渲染包不会修改模板分量。

    : <dfn>\[[drawCount]]</dfn>, of type {{GPUSize64}}
    ::
        此 {{GPURenderBundle}} 中的绘制命令数。
</dl>

### 渲染包创建 ### {#render-bundle-creation}

<script type=idl>
dictionary GPURenderBundleDescriptor
         : GPUObjectDescriptorBase {
};
</script>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderBundleEncoder {
    GPURenderBundle finish(optional GPURenderBundleDescriptor descriptor = {});
};
GPURenderBundleEncoder includes GPUObjectBase;
GPURenderBundleEncoder includes GPUCommandsMixin;
GPURenderBundleEncoder includes GPUDebugCommandsMixin;
GPURenderBundleEncoder includes GPUBindingCommandsMixin;
GPURenderBundleEncoder includes GPURenderCommandsMixin;
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createRenderBundleEncoder(descriptor)</dfn>
    ::
        创建一个 {{GPURenderBundleEncoder}}。

        <div algorithm=GPUDevice.createRenderBundleEncoder>
            <div data-timeline=content>
                **调用：** {{GPUDevice}} |this|.

                **参数：**

                <pre class=argumentdef for="GPUDevice/createRenderBundleEncoder(descriptor)">
                    |descriptor|: 要创建的 {{GPURenderBundleEncoder}} 的描述。
                </pre>

                **返回：** {{GPURenderBundleEncoder}}

                [=内容时间线=] 步骤：

                1. [=?=] [$Validate texture format required features$] of each non-`null` element of
                    |descriptor|.{{GPURenderPassLayout/colorFormats}} with |this|.{{GPUObjectBase/[[device]]}}.
                1. [=?=] [$Validate texture format required features$] of
                    |descriptor|.{{GPURenderPassLayout/depthStencilFormat}} with |this|.{{GPUObjectBase/[[device]]}}.
                1. 让 |e| 成为一个新的 {{GPURenderBundleEncoder}} 对象。
                1. 在 [=设备时间轴=] 上发布 |initialization steps| 。
                1. 返回 |e|.
            </div>
            <div data-timeline=device>
                [=设备时间线=] |initialization steps|:

                1. 如果以下任何条件不满足 [$generate a validation error$]，则使 |e| [=无效=]，并停止。

                    <div class=validusage>
                        - |this| is [=valid=].
                        - |descriptor|.{{GPURenderPassLayout/colorFormats}}.length must be &le;
                            |this|.{{device/[[limits]]}}.{{supported limits/maxColorAttachments}}.
                        - For each non-`null` |colorFormat| in |descriptor|.{{GPURenderPassLayout/colorFormats}}:
                            - |colorFormat| must be a [=color renderable format=].
                        - [$Calculating color attachment bytes per sample$](|descriptor|.{{GPURenderPassLayout/colorFormats}})
                            must be &le; |this|.{{device/[[limits]]}}.{{supported limits/maxColorAttachmentBytesPerSample}}.
                        - If |descriptor|.{{GPURenderPassLayout/depthStencilFormat}} is [=map/exist|provided=]:
                            - |descriptor|.{{GPURenderPassLayout/depthStencilFormat}} must be a
                                [=depth-or-stencil format=].
                            - If |descriptor|.{{GPURenderPassLayout/depthStencilFormat}} is a
                                [=combined depth-stencil format=]:
                                - |descriptor|.{{GPURenderBundleEncoderDescriptor/depthReadOnly}} must be equal to
                                    |descriptor|.{{GPURenderBundleEncoderDescriptor/stencilReadOnly}}.
                        - There must exist at least one attachment, either:
                            - A non-`null` value in
                                |descriptor|.{{GPURenderPassLayout/colorFormats}}, or
                            - A |descriptor|.{{GPURenderPassLayout/depthStencilFormat}}.
                    </div>
                1. 将 |e|.{{GPURenderCommandsMixin/[[layout]]}} 设置为 |descriptor| 的包含的 {{GPURenderPassLayout}} 接口的副本。
                1. 将 |e|.{{GPURenderCommandsMixin/[[depthReadOnly]]}} 设置为 |descriptor|.{{GPURenderBundleEncoderDescriptor/depthReadOnly}}。
                1. 将 |e|.{{GPURenderCommandsMixin/[[stencilReadOnly]]}} 设置为 |descriptor|.{{GPURenderBundleEncoderDescriptor/stencilReadOnly}}。
                1. 将 |e|.{{GPUCommandsMixin/[[state]]}} 设置为 "[=encoder state/open=]"。
                1. 将 |e|.{{GPURenderCommandsMixin/[[drawCount]]}} 设置为 0。

                问题：描述 {{GPUDevice/createRenderBundleEncoder()}} 的步骤的重置。
            </div>
        </div>
</dl>

### 编码 ### {#render-bundle-encoding}

<script type=idl>
dictionary GPURenderBundleEncoderDescriptor
         : GPURenderPassLayout {
    boolean depthReadOnly = false;
    boolean stencilReadOnly = false;
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderBundleEncoderDescriptor>
    : <dfn>depthReadOnly</dfn>
    ::
        如果为 `true`，则表示渲染包不会修改任何渲染通道中执行渲染包的 {{GPURenderPassDepthStencilAttachment}} 的深度分量。

    : <dfn>stencilReadOnly</dfn>
    ::
        如果为 `true`，则表示渲染包不会修改任何渲染通道中执行渲染包的 {{GPURenderPassDepthStencilAttachment}} 的模板分量。
</dl>

### 最终化 ### {#render-bundle-finalization}

<dl dfn-type=method dfn-for=GPURenderBundleEncoder>
    : <dfn>finish(descriptor)</dfn>
    ::
        完成渲染包命令序列的记录。

        <div algorithm=GPURenderBundleEncoder.finish>
            <div data-timeline=content>
                **调用：** {{GPURenderBundleEncoder}} this.

                **参数：**

                <pre class=argumentdef for="GPURenderBundleEncoder/finish(descriptor)">
                    descriptor:
                </pre>

                **返回：** {{GPURenderBundle}}

                [=内容时间线=] 步骤：

                1. 让 |renderBundle| 成为一个新的 {{GPURenderBundle}}。
                1. 在 [=设备时间轴=] 上发布后续步骤。
                    |this|.{{GPUObjectBase/[[device]]}}.
                1. 返回 |renderBundle|.
            </div>
            <div data-timeline=device>
                1. [=设备时间线=] |finish steps|：

                1. 如果满足以下所有要求，则让 |validationSucceeded| 为 `true`，否则为 `false`。

                    <div class=validusage>
                        - |this| 必须是 [=valid=]。
                        - |this|.{{GPUCommandsMixin/[[state]]}} 必须为 "[=encoder state/open=]"。
                        - |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}} 必须 [=list/is empty|be empty=]。
                        - |this| 中包含的每个 [=usage scope=] 必须满足 [=usage scope validation=]。
                    </div>
                1. 将 |this|.{{GPUCommandsMixin/[[state]]}} 设置为 "[=encoder state/ended=]"。
                1. 如果 |validationSucceeded| 为 `false`，则：
                    1. [$生成验证错误$]。
                    1. 返回一个新的 [=invalid=] {{GPURenderBundle}}。
                1. 将 |renderBundle|.{{GPURenderBundle/[[command_list]]}} 设置为
                    |this|.{{GPUCommandsMixin/[[commands]]}}.
                1. 将 |renderBundle|.{{GPURenderBundle/[[drawCount]]}} 设置为
                    |this|.{{GPURenderCommandsMixin/[[drawCount]]}}.
            </div>
        </div>
</dl>

# 查询 # {#queries}

<h3 id=gpuqueuedescriptor data-dfn-type=dictionary>`GPUQueueDescriptor`
<span id=dictdef-gpuqueuedescriptor></span>
</h3>

{{GPUQueueDescriptor}} 描述了一个队列请求。

<script type=idl>
dictionary GPUQueueDescriptor
         : GPUObjectDescriptorBase {
};
</script>

<h3 id=gpuqueue data-dfn-type=interface>`GPUQueue`
<span id=gpu-queue></span>
</h3>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUQueue {
    undefined submit(sequence<GPUCommandBuffer> commandBuffers);

    Promise<undefined> onSubmittedWorkDone();

    undefined writeBuffer(
        GPUBuffer buffer,
        GPUSize64 bufferOffset,
        [AllowShared] BufferSource data,
        optional GPUSize64 dataOffset = 0,
        optional GPUSize64 size);

    undefined writeTexture(
        GPUImageCopyTexture destination,
        [AllowShared] BufferSource data,
        GPUImageDataLayout dataLayout,
        GPUExtent3D size);

    undefined copyExternalImageToTexture(
        GPUImageCopyExternalImage source,
        GPUImageCopyTextureTagged destination,
        GPUExtent3D copySize);
};
GPUQueue includes GPUObjectBase;
</script>

{{GPUQueue}} 有以下方法：

<dl dfn-type=method dfn-for=GPUQueue>
    : <dfn>writeBuffer(buffer, bufferOffset, data, dataOffset, size)</dfn>
    ::
        将提供的数据写入 {{GPUBuffer}} 中。

        <div algorithm=GPUQueue.writeBuffer>
            <div data-timeline=content>
                **调用：** {{GPUQueue}} |this|.

                **参数：**

                <pre class=argumentdef for="GPUQueue/writeBuffer(buffer, bufferOffset, data, dataOffset, size)">
                    |buffer|:要写入的缓冲区。
                    |bufferOffset|:要开始写入的字节偏移量。
                    |data|:要写入 |buffer| 的数据。
                    |dataOffset|:要从中开始写入的 |data| 中的偏移量。如果 |data| 是 `TypedArray`，则以元素为单位，否则以字节为单位。
                    |size|:要从 |data| 写入 |buffer| 的内容的大小。如果 |data| 是 `TypedArray`，则以元素为单位，否则以字节为单位。
                </pre>

                **返回：** {{undefined}}

                [=内容时间线=] 步骤：

                1. 如果 |data| 是 {{ArrayBuffer}} 或 {{DataView}}，则将元素类型设置为 "byte"。否则，|data| 是 TypedArray；将元素类型设置为 TypedArray 的类型。
                1. 让 |dataSize| 成为 |data| 的大小，以元素为单位。
                1. 如果 |size| 丢失，则让 |contentsSize| 成为 |dataSize| &minus; |dataOffset|。否则，让 |contentsSize| 成为 |size|。
                1. 如果不满足以下任何条件，则抛出 {{OperationError}} 并停止。

                    <!-- 注意：在此处内联编写有效的用法规则最容易，因为它们取决于上面的 contentsSize。 -->

                    <div class=validusage>
                        - |contentsSize| &ge; 0.
                        - |dataOffset| + |contentsSize| &le; |dataSize|.
                        - |contentsSize|，转换为字节，是 4 字节的倍数。
                    </div>
                1. 让 |dataContents| 成为 [=get a copy of the buffer source|a copy of the bytes held by the buffer source=]。
                1. 让 |contents| 成为从 |dataOffset| 元素开始的 |dataContents| 的 |contentsSize| 元素。
                1. 在 |this| 的 [=Device timeline=] 上发布后续步骤。
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. If any of the following conditions are unsatisfied,
                    如果不满足以下任何条件，则 [$generate a validation error$] 并停止。

                    <div class=validusage>
                        - |buffer| 是 [$valid to use with$] |this|。
                        - |buffer|.{{GPUBuffer/[[internals]]}}.[=buffer internals/state=] 是 "[=buffer internals/state/available=]"。
                        - |buffer|.{{GPUBuffer/usage}} 包括 {{GPUBufferUsage/COPY_DST}}。
                        - |bufferOffset|，转换为字节，是 4 字节的倍数。
                        - |bufferOffset| + |contentsSize|，转换为字节，&le; |buffer|.{{GPUBuffer/size}} 字节。
                    </div>
                1. 从 |bufferOffset| 开始将 |contents| 写入 |buffer|。
            </div>
        </div>

    : <dfn>writeTexture(destination, data, dataLayout, size)</dfn>
    ::
        将提供的数据写入 {{GPUTexture}} 中。

        <div algorithm=GPUQueue.writeTexture>
            <div data-timeline=content>
                **调用：** {{GPUQueue}} |this|.

                **参数：**

                <pre class=argumentdef for="GPUQueue/writeTexture(destination, data, dataLayout, size)">
                    |destination|:要写入的 [=texture subresource=] 和原点。
                    |data|:要写入 |destination| 的数据。
                    |dataLayout|:|data| 中内容的布局。
                    |size|:要从 |data| 写入 |destination| 的内容的范围。
                </pre>

                **返回：** {{undefined}}

                [=内容时间线=] 步骤：

                1. [=?=] [$validate GPUOrigin3D shape$](|destination|.{{GPUImageCopyTexture/origin}}).
                1. [=?=] [$validate GPUExtent3D shape$](|size|).
                1. |dataBytes| 成为 [=get a copy of the buffer source|a copy of the bytes held by the buffer source=] |data|。
                1. 在 |this| 的 [=Device timeline=] 上发布后续步骤。
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. 让 |texture| 成为 |destination|.{{GPUImageCopyTexture/texture}}。
                1. If any of the following conditions are unsatisfied,
                    如果不满足以下任何条件，则 [$generate a validation error$] 并停止。

                    <div class=validusage>
                        - [$validating GPUImageCopyTexture$](|destination|, |size|) 返回 `true`。
                        - |texture|.{{GPUTexture/usage}} 包括 {{GPUTextureUsage/COPY_DST}}。
                        - |texture|.{{GPUTexture/sampleCount}} 是 1。
                        - [=validating texture copy range=](|destination|, |size|) 返回 `true`。
                        - |destination|.{{GPUImageCopyTexture/aspect}} 必须引用 |texture|.{{GPUTexture/format}} 的单个方面。
                        - 该方面必须根据 [[#depth-formats]] 是有效的图像复制目标。
                        - 让 |aspectSpecificFormat| = |texture|.{{GPUTexture/format}}。
                        - 如果 |texture|.{{GPUTexture/format}} 是 [=depth-or-stencil format=]：
                            - 根据 [[#depth-formats]]，将 |aspectSpecificFormat| 设置为 |texture|.{{GPUTexture/format}} 的 [=aspect-specific format=]。
                        - [$validating linear texture data$](|dataLayout|,
                            |dataBytes|.[=byte sequence/length=],
                            |aspectSpecificFormat|,
                            |size|) succeeds.

                        注意：与 {{GPUCommandEncoder}}.{{GPUCommandEncoder/copyBufferToTexture()}} 不同，|dataLayout|.{{GPUImageDataLayout/bytesPerRow}} 或 |dataLayout|.{{GPUImageDataLayout/offset}} 上没有对齐要求。
                    </div>
                1. 让 |contents| 成为通过使用 |dataLayout| 和 |size| 查看 |dataBytes| 的 [=images=] 的内容。

                    问题：更正式地指定。

                    注意：这被描述为将 |data| 的所有内容复制到设备时间线，但实际上 |data| 可能比必要的大得多。实现应通过仅复制必要的字节来优化。
                1. 在 |this| 的 [=Queue timeline=] 上发布后续步骤。
            </div>
            <div data-timeline=queue>
                [=Queue timeline=] 步骤：

                1. 将 |contents| 写入 |destination|。

                    问题：定义复制，包括 snorm 的规定。
            </div>
        </div>

    : <dfn>copyExternalImageToTexture(source, destination, copySize)</dfn>
    ::
        将平台图像/画布的内容复制到目标纹理中。

        此操作根据 {{GPUImageCopyTextureTagged}} 的参数执行 [[#color-space-conversions|color encoding]] 到目标编码。

        复制到 `-srgb` 纹理会导致相同的纹理字节，而不是相同的解码值，就像复制到相应的非 `-srgb` 格式一样。因此，在复制操作之后，根据其格式是否为 `-srgb`，对目标纹理进行采样会产生不同的结果，其他都不变。

        <!-- POSTV1(srgb-linear): If added, explain here how it interacts. -->

        <div algorithm=GPUQueue.copyExternalImageToTexture>
            <div data-timeline=content>
                **调用：** {{GPUQueue}} |this|.

                **参数：**

                <pre class=argumentdef for="GPUQueue/copyExternalImageToTexture(source, destination, copySize)">
                    |source|:要复制到 |destination| 的源图像和原点。
                    |destination|:要写入的 [=texture subresource=] 和原点，以及其编码元数据。
                    |copySize|:要从 |source| 写入 |destination| 的内容的范围。
                </pre>

                **返回：** {{undefined}}

                [=内容时间线=] 步骤：

                1. [=?=] [$validate GPUOrigin2D shape$](|source|.{{GPUImageCopyExternalImage/origin}}).
                1. [=?=] [$validate GPUOrigin3D shape$](|destination|.{{GPUImageCopyTexture/origin}}).
                1. [=?=] [$validate GPUExtent3D shape$](|copySize|).
                1. 让 |sourceImage| 为 |source|.{{GPUImageCopyExternalImage/source}}
                1. 如果 |sourceImage| <l spec=html>[=is not origin-clean=]</l>，则抛出 {{SecurityError}} 并停止。
                1.  如果不满足以下任何要求，则抛出 {{OperationError}} 并停止。

                    <div class=validusage>
                        - |source|.|origin|.[=GPUOrigin3D/x=] + |copySize|.[=GPUExtent3D/width=]
                            必须 &le; the width of |sourceImage|.
                        - |source|.|origin|.[=GPUOrigin3D/y=] + |copySize|.[=GPUExtent3D/height=]
                            必须 &le; the height of |sourceImage|.
                        - |source|.|origin|.[=GPUOrigin3D/z=] + |copySize|.[=GPUExtent3D/depthOrArrayLayers=]
                            必须 &le; 1.
                    </div>
                1. 让 |usability| 为 [=?=] [=check the usability of the image argument=](|source|).
                1. 在 |this| 的 [=设备时间线=] 上发布后续步骤。
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. 让 |texture| 成为 |destination|.{{GPUImageCopyTexture/texture}}。
                1. 如果不满足以下任何要求，则 [$generate a validation error$] 并停止。

                    <div class=validusage>
                        - |usability| 必须是 `good`。
                        - |destination|.{{GPUImageCopyTexture/texture}} 必须是 [$valid to use with$] |this|。
                        - [$validating GPUImageCopyTexture$](destination, copySize) 必须返回 `true`。
                        - [=validating texture copy range=](destination, copySize) 必须返回 `true`。
                        - |texture|.{{GPUTexture/usage}} 必须包括 {{GPUTextureUsage/RENDER_ATTACHMENT}} 和 {{GPUTextureUsage/COPY_DST}}。
                        - |texture|.{{GPUTexture/dimension}} 必须是 {{GPUTextureDimension/"2d"}}。
                        - |texture|.{{GPUTexture/sampleCount}} 必须是 1。
                        - |texture|.{{GPUTexture/format}} 必须是以下格式之一
                            格式（所有这些格式都支持 {{GPUTextureUsage/RENDER_ATTACHMENT}} 用法）：
                            - {{GPUTextureFormat/"r8unorm"}}
                            - {{GPUTextureFormat/"r16float"}}
                            - {{GPUTextureFormat/"r32float"}}
                            - {{GPUTextureFormat/"rg8unorm"}}
                            - {{GPUTextureFormat/"rg16float"}}
                            - {{GPUTextureFormat/"rg32float"}}
                            - {{GPUTextureFormat/"rgba8unorm"}}
                            - {{GPUTextureFormat/"rgba8unorm-srgb"}}
                            - {{GPUTextureFormat/"bgra8unorm"}}
                            - {{GPUTextureFormat/"bgra8unorm-srgb"}}
                            - {{GPUTextureFormat/"rgb10a2unorm"}}
                            - {{GPUTextureFormat/"rgba16float"}}
                            - {{GPUTextureFormat/"rgba32float"}}
                    </div>
                1. 问题：执行实际的复制。
            </div>
        </div>

    : <dfn>submit(commandBuffers)</dfn>
    ::
        GPU 在此队列上安排执行命令缓冲区。

        提交的命令缓冲区不能再次使用。

        <div algorithm=GPUQueue.submit>
            <div data-timeline=content>
                **调用：** {{GPUQueue}} this.

                **参数：**

                <pre class=argumentdef for="GPUQueue/submit(commandBuffers)">
                    |commandBuffers|:
                </pre>

                **返回：** {{undefined}}

                [=内容时间线=] 步骤：

                1. 在 |this| 的 [=设备时间线=] 上发布后续步骤。
            </div>
            <div data-timeline=device>
                [=设备时间线=] 步骤：

                1. 如果不满足以下任何要求，则 [$generate a validation error$] 并停止。

                    <div class=validusage>
                        - |commandBuffers| 中的每个 {{GPUCommandBuffer}} 必须是 [$valid to use with$] |this|。
                        - 对于 |commandBuffers| 的任何元素中的任何命令使用的以下类型的资源：

                            <dl class=switch>
                                : {{GPUBuffer}} |b|
                                :: |b|.{{GPUBuffer/[[internals]]}}.[=buffer internals/state=] 必须是
                                     "[=buffer internals/state/available=]".
                                : {{GPUTexture}} |t|
                                :: |t|.{{GPUTexture/[[destroyed]]}} 必须是 `false`.
                                : {{GPUExternalTexture}} |et|
                                :: |et|.{{GPUExternalTexture/[[expired]]}} 必须是 `false`.
                                : {{GPUQuerySet}} |qs|
                                :: |qs| 必须处于 [=query set state/available=] 状态。对于遮挡查询，
                                    {{GPUCommandEncoder/beginRenderPass()}} 中的 {{GPURenderPassDescriptor/occlusionQuerySet}}
                                    除非也被 {{GPURenderPassEncoder/beginOcclusionQuery()}} 使用，否则不会 "used"。
                            </dl>
                    </div>

                1. 对于 |commandBuffers| 中的每个 |commandBuffer|：
                    1. 使 |commandBuffer| [=invalid=]。

                1. 在 |this| 的 [=Queue timeline=] 上发布后续步骤。
            </div>
            <div data-timeline=queue>
                [=队列时间线=] 步骤：

                1. 对于 |commandBuffers| 中的每个 |commandBuffer|：
                    1. 执行 |commandBuffer|.{{GPUCommandBuffer/[[command_list]]}} 中的每个命令。
            </div>
        </div>

    : <dfn>onSubmittedWorkDone()</dfn>
    ::
        返回一个 {{Promise}}，一旦此队列完成处理到目前为止提交的所有工作，就会解析。

        此 {{Promise}} 的解析意味着在该调用之前对 {{GPUBuffer}}s 进行的 {{GPUBuffer/mapAsync()}} 调用的完成，该调用仅在该队列上独占使用。

        <div algorithm=GPUQueue.onSubmittedWorkDone>
            <div data-timeline=content>
                **调用：** {{GPUQueue}} |this|.

                **返回：** {{Promise}}&lt;{{undefined}}&gt;

                [=内容时间线=] 步骤：

                1. 让 <var data-timeline=content>contentTimeline</var> 成为当前的 [=Content timeline=]。
                1. 让 |promise| 成为 [=a new promise=]。
                1. 在 |this| 的 [=Device timeline=] 上发布 |synchronization steps|。
                1. 返回 |promise|。
            </div>
            <div data-timeline=device>
                [=Device timeline=] |synchronization steps|:
                // [=Device timeline=] |synchronization steps|：

                1. 当 [=device timeline=] 被告知 |this| 上的所有 <span data-timeline=queue>currently-enqueued operations</span> 的完成，或者如果 |this| 丢失，或者当 |this| [=lose the device|becomes lost=] 时：
                    1. 在 <var data-timeline=content>contentTimeline</var> 上发布后续步骤。
            </div>
            <div data-timeline=content>
                [=Content timeline=] 步骤：

                1. [=Resolve=] |promise|.
            </div>
        </div>
</dl>


# 查询 # {#queries}

<h3 id=gpuqueryset data-dfn-type=interface>`GPUQuerySet`
<span id=queryset></span>
</h3>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUQuerySet {
    undefined destroy();

    readonly attribute GPUQueryType type;
    readonly attribute GPUSize32 count;
};
GPUQuerySet includes GPUObjectBase;
</script>

{{GPUQuerySet}} 有以下属性：

<dl dfn-type=attribute dfn-for=GPUQuerySet>
    : <dfn>type</dfn>
    ::
        此 {{GPUQuerySet}} 管理的查询的类型。

    : <dfn>count</dfn>
    ::
        此 {{GPUQuerySet}} 管理的查询的数量。
</dl>

{{GPUQuerySet}} 有以下内部槽：

<dl dfn-type=attribute dfn-for=GPUQuerySet>
    : <dfn>\[[state]]</dfn>, of type [=query set state=]
    ::
        此 {{GPUQuerySet}} 的当前状态。
</dl>

每个 {{GPUQuerySet}} 在 [=Device timeline=] 上都有一个当前的 <dfn dfn>query set state</dfn>，它是以下之一：

<dl dfn-type=dfn dfn-for="query set state">
    : "<dfn>available</dfn>"
    :: {{GPUQuerySet}} 可用于其内容的 GPU 操作。
    : "<dfn>destroyed</dfn>"
    :: {{GPUQuerySet}} 不再可用于除 {{GPUQuerySet/destroy}} 之外的任何操作。
</dl>

### 查询集创建 ### {#queryset-creation}

{{GPUQuerySetDescriptor}} 指定在创建 {{GPUQuerySet}} 时要使用的选项。

<script type=idl>
dictionary GPUQuerySetDescriptor
         : GPUObjectDescriptorBase {
    required GPUQueryType type;
    required GPUSize32 count;
};
</script>

<dl dfn-type=dict-member dfn-for=GPUQuerySetDescriptor>
    : <dfn>type</dfn>
    ::
        {{GPUQuerySet}} 管理的查询的类型。

    : <dfn>count</dfn>
    ::
        {{GPUQuerySet}} 管理的查询的数量。
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createQuerySet(descriptor)</dfn>
    ::
        Creates a {{GPUQuerySet}}.

        <div algorithm=GPUDevice.createQuerySet>
            <div data-timeline=content>
                **调用：** {{GPUDevice}} this.

                **参数：**

                <pre class=argumentdef for="GPUDevice/createQuerySet(descriptor)">
                    descriptor: 要创建的 {{GPUQuerySet}} 的描述。
                </pre>

                **返回：** {{GPUQuerySet}}

                [=内容时间线=] 步骤：

                1. 如果 |descriptor|.{{GPUQuerySetDescriptor/type}} 是 {{GPUQueryType/"timestamp"}}，
                    但 {{GPUFeatureName/"timestamp-query"}} 未 [=enabled for=] |this|：
                    1. 抛出 {{TypeError}}。
                1. 让 |q| 成为一个新的 {{GPUQuerySet}} 对象。
                1. 将 |q|.{{GPUQuerySet/type}} 设置为 |descriptor|.{{GPUQuerySetDescriptor/type}}。
                1. 将 |q|.{{GPUQuerySet/count}} 设置为 |descriptor|.{{GPUQuerySetDescriptor/count}}。
                1. 在 |this| 的 [=Device timeline=] 上发布 |initialization steps|。
                1. 返回 |q|。
            </div>
            <div data-timeline=device>
                [=Device timeline=] |initialization steps|:

                1. 如果不满足以下任何要求，则 [$generate a validation error$]，使 |q| [=invalid=]，并停止。

                    <div class=validusage>
                        - |this| 是 [=valid=]。
                        - |descriptor|.{{GPUQuerySetDescriptor/count}} 必须 &le; 4096。
                    </div>

                1. 将 |q|.{{GPUQuerySet/[[state]]}} 设置为 [=query set state/available=]。
            </div>
        </div>
</dl>

<div class=example>
    创建一个保存 32 个遮挡查询结果的 {{GPUQuerySet}}。

    <pre highlight=js>
        const querySet = gpuDevice.createQuerySet({
            type: 'occlusion',
            count: 32
        });
    </pre>
</div>

### 查询集销毁 ### {#queryset-destruction}

不再需要 {{GPUQuerySet}} 的应用程序可以选择在垃圾回收之前通过调用 {{GPUQuerySet/destroy()}} 来丢失对它的访问。

<dl dfn-type=method dfn-for=GPUQuerySet>
    : <dfn>destroy()</dfn>
    ::
        销毁 {{GPUQuerySet}}。

        <div algorithm=GPUQuerySet.destroy>
            <div data-timeline=content>
                **调用：** {{GPUQuerySet}} |this|.

                **返回：** {{undefined}}

                [=内容时间线=] 步骤：

                1. 将 |this|.{{GPUQuerySet/[[state]]}} 设置为 [=query set state/destroyed=]。
            </div>
        </div>
</dl>

## 查询类型 ## {#querytype}

<script type=idl>
enum GPUQueryType {
    "occlusion",
    "timestamp",
};
</script>

## 遮挡查询 ## {#occlusion}

遮挡查询仅在渲染通道上可用，用于查询一组绘图命令的所有片段测试通过的片段样本数，包括剪刀、样本掩码、alpha 到覆盖、模板和深度测试。查询的任何非零结果值都表示至少有一个样本通过了测试并到达了渲染管道的输出合并阶段，0 表示没有样本通过了测试。

在开始渲染通道时，{{GPURenderPassDescriptor}}.{{GPURenderPassDescriptor/occlusionQuerySet}} 必须设置为能够在通道期间使用遮挡查询。通过调用 {{GPURenderPassEncoder/beginOcclusionQuery()}} 和 {{GPURenderPassEncoder/endOcclusionQuery()}} 来开始和结束遮挡查询，这些调用不能嵌套。

## 时间戳查询 ## {#timestamp}

时间戳查询允许应用程序将时间戳写入 {{GPUQuerySet}}，使用：

- {{GPUCommandEncoder}}.{{GPUCommandEncoder/writeTimestamp()}}
- {{GPUComputePassDescriptor}}.{{GPUComputePassDescriptor/timestampWrites}}
- {{GPURenderPassDescriptor}}.{{GPURenderPassDescriptor/timestampWrites}}

然后使用 {{GPUCommandEncoder}}.{{GPUCommandEncoder/resolveQuerySet()}} 将时间戳值（以 64 位无符号整数的纳秒为单位）解析到 {{GPUBuffer}} 中。

时间戳查询需要 {{GPUFeatureName/"timestamp-query"}} 在设备上 [=enabled for=]。

注意：如果物理设备重置时间戳计数器，则时间戳值可能为零，请忽略它和以下值。

Issue(gpuweb/gpuweb#4069)：编写关于时间戳值重置的规范文本。

<p tracking-vector>
时间戳查询可以提供高分辨率的 GPU 计时。
有关安全考虑，请参见 [[#security-timing]]。

<div algorithm class=validusage>
    <dfn abstract-op>Validate timestampWrites</dfn>({{GPUDevice}} |device|,
    <code>({{GPUComputePassTimestampWrites}} or {{GPURenderPassTimestampWrites}})</code> |timestampWrites|)

    如果满足以下要求，则返回 `true`，否则返回 `false`。

    - {{GPUFeatureName/"timestamp-query"}} 必须 [=enabled for=] |device|.
    - |timestampWrites|.`querySet` 必须 [$valid to use with$] |device|.
    - |timestampWrites|.`querySet`.{{GPUQuerySet/type}} 必须 {{GPUQueryType/"timestamp"}}.
    - 在 |timestampWrites| 中的写入索引成员（`beginningOfPassWriteIndex`、`endOfPassWriteIndex`）中：
        - 至少有一个必须 [=map/exist|provided=]。
        - 在那些 [=map/exist|provided=] 的人中：
            - 不能有两个相等。
            - 每个必须 &lt; |timestampWrites|.`querySet`.{{GPUQuerySet/count}}。

    <!-- 编辑说明：任何其他时间戳写入位置，无论是计算还是渲染特定的，都可以在此处有条件地编写，或者在计算/渲染通道描述符验证的调用站点编写。 -->
</div>

# Canvas 渲染 # {#canvas-rendering}

## {{HTMLCanvasElement/getContext()|HTMLCanvasElement.getContext()}} ## {#canvas-getcontext}

 {{GPUCanvasContext}} 对象由  {{HTMLCanvasElement}} 中的 {{HTMLCanvasElement/getContext()}} 方法[$create a 'webgpu' context on a canvas|创建$]。
通过传递字符串字面量 `'webgpu'` 实例化其 `contextType` 参数。

<div class=example>
    从离屏的 {{HTMLCanvasElement}} 获取一个 {{GPUCanvasContext}}：

    <pre highlight=js>
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('webgpu');
    </pre>
</div>

与WebGL或2D上下文创建不同的是， {{HTMLCanvasElement/getContext()|HTMLCanvasElement.getContext()}} 或 {{OffscreenCanvas/getContext()|OffscreenCanvas.getContext()}} 的第二个参数，即上下文创建属性字典 `options` 会被忽略。而是使用 {{GPUCanvasContext/configure()|GPUCanvasContext.configure()}} 来改变画布的配置，而无需替换画布本身。

<div algorithm>
    To <dfn abstract-op>create a 'webgpu' context on a canvas</dfn>
    （{{HTMLCanvasElement}} 或 {{OffscreenCanvas}}） |canvas|:

    1. 使 |context| 成为一个新的 {{GPUCanvasContext}}.
    1. 设置 |context|.{{GPUCanvasContext/canvas}} 为 |canvas|.
    1. [$Replace the drawing buffer$] of |context|.
    1. 返回 |context|.

    注意：当调用 `getContext()` 获取 WebGPU 画布上下文时，用户代理应考虑在提供了被忽略的 `options` 参数时发出对开发者可见的警告。
</div>

## GPUCanvasContext ## {#canvas-context}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUCanvasContext {
    readonly attribute (HTMLCanvasElement or OffscreenCanvas) canvas;

    undefined configure(GPUCanvasConfiguration configuration);
    undefined unconfigure();

    GPUTexture getCurrentTexture();
};
</script>

{{GPUCanvasContext}} 有下列属性：

<dl dfn-type=attribute dfn-for=GPUCanvasContext>
    : <dfn>canvas</dfn>
    ::
         context 创建位置的画布。
</dl>

{{GPUCanvasContext}} 具有以下内部槽位（internal slots）：

<dl dfn-type=attribute dfn-for=GPUCanvasContext>
    : <dfn>\[[configuration]]</dfn>, {{GPUCanvasConfiguration}}? 类型, 初始为 `null`
    ::
        当前为该上下文配置的选项。

        如果上下文尚未配置或已被{{GPUCanvasContext/unconfigure()|取消配置}}，则为 `null`。

    : <dfn>\[[textureDescriptor]]</dfn>, {{GPUTextureDescriptor}}? 类型, 初始为 `null`
    ::
        当前配置的纹理描述符，根据{{GPUCanvasContext/[[configuration]]}}和画布派生而来。

        如果上下文尚未配置或已被{{GPUCanvasContext/unconfigure()|取消配置}}，则为 `null`。

    : <dfn>\[[drawingBuffer]]</dfn>, 图像, 初始为
        一个与画布大小相同的透明黑色图像。
    ::
        绘图缓冲区是画布的工作副本图像数据。它通过{{GPUCanvasContext/[[currentTexture]]}}（由{{GPUCanvasContext/getCurrentTexture()}}返回）可写访问。

        绘图缓冲区用于[$get a copy of the image contents of a context$]，这在画布被显示或以其他方式读取时发生。即使{{GPUCanvasContext/[[configuration]]}}.{{GPUCanvasConfiguration/alphaMode}}是{{GPUCanvasAlphaMode/"opaque"}}，它也可能是透明的。{{GPUCanvasConfiguration/alphaMode}}仅影响 [$get a copy of the image contents of a context$] 算法的结果。

        绘图缓冲区的生命周期超过{{GPUCanvasContext/[[currentTexture]]}}，并且即使画布已经呈现，它仍然包含先前渲染的内容。它只在“[$Replace the drawing buffer$]”时被清除。

        每当读取绘图缓冲区时，实现必须确保所有先前提交的工作（例如队列提交）通过{{GPUCanvasContext/[[currentTexture]]}}已完成对其的写入。

    : <dfn>\[[currentTexture]]</dfn>, {{GPUTexture}}? 类型, 初始为 `null`
    ::
        {{GPUTexture}} 用于当前帧绘制的纹理。
        它提供了对底层 {{GPUCanvasContext/[[drawingBuffer]]}} 的可写视图。
        如果 `null` ，则 {{GPUCanvasContext/getCurrentTexture()}} 会填充该槽，然后返回它。

        在可见画布的稳态下，通过 currentTexture 对绘图缓冲区进行的任何更改在 [$updating the rendering of a WebGPU canvas$] 时呈现出来。
        在此点或之前，纹理也会被销毁，{{GPUCanvasContext/[[currentTexture]]}} 被设置为 null，表示下一个调用 {{GPUCanvasContext/getCurrentTexture()}} 将创建一个新的纹理。

        {{GPUTexture/destroy()|销毁}} currentTexture 对绘图缓冲区内容没有影响，它只会提前终止对绘图缓冲区的写访问。
        在同一帧中，{{GPUCanvasContext/getCurrentTexture()}} 仍然返回相同的已销毁纹理。

        [$Expire the current texture$] 将 currentTexture 设置为 `null` 。
        它由 {{GPUCanvasContext/configure()}}、画布调整大小、呈现、{{OffscreenCanvas/transferToImageBitmap()}} 和其他操作调用。
</dl>

{{GPUCanvasContext}} 有下列方法：

<dl dfn-type=method dfn-for=GPUCanvasContext>
    : <dfn>configure(configuration)</dfn>
    ::
        配置此画布的上下文。
        这将清除绘图缓冲区，使其变为透明黑色（在 [$Replace the drawing buffer$] 中）。

        <div algorithm=GPUCanvasContext.configure>
            <div data-timeline=content>
                **Called on:** {{GPUCanvasContext}} |this|.

                **参数：**

                <pre class=argumentdef for="GPUCanvasContext/configure(configuration)">
                    |configuration|: 期望的上下文配置。
                </pre>

                **返回：** undefined

                [=Content timeline=] 步骤：

                1. 令 |device| 为 |configuration| 的 {{GPUCanvasConfiguration/device}}。
                1. [=?=] 使用 |device|.{{GPUObjectBase/[[device]]}} 验证 |configuration|.{{GPUCanvasConfiguration/format}} 的 [$Validate texture format required features$] 。
                1. [=?=] 对于 |configuration|.{{GPUTextureDescriptor/viewFormats}} 中的每个元素，使用 |device|.{{GPUObjectBase/[[device]]}} [$Validate texture format required features$] 。
                1. 令 |descriptor| 为 [$GPUTextureDescriptor for the canvas and configuration$](|this|.{{GPUCanvasContext/canvas}}, |configuration|)。
                1. 将 |this|.{{GPUCanvasContext/[[configuration]]}} 设置为 |configuration|。
                1. 将 |this|.{{GPUCanvasContext/[[textureDescriptor]]}} 设置为 |descriptor|。
                1. [$Replace the drawing buffer$]，重置 |this|.{{GPUCanvasContext/[[drawingBuffer]]}} 为具有新格式和标签的位图。
                1. 在 |device| 的 [=Device timeline=] 上执行后续步骤。
            </div>
            <div data-timeline=device>
                [=Device timeline=] 步骤：

                1. 如果以下任何要求未满足，则 [$generate a validation error$] 并停止。

                    <div class=validusage>
                        - [$validating GPUTextureDescriptor$](|device|, |descriptor|)
                            必须返回 true。
                        - [=Supported context formats=] 必须 [=set/contain=]
                            |configuration|.{{GPUCanvasConfiguration/format}}.
                    </div>

                    注意：这种早期验证在下一次 {{GPUCanvasContext/configure()}} 调用之前仍然有效，**但是**在画布调整大小时，{{GPUTextureDescriptor/size}} 的验证会发生变化。
            </div>
        </div>

    : <dfn>unconfigure()</dfn>
    ::
        移除上下文配置。销毁在配置期间创建的任何纹理。

        <div algorithm=GPUCanvasContext.unconfigure>
            <div data-timeline=content>
                **Called on:** {{GPUCanvasContext}} |this|.

                **返回：** undefined

                [=Content timeline=] 步骤：

                1. 将 |this|.{{GPUCanvasContext/[[configuration]]}} 设置为 `null`。
                1. 将 |this|.{{GPUCanvasContext/[[textureDescriptor]]}} 设置为 `null`。
                1. [$Replace the drawing buffer$]，重置 |this| 的绘图缓冲区。
            </div>
        </div>

    : <dfn>getCurrentTexture()</dfn>
    ::
        获取下一个将由 {{GPUCanvasContext}} 合成到文档中的 {{GPUTexture}}。

        <div class=note>
            注意：
            应用程序应在渲染到画布纹理的同一任务中调用 {{GPUCanvasContext/getCurrentTexture()}}。
            否则，在应用程序完成对其进行渲染之前，纹理可能会被这些步骤销毁。

            过期任务（如下所定义）是可选实现的。
            即使实现了过期任务，任务源的优先级没有明确定义，因此可能会在下一个任务中或在所有其他任务源为空之后发生（请参阅 [=automatic expiry task source=]）。
            只有在显示可见画布（[$updating the rendering of a WebGPU canvas$]）以及其他调用者 [$Replace the drawing buffer$] 时，过期才得到保证。
        </div>

        <div algorithm=GPUCanvasContext.getCurrentTexture>
            <div data-timeline=content>
                **Called on:** {{GPUCanvasContext}} |this|.

                **返回：** {{GPUTexture}}

                [=Content timeline=] 步骤：

                1. 如果 |this|.{{GPUCanvasContext/[[configuration]]}} 是 `null`：
                    1. 抛出一个 {{InvalidStateError}} 并停止。 
                1. [=Assert=] |this|.{{GPUCanvasContext/[[textureDescriptor]]}} 不是 `null`。
                1. 令 |device| 为 |this|.{{GPUCanvasContext/[[configuration]]}}.{{GPUCanvasConfiguration/device}}。
                1. 如果 |this|.{{GPUCanvasContext/[[currentTexture]]}} 是 `null`：
                    1. [$Replace the drawing buffer$]，重置 |this|.{{GPUCanvasContext/[[drawingBuffer]]}}。
                    1. 将 |this|.{{GPUCanvasContext/[[currentTexture]]}} 设置为调用 |device|.{{GPUDevice/createTexture()}} 的结果，
                        参数为 |this|.{{GPUCanvasContext/[[textureDescriptor]]}}，但使用 {{GPUTexture}} 的底层存储指向 |this|.{{GPUCanvasContext/[[drawingBuffer]]}}。

                        注意：
                        如果无法创建纹理（例如由于验证失败或内存不足），则会生成错误并返回一个无效的 {{GPUTexture}}。
                        这里的一些验证与 {{GPUCanvasContext/configure()}} 中的验证重复。实现 **不得** 跳过这些重复的验证。
                1. **可选地**，[$queue an automatic expiry task$]，使用设备 |device| 和以下步骤：

                    <div data-timeline=content>
                        1. [$Expire the current texture$]，对 |this| 执行该操作。

                            注意：如果在 [$updating the rendering of a WebGPU canvas$] 时已经发生过此操作，则其不会产生任何效果。
                    </div>
                1. 返回 |this|.{{GPUCanvasContext/[[currentTexture]]}}.
            </div>
        </div>

        注意：在 "[$Expire the current texture$]" 运行之前，每次调用 {{GPUCanvasContext/getCurrentTexture()}} 都将返回相同的 {{GPUTexture}} 对象，即使该 {{GPUTexture}} 被销毁、验证失败或分配失败。
</dl>

<div algorithm>
    To <dfn abstract-op>get a copy of the image contents of a context</dfn>:

    **参数：**

    - |context|: the {{GPUCanvasContext}}

    **返回：** image contents

    1. 确保所有提交的工作项（例如队列提交）已完成对图像（通过 |context|.{{GPUCanvasContext/[[currentTexture]]}}）的写入。
    1. 令 |snapshot| 为 |context|.{{GPUCanvasContext/[[drawingBuffer]]}} 的副本。
    1. 令 |alphaMode| 为 |context|.{{GPUCanvasContext/[[configuration]]}}.{{GPUCanvasConfiguration/alphaMode}}。
    1.
        <dl class=switch>
            : 如果 |alphaMode| 是 {{GPUCanvasAlphaMode/"opaque"}}:
            ::
                1. 将 |snapshot| 的 alpha 通道清除为 1.0。
                1. 将 |snapshot| 标记为不透明。

                注意：
                如果 {{GPUCanvasContext/[[currentTexture]]}}（如果有的话）已被销毁（例如在 [$Replace the drawing buffer$] 中），则无法观察到 alpha 通道，实现可能会原地清除 alpha 通道。

            : 否则:
            :: 使用 |alphaMode| 对 |snapshot| 进行标记。
        </dl>

    1. 返回 |snapshot|。

    <!-- POSTV1(desynchronized): If a "desynchronized" option is added, explicitly describe its behavior here. -->
</div>

<div algorithm>
    对 {{GPUCanvasContext}} |context| 执行 <dfn abstract-op>Replace the drawing buffer</dfn> ：

    1. [$Expire the current texture$]，对 |context| 执行该操作。
    1. 令 |configuration| 为 |context|.{{GPUCanvasContext/[[configuration]]}}。
    1. 将 |context|.{{GPUCanvasContext/[[drawingBuffer]]}} 设置为与 |context|.{{GPUCanvasContext/canvas}} 相同尺寸的透明黑色图像。

        - 如果 |configuration| 为 null，则绘图缓冲区标记为颜色空间 {{PredefinedColorSpace/"srgb"}}。
            在这种情况下，绘图缓冲区将保持空白，直到配置上下文。
        - 如果不是，则绘图缓冲区具有指定的 |configuration|.{{GPUCanvasConfiguration/format}}，
            并带有指定的 |configuration|.{{GPUCanvasConfiguration/colorSpace}} 标记。

    注意：在 "[$get a copy of the image contents of a context$]" 之前，将忽略 |configuration|.{{GPUCanvasConfiguration/alphaMode}}。

    注意：如果绘图缓冲区已经被清除并具有正确的配置，这通常不会产生任何操作。        
</div>

<div algorithm>
     <dfn abstract-op>Expire the current texture</dfn> 作用于一个 {{GPUCanvasContext}} |context|:

    1. 如果 |context|.{{GPUCanvasContext/[[currentTexture]]}} 不为 `null`:
        1. 调用 |context|.{{GPUCanvasContext/[[currentTexture]]}}.{{GPUTexture/destroy()}}(不销毁 |context|.{{GPUCanvasContext/[[drawingBuffer]]}})终止图像的写权限。
        1. 将 |context|.{{GPUCanvasContext/[[currentTexture]]}} 设定为 `null`.
</div>

## HTML 规范 Hooks ## {#canvas-hooks}

以下算法 "hook" 到 HTML 规范中的算法中，并必须在指定的时机运行。

<div algorithm="get the bitmap of a WebGPU canvas">
    当从具有 {{GPUCanvasContext}} |context| 的 {{HTMLCanvasElement}} 或 {{OffscreenCanvas}} 读取 "位图(bitmap)" 时：

    1. 返回 |context| 的 [$get a copy of the image contents of a context|图像副本$]。
        <div class=note>
            注意：
            这种情况发生在许多地方，包括：

            - 当 {{HTMLCanvasElement}} 的渲染更新时。
            - 当具有 [=placeholder canvas element=] 的 {{OffscreenCanvas}} 的渲染更新时。
            - 当通过 {{OffscreenCanvas/transferToImageBitmap()}} 从位图创建 {{ImageBitmap}} 时。
            - 当使用其他 Web API（如 {{CanvasDrawImage/drawImage()}}、`texImage2D()`、`texSubImage2D()`、{{HTMLCanvasElement/toDataURL()}} 、 {{HTMLCanvasElement/toBlob()}} 等）读取 WebGPU 画布内容时。

            如果 {{GPUCanvasConfiguration/alphaMode}} 是 {{GPUCanvasAlphaMode/"opaque"}}，
            这将导致 alpha 通道被清除。当实现能够以忽略 alpha 通道的方式读取或显示图像时，实现可能会跳过此步骤。

            如果应用程序仅需要用于交互操作（而非呈现），则在不需要时避免使用 {{GPUCanvasAlphaMode/"opaque"}}。
        </div>
</div>

<div algorithm>
    当 <dfn abstract-op>updating the rendering of a WebGPU canvas</dfn>
    （一个 {{HTMLCanvasElement}} 或一个具有 [=placeholder canvas element=] 的 {{OffscreenCanvas}}）
    在具有 {{GPUCanvasContext}} |context| 的 {{HTMLCanvasElement}} 或具有 [=placeholder canvas element=] 的 {{OffscreenCanvas}} 中，
    这会在 [=event loop processing model=] 的以下子步骤中发生：

    - "更新 `Document` 的渲染或用户界面"
    - "更新专用 worker 的渲染"

    执行以下步骤：

    1. 对 |context| 运行 [$Expire the current texture$]。

    注意：如果这已经在由 {{GPUCanvasContext/getCurrentTexture()}} 排队的任务中发生过，
    则没有任何效果。

    注意：
    这不适用于独立的 {{OffscreenCanvas}}（通过 `new OffscreenCanvas()` 创建的）。
</div>

<div algorithm="transferToImageBitmap from WebGPU">
    当在具有 {{GPUCanvasContext}} |context| 的画布上调用 {{OffscreenCanvas/transferToImageBitmap()}} 时，在从画布的位图创建 {{ImageBitmap}} 后：

    1. 对 |context| 运行 [$Replace the drawing buffer$]。

    注意：这相当于将（可能已清除 alpha 通道）的图像内容 "移动" 到 ImageBitmap 中，而不进行复制。
</div>

## GPU画布配置(CanvasConfiguration) ## {#canvas-configuration}

 <dfn dfn>supported context formats</dfn> 是一个 [=set=] 的 {{GPUTextureFormat}}，当作为 {{GPUCanvasConfiguration}}.{{GPUCanvasConfiguration/format}} 指定时，
无论给定的 {{GPUCanvasConfiguration}}.{{GPUCanvasConfiguration/device}} 如何，都必须支持这些格式。
初始设置为：«;{{GPUTextureFormat/"bgra8unorm"}}, {{GPUTextureFormat/"rgba8unorm"}}, {{GPUTextureFormat/"rgba16float"}}»。

注意：画布配置不能使用 `srgb` 格式，如 {{GPUTextureFormat/"bgra8unorm-srgb"}}。而应使用非 `srgb` 等效格式（{{GPUTextureFormat/"bgra8unorm"}}），在 {{GPUCanvasConfiguration/viewFormats}} 中指定 `srgb` 格式，并使用 {{GPUTexture/createView()}} 创建具有 `srgb` 格式的视图。

<script type=idl>
enum GPUCanvasAlphaMode {
    "opaque",
    "premultiplied",
};

dictionary GPUCanvasConfiguration {
    required GPUDevice device;
    required GPUTextureFormat format;
    GPUTextureUsageFlags usage = 0x10;  // GPUTextureUsage.RENDER_ATTACHMENT
    sequence<GPUTextureFormat> viewFormats = [];
    PredefinedColorSpace colorSpace = "srgb";
    GPUCanvasAlphaMode alphaMode = "opaque";
};
</script>

{{GPUCanvasConfiguration}} 有下列成员：

<dl dfn-type=dict-member dfn-for=GPUCanvasConfiguration>
    : <dfn>device</dfn>
    ::
        {{GPUCanvasContext/getCurrentTexture()}} 返回的纹理与之兼容的 {{GPUDevice}}。

    : <dfn>format</dfn>
    ::
        {{GPUCanvasContext/getCurrentTexture()}} 返回的纹理格式。
        必须是 [=Supported context formats=] 中的一个。

    : <dfn>usage</dfn>
    ::
        {{GPUCanvasContext/getCurrentTexture()}} 返回的纹理使用方式。
        {{GPUTextureUsage/RENDER_ATTACHMENT}} 是默认值，但如果显式设置了使用方式，则不会自动包括它。
        如果希望将{{GPUCanvasContext/getCurrentTexture()}}返回的纹理用作渲染通道的颜色目标，请确保在设置自定义使用方式时包括{{GPUTextureUsage/RENDER_ATTACHMENT}}。

    : <dfn>viewFormats</dfn>
    ::
        从{{GPUCanvasContext/getCurrentTexture()}}返回的纹理创建的视图可以使用的格式。

    : <dfn>colorSpace</dfn>
    ::
        {{GPUCanvasContext/getCurrentTexture()}} 返回的纹理中写入的值应该使用的颜色空间进行显示。

    : <dfn>alphaMode</dfn>
    ::
        确定 alpha 值对从 {{GPUCanvasContext/getCurrentTexture()}} 返回的纹理内容在读取、显示或用作图像源时的影响。
</dl>

<div class=example>
    使用特定的 {{GPUDevice}} 配置 {{GPUCanvasContext}}，使用此context的首选格式：

    <pre highlight=js>
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('webgpu');

        context.configure({
            device: gpuDevice,
            format: navigator.gpu.getPreferredCanvasFormat(),
        });
    </pre>
</div>

<div algorithm>
    The <dfn abstract-op>GPUTextureDescriptor for the canvas and configuration</dfn>(
    ({{HTMLCanvasElement}} 或 {{OffscreenCanvas}}) |canvas|,
    {{GPUCanvasConfiguration}} |configuration|)
    是有以下成员的 {{GPUTextureDescriptor}} ：

    - {{GPUTextureDescriptor/size}}: [|canvas|.width, |canvas|.height, 1].
    - {{GPUTextureDescriptor/format}}: |configuration|.{{GPUCanvasConfiguration/format}}.
    - {{GPUTextureDescriptor/usage}}: |configuration|.{{GPUCanvasConfiguration/usage}}.
    - {{GPUTextureDescriptor/viewFormats}}: |configuration|.{{GPUCanvasConfiguration/viewFormats}}.

    并将其他成员设置为它们的默认值。

    |canvas|.width 表示 {{HTMLCanvasElement}}.{{HTMLCanvasElement/width}} 或 {{OffscreenCanvas}}.{{OffscreenCanvas/width}}.
    |canvas|.height 表示 {{HTMLCanvasElement}}.{{HTMLCanvasElement/height}} 或 {{OffscreenCanvas}}.{{OffscreenCanvas/height}}.
</div>

### 画布颜色空间 ### {#canvas-color-space}

在演示过程中，色值在 [0, 1] 范围之外的色度不应被截断至该范围；当{{GPUCanvasConfiguration/format}}和用户的显示能力允许时，可以使用扩展值来显示画布 “颜色空间” 原色定义之外的颜色。
这与亮度相反，亮度应被截断至最大标准动态范围亮度。

<!-- POSTV1(HDR canvases): ... unless HDR is explicitly enabled for the canvas element. -->

### 画布上下文的尺寸调整(Context sizing) ### {#context-sizing}

所有画布配置都在{{GPUCanvasContext/configure()}}中进行设置，除了画布的分辨率，分辨率是通过画布的 `width` 和 `height` 来设置的。

注意：
与WebGL和2D画布一样，调整WebGPU画布的大小会导致绘图缓冲区的当前内容丢失。
在WebGPU中，它通过[$Replace the drawing buffer|replacing the drawing buffer$]来实现这一点。

<div algorithm>
    当具有{{GPUCanvasContext}} |context|的{{HTMLCanvasElement}}或{{OffscreenCanvas}} |canvas|的 `width` 或 `height` 属性被修改时，
    <dfn abstract-op>update the canvas size</dfn>:

    1. [$Replace the drawing buffer$]为 |context|。
    1. 将 |configuration| 设为 |context|.{{GPUCanvasContext/[[configuration]]}}。
    1. 如果 |configuration| 不为 `null`：
        1. 将 |context|.{{GPUCanvasContext/[[textureDescriptor]]}} 设置为
            [$GPUTextureDescriptor for the canvas and configuration$]（|canvas|, |configuration|）。

    注意：这可能导致{{GPUTextureDescriptor}}超过设备的{{supported limits/maxTextureDimension2D}}。
    在这种情况下，验证将在{{GPUCanvasContext/getCurrentTexture()}}中失败。
</div>

<div class=example>
    响应画布大小调整，使用[ResizeObserver](https://www.w3.org/TR/resize-observer/)监测画布大小变化，并重新配置{{GPUCanvasContext}}以获取画布的准确像素尺寸：

    <pre highlight=js>
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('webgpu');

        const resizeObserver = new ResizeObserver(entries => {
            for (const entry of entries) {
                if (entry.target != canvas) { continue; }
                canvas.width = entry.devicePixelContentBoxSize[0].inlineSize;
                canvas.height = entry.devicePixelContentBoxSize[0].blockSize;
            }
        });
        resizeObserver.observe(canvas);
    </pre>
</div>

<h3 id=gpucanvasalphamode data-dfn-type=enum>`GPUCanvasAlphaMode`
<span id=GPUCanvasAlphaMode></span>
</h3>

此枚举用于选择当读取画布内容时，画布的内容在[$get a copy of the image contents of a context|显示到屏幕或作为图像源$]（在drawImage、toDataURL等中使用）时将如何被解释。

以下，`src` 是画布纹理中的值，`dst` 是画布被合成到的图像（例如HTML页面渲染或2D画布）。

<dl dfn-type=enum-value dfn-for=GPUCanvasAlphaMode>
    : <dfn>"opaque"</dfn>
    ::
        将 RGB 作为不透明色，并忽略 alpha 值。
        如果内容尚未不透明，则在 "[$get a copy of the image contents of a context$]" 中将 alpha 通道清除为 1.0。

    : <dfn>"premultiplied"</dfn>
    ::
        以预乘方式读取 RGBA：颜色值通过其 alpha 值进行预乘。
        50% alpha 的 100% 红色为 `[0.5, 0, 0, 0.5]`。

        如果输出到画布的[=out-of-gamut premultiplied RGBA values=]，且画布是：

        <dl class=switch>
            : [$get a copy of the image contents of a context|作为图像源$]
            :: 值将按照 [[#color-space-conversions|颜色空间转换]] 中描述的方式进行保留。

            : 显示到屏幕
            :: 合成结果是未定义的。即使在合成之前颜色空间转换会产生在色域内的值也是如此，因为合成的中间格式没有指定。
        </dl>
</dl>

# 错误 &amp; 调试 # {#errors-and-debugging}

在一般情况下，WebGPU的正常操作过程中，通过[$dispatch error$]来引发错误。


在设备 [=lose the device|丢失=]（描述如下） 后，不再暴露错误。
此时，实现不需要运行验证或错误跟踪：
{{GPUDevice/popErrorScope()}} 和 {{GPUDevice/uncapturederror}} 停止报告错误，
并且设备上对象的有效性变得不可观察。

此外，设备丢失本身不会产生错误。
相反的，{{GPUDevice}}.{{GPUDevice/lost}} promise 解析来指示设备已丢失。

## 致命错误 ## {#fatal-errors}

<script type=idl>
enum GPUDeviceLostReason {
    "unknown",
    "destroyed",
};

[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUDeviceLostInfo {
    readonly attribute GPUDeviceLostReason reason;
    readonly attribute DOMString message;
};

partial interface GPUDevice {
    readonly attribute Promise<GPUDeviceLostInfo> lost;
};
</script>

{{GPUDevice}} 有下列额外的属性：

<dl dfn-type=attribute dfn-for=GPUDevice>
    : <dfn>lost</dfn>
    ::
        一个 [=slot-backed attribute=] 持有一个 promise，该 promise 在设备创建时创建，设备的生命周期内保持 pending，然后在设备丢失时解析。
        在初始化时，它被设置为 [=a new promise=]。
</dl>

<h3 id=gpuerror data-dfn-type=interface>`GPUError`
<span id=error></span>
</h3>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUError {
    readonly attribute DOMString message;
};
</script>

{{GPUError}} 是从 {{GPUDevice/popErrorScope()}} 和 {{GPUDevice/uncapturederror}} 事件中暴露的所有错误的基本接口。

错误只能在其各自的算法中明确说明可能生成的条件和生成的错误子类型的操作中生成。

在设备丢失后不会生成错误。参见[[#errors-and-debugging]]。

注意：{{GPUError}} 可能在本规范的将来版本中获得新的子类型。应用程序应该处理这种可能性，尽可能使用错误的 {{GPUError/message}}，并使用 `instanceof` 进行特化。当需要序列化错误（例如，进入 JSON，用于调试报告）时，请使用 `error.constructor.name`。

{{GPUError}} 具有以下属性：

<dl dfn-type=attribute dfn-for=GPUError>
    : <dfn>message</dfn>
    ::
        一个人类可读的，提供有关发生的错误的信息的 [=localizable text=] 消息。

        注意：此消息通常用于应用程序开发人员调试其应用程序并捕获调试报告的信息，而不是向最终用户显示。

        注意：用户代理不应在此消息中包含可能的机器可解析细节，例如 {{GPUErrorFilter/"out-of-memory"}} 上的空闲系统内存或内存耗尽的其他条件的其他细节。

        注意：{{GPUError/message}} 应遵循 [=best practices for language and direction information=]。这包括利用可能出现的任何关于报告字符串语言和方向元数据的未来标准。

        <p class="note editorial">Editorial:
        在撰写本文时，尚无可用的语言/方向建议，可与遗留 API 兼容并保持一致，但是当有时，请正式采用它。
</dl>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUValidationError
        : GPUError {
    constructor(DOMString message);
};
</script>

{{GPUValidationError}} 是 {{GPUError}} 的子类型，它指示操作未满足所有验证要求。验证错误始终表示应用程序错误，并且预计在使用相同的 {{device/[[features]]}} 和 {{device/[[limits]]}} 的所有设备上以相同的方式失败。

<div algorithm>
    为 {{GPUDevice}} |device| <dfn abstract-op lt="Generate a validation error|generate a validation error|validation error">generate avalidation error</dfn>，运行以下步骤：

    <div data-timeline=content>
        [=Content timeline=] 步骤：

        1. 让 |error| 成为一个带有适当错误消息的新 {{GPUValidationError}}。
        1. [$Dispatch error$] |error| 到 |device|。
    </div>
</div>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUOutOfMemoryError
        : GPUError {
    constructor(DOMString message);
};
</script>

{{GPUOutOfMemoryError}} 是 {{GPUError}} 的子类型，它指示没有足够的空闲内存来完成所请求的操作。如果使用较低的内存要求（例如使用较小的纹理尺寸）再次尝试操作，或者首先释放其他资源使用的内存，则操作可能会成功。

<div algorithm>
    为 {{GPUDevice}} |device| <dfn abstract-op lt="Generate an out-of-memory error|generate an out-of-memory error|out-of-memory error">generate an out-of-memory error</dfn>，运行下列步骤

    <div data-timeline=content>
        [=Content timeline=] 步骤：

        1. 让 |error| 成为一个带有适当错误消息的新 {{GPUOutOfMemoryError}}。
        1. [$Dispatch error$] |error| 到 |device|。
    </div>
</div>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUInternalError
        : GPUError {
    constructor(DOMString message);
};
</script>

{{GPUInternalError}} 是 {{GPUError}} 的子类型，它指示即使满足了所有验证要求，操作也因系统或实现特定原因而失败。
例如，操作可能以一种不容易被[=supported limits=]捕捉到的方式超出了实现的能力。相同的操作可能在其他设备上或在不同的情况下成功。



<div algorithm>
    对于{{GPUDevice}} |device| <dfn abstract-op lt="Generate an internal error|generate an internal error|internal error">generate an internal error</dfn>，运行以下步骤：

    <div data-timeline=content>
        [=Content timeline=] 步骤：

        1. 让 |error| 成为一个带有适当错误消息的新 {{GPUInternalError}}。
        1. [$Dispatch error$] |error| 到 |device|。
    </div>
</div>

## 错误范围 ## {#error-scopes}

一个 <dfn dfn>GPU error scope</dfn> 捕获在当前[=GPU error scope=]中生成的 {{GPUError}}。错误范围用于隔离在一组 WebGPU 调用中发生的错误，通常用于调试目的或使操作更具容错性。

[=GPU error scope=] 有以下内部槽（slot）：
<dl dfn-type=attribute dfn-for="GPU error scope">
    : <dfn>\[[errors]]</dfn>， 类型为 [=list=]&lt;{{GPUError}}&gt;，初始值 []
    ::
        当前[=GPU error scope=]中观察到的 {{GPUError}}（如果有）。

    : <dfn>\[[filter]]</dfn>，类型为 {{GPUErrorFilter}}
    ::
        确定此 [=GPU error scope=] 观察的 {{GPUError}} 的类型。
</dl>

<script type=idl>
enum GPUErrorFilter {
    "validation",
    "out-of-memory",
    "internal",
};

partial interface GPUDevice {
    undefined pushErrorScope(GPUErrorFilter filter);
    Promise<GPUError?> popErrorScope();
};
</script>

{{GPUErrorFilter}} 定义了在调用 {{GPUDevice/pushErrorScope()}} 时应该捕获的错误类型：

{{GPUDevice/pushErrorScope()}}:

<dl dfn-type=enum-value dfn-for=GPUErrorFilter>
    : <dfn>"validation"</dfn>
    ::
        表示错误范围将捕获 {{GPUValidationError}}。

    : <dfn>"out-of-memory"</dfn>
    ::
        表示错误范围将捕获 {{GPUOutOfMemoryError}}。

    : <dfn>"internal"</dfn>
    ::
        表示错误范围将捕获 {{GPUInternalError}}。
</dl>

{{GPUDevice}} 有以下内部槽（slot）：

<dl dfn-type=attribute dfn-for=GPUDevice>
    : <dfn>\[[errorScopeStack]]</dfn>，类型为 [=stack=]&lt;[=GPU error scope=]&gt;
    ::
        已推送到 {{GPUDevice}} 的 [=GPU error scopes=] 的 [=stack=]。
</dl>

<div algorithm>
    {{GPUError}} |error| 和 {{GPUDevice}} |device| 的 <dfn abstract-op>current error scope</dfn> 由向 |device| 的 [=Device timeline=] 发出以下步骤来确定：

    <div data-timeline=device>
        [=Device timeline=] 步骤：

        1. 如果 |error| 是以下实例之一：

            <dl class=switch>
                : {{GPUValidationError}}
                :: 令 |type| 为 "validation"。
                : {{GPUOutOfMemoryError}}
                :: 令 |type| 为 "out-of-memory"。
                : {{GPUInternalError}}
                :: 令 |type| 为 "internal"。
            </dl>
        1. 令 |scope| 为 |device|.{{GPUDevice/[[errorScopeStack]]}} 的最后一个 [=list/item=]。
        1. 当 |scope| 不是 `undefined` 时：
            1. 如果 |scope|.{{GPU error scope/[[filter]]}} 是 |type|，则返回 |scope|。
            1. 将 |scope| 设置为 |device|.{{GPUDevice/[[errorScopeStack]]}} 的前一个 [=list/item=]。
        1. 返回 `undefined`。
    </div>
</div>

<div algorithm>
    要在 {{GPUDevice}} |device| 上 <dfn abstract-op lt="Dispatch error|dispatch error">dispatch an error</dfn> {{GPUError}} |error|，请在 |device| 的 [=Device timeline=] 上运行以下步骤：


    <div data-timeline=device>
        [=Device timeline=] 步骤：

        1. 如果 |device| 是 [=invalid|lost=]，则返回。

            注意：设备丢失后不会生成任何错误。请参阅 [[#errors-and-debugging]]。
        1. 令 |scope| 为 |error| 和 |device| 的 [$current error scope$]。
        1. 如果 |scope| 不是 `undefined`：
            1. 将 |error| [=list/Append=]到 |scope|.{{GPU error scope/[[errors]]}}。
            1. 返回。
        1. 否则向 [=Content timeline=] 发出以下步骤：
    </div>
    <div data-timeline=content>
        [=Content timeline=] 步骤：

        1. 如果用户代理选择，[$queue a global task for GPUDevice$] |device|，并执行以下步骤：

            <div data-timeline=content>
                1. 在 |device| 上触发一个名为 "{{GPUDevice/uncapturederror}}" 的 {{GPUUncapturedErrorEvent}}，其 {{GPUUncapturedErrorEvent/error}} 为 |error|。
            </div>

        注意：如果（且仅当）没有注册 {{GPUDevice/uncapturederror}} 处理程序，则用户代理**应该**将未捕获的错误显示给开发人员，例如作为浏览器开发人员控制台中的警告。
    </div>

    注意：用户代理可以选择限制 {{GPUDevice}} 可以引发的 {{GPUUncapturedErrorEvent}} 的数量，以防止过多的错误处理或日志记录影响性能。
</div>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>pushErrorScope(filter)</dfn>
    ::
        将一个新的 [=GPU error scope=] 推入 |this| 的 {{GPUDevice/[[errorScopeStack]]}}。

        <div algorithm=GPUDevice.pushErrorScope>
            <div data-timeline=content>
                **Called on:** {{GPUDevice}} |this|.

                **参数：**

                <pre class=argumentdef for="GPUDevice/pushErrorScope(filter)">
                    |filter|: 此错误范围观察的错误类。
                </pre>

                **返回：** {{undefined}}

                [=Content timeline=] 步骤：

                1. 在 |this| 的 [=Device timeline=] 上发出后续步骤。
            </div>
            <div data-timeline=device>
                [=Device timeline=] 步骤：

                1. 令 |scope| 为一个新的 [=GPU error scope=]。
                1. 将 |scope|.{{GPU error scope/[[filter]]}} 设置为 |filter|。
                1. 将 |scope| [=stack/Push=]到 |this|.{{GPUDevice/[[errorScopeStack]]}}。
            </div>
        </div>

    : <dfn>popErrorScope()</dfn>
    ::
        从 |this| 的 {{GPUDevice/[[errorScopeStack]]}} 弹出一个 [=GPU error scope=]，并解析为错误范围观察到的**任何** {{GPUError}}，如果没有则为 `null`。

        不能保证承诺解析的顺序。

        <div algorithm=GPUDevice.popErrorScope>
            <div data-timeline=content>
                **Called on:** {{GPUDevice}} |this|.

                **返回：** {{Promise}}&lt;{{GPUError}}?&gt;

                [=Content timeline=] 步骤：

                1. 令<var data-timeline=content>contentTimeline</var>为当前[=Content timeline=]。
                1. 令|promise|为[=a new promise=]。
                1. 在|this|的[=Device timeline=]上发出|check steps|。
                1. 返回|promise|。
            </div>
            <div data-timeline=device>
                [=Device timeline=] |check steps|：

                1. 如果 |this| 是 [=invalid|lost=]，则在 <var data-timeline=content>contentTimeline</var> 上发出以下步骤并返回：

                    <div data-timeline=content>
                        [=Content timeline=] 步骤：

                        1. 用 `null` [=Resolve=] |promise|。
                    </div>

                    注意：设备丢失后不会生成错误。请参阅 [[#errors-and-debugging]]。

                1. 如果以下任何要求不满足：

                    <div class=validusage>
                        - |this|.{{GPUDevice/[[errorScopeStack]]}}.[=list/size=] 必须 &gt; 0。
                    </div>

                    然后在 <var data-timeline=content>contentTimeline</var> 上发出以下步骤并返回：

                    <div data-timeline=content>
                        [=Content timeline=] 步骤：

                        1. 用 {{OperationError}} [=Reject=] |promise|。
                    </div>

                1. 令 |scope| 为从 |this|.{{GPUDevice/[[errorScopeStack]]}} [=stack/pop|popping=]一个 [=list/item=] 的结果。
                1. 令 |error| 为 |scope|.{{GPU error scope/[[errors]]}} 中的**任何**一个，如果没有则为 `null`。

                    对于列表中的任何两个错误 E1 和 E2，如果 E2 是由 E1 导致的，则**不应该**选择 E2。

                    注意：
                    例如，如果 E1 来自 `t` = {{GPUDevice/createTexture()}}，并且 E2 来自 `t`.{{GPUTexture/createView()}}，因为 `t` 是 [=invalid=]，则应该优先选择 E1，因为开发人员更容易理解出了什么问题。
                    由于这两个都是 {{GPUValidationError}}，唯一的区别在于 {{GPUError/message}} 字段，而这个字段本来就是为人类阅读而设计的。

                1. 在**现在或将来的某个未指定的时间点**，在 <var data-timeline=content>contentTimeline</var> 上发出后续步骤。

                    注意：
                    通过允许 {{GPUDevice/popErrorScope()}} 调用以任何顺序解析，以及允许使用范围内观察到的任何错误，该规范允许验证以任意顺序完成，只要任何状态观察都是在遵守该规范的适当时间点进行的。例如，这允许实现在后台线程上执行仅取决于非状态输入的着色器编译，以与其他设备时间线工作并行完成，并稍后报告任何导致的错误。
            </div>
            <div data-timeline=content>
                [=Content timeline=] 步骤：

                1. 用 |error| [=Resolve=] |promise|。
            </div>
        </div>
</dl>

<div class=example>
    使用错误范围来捕获可能失败的 {{GPUDevice}} 操作的验证错误：

    <pre highlight=js>
        gpuDevice.pushErrorScope('validation');

        let sampler = gpuDevice.createSampler({
            maxAnisotropy: 0, // Invalid, maxAnisotropy must be at least 1.
        });

        gpuDevice.popErrorScope().then((error) => {
            if (error) {
                // There was an error creating the sampler, so discard it.
                sampler = null;
                console.error(\`An error occured while creating sampler: ${error.message}\`);
            }
        });
    </pre>
</div>

<div class=note>
注意：错误范围可以涵盖尽可能多的命令。错误范围覆盖的命令数量通常与应用程序对错误的响应行为相关。

例如：一个只包含创建单个资源（如纹理或缓冲区）的错误范围可以用于检测失败情况，比如内存不足的情况，此时应用程序可以尝试释放一些资源并再次进行分配。

然而，错误范围并不标识哪个命令失败。因此，例如将加载模型期间执行的所有命令包装在一个单独的错误范围中将无法提供足够的细粒度来确定问题是否是由于内存限制引起的。因此，释放资源通常不是对该范围的失败做出的有效响应。更合适的响应应该是允许应用程序回退到不同的模型或产生一个无法加载模型的警告。如果希望对内存限制作出响应，分配内存的操作总是可以包装在一个较小的嵌套错误范围中。
</div>

## 遥测 ## {#telemetry}

当一个 {{GPUError}} 被生成，但没有被任何 [=GPU error scope=] 观察到时，用户代理**可能**会使用 {{GPUUncapturedErrorEvent}} 在 {{GPUDevice}} 上 [=fire an event=]，并命名为 <dfn event for=GPUDevice>uncapturederror</dfn>。

注意：{{GPUDevice/uncapturederror}} 事件旨在用于遥测和报告意外错误。它们可能不会被分派给所有未捕获的错误（例如，可能存在一个限制，用于显示的错误数量），并且不应该用于处理在应用程序正常运行期间可能发生的已知错误情况。在这些情况下，应该优先使用 {{GPUDevice/pushErrorScope()}} 和 {{GPUDevice/popErrorScope()}}。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUUncapturedErrorEvent : Event {
    constructor(
        DOMString type,
        GPUUncapturedErrorEventInit gpuUncapturedErrorEventInitDict
    );
    [SameObject] readonly attribute GPUError error;
};

dictionary GPUUncapturedErrorEventInit : EventInit {
    required GPUError error;
};
</script>

{{GPUUncapturedErrorEvent}} 有以下属性：

<dl dfn-type=attribute dfn-for=GPUUncapturedErrorEvent>
    : <dfn>error</dfn>
    ::
        一个 [=slot-backed attribute=]，保存一个表示未捕获的错误的对象。它的类型与 {{GPUDevice/popErrorScope()}} 返回的错误相同。
</dl>

<script type=idl>
partial interface GPUDevice {
    [Exposed=(Window, DedicatedWorker)]
    attribute EventHandler onuncapturederror;
};
</script>

{{GPUDevice}} 有以下属性：

<dl dfn-type=attribute dfn-for=GPUDevice>
    : <dfn>onuncapturederror</dfn>
    ::
        {{GPUDevice/uncapturederror}} 事件类型的一个 [=event handler IDL attribute=]。
</dl>

<div class=example>
    监听 {{GPUDevice}} 的未捕获错误：

    <pre highlight=js>
        gpuDevice.addEventListener('uncapturederror', (event) => {
            // Re-surface the error, because adding an event listener may silence console logs.
            console.error('A WebGPU error was not captured:', event.error);

            myEngineDebugReport.uncapturedErrors.push({
                type: event.error.constructor.name,
                message: event.error.message,
            });
        });
    </pre>
</div>

# 详细操作 # {#detailed-operations}

 这一部分描述了各种 GPU 操作的细节。

问题：这一部分是不完整的。

## Transfer ## {#transfer-operations}

<p class="note editorial">Editorial: describe the transfers at the high level

## 计算 ## {#computing-operations}

计算操作提供了对 GPU 可编程硬件的直接访问。计算着色器没有着色器阶段的输入或输出，它们的结果是将数据写入绑定为 {{GPUBufferBindingType/"storage"|GPUBufferBindingType."storage"}} 和 {{GPUStorageTextureBindingLayout}} 的存储绑定中的副作用。这些操作在 {{GPUComputePassEncoder}} 中被编码为：

- {{GPUComputePassEncoder/dispatchWorkgroups()}}
- {{GPUComputePassEncoder/dispatchWorkgroupsIndirect()}}

<p class="note editorial">Editorial: describe the computing algorithm

如果着色器没有在合理的时间内 [=shader execution end|执行完毕=]，由用户代理决定，那么 [=device=] 可能会 [=lose the device|丢失设备=]。

## 渲染 ## {#rendering-operations}

渲染是通过一组 GPU 操作来完成的，这些操作在 {{GPURenderPassEncoder}} 中执行，并导致纹理数据的修改，这些纹理数据由渲染通道附件查看。这些操作是用以下方式编码的：

- {{GPURenderCommandsMixin/draw()}}
- {{GPURenderCommandsMixin/drawIndexed()}},
- {{GPURenderCommandsMixin/drawIndirect()}}
- {{GPURenderCommandsMixin/drawIndexedIndirect()}}.

注意：渲染是 GPU 的传统用法，并且由硬件中的多个固定功能块支持。

主要的渲染算法：

<div algorithm>
    <dfn abstract-op>render</dfn>(descriptor, drawCall, state)

        **参数：**

        - |descriptor|: 当前{{GPURenderPipeline}}的描述。
        - |drawCall|: 绘制调用参数。
        - |state|: 在发出绘制调用的{{GPURenderCommandsMixin}}的渲染状态[=RenderState=]。

        1. **解析索引**。参见 [[#index-resolution]]。

            让 |vertexList| 成为 [$resolve indices$](|drawCall|, |state|) 的结果。

        1. **处理顶点**。参见 [[#vertex-processing]]。

            执行 [$process vertices$](|vertexList|, |drawCall|, |descriptor|.{{GPURenderPipelineDescriptor/vertex}}, |state|)。

        1. **组装原语**。参见 [[#primitive-assembly]]。

            执行 [$assemble primitives$](|vertexList|, |drawCall|, |descriptor|.{{GPURenderPipelineDescriptor/primitive}})。

        1. **裁剪原语**。参见 [[#primitive-clipping]]。

            让 |primitiveList| 成为这个阶段的结果。

        1. **光栅化**。参见 [[#rasterization]]。

            让 |rasterizationList| 成为 [$rasterize$](|primitiveList|, |state|) 的结果。

        1. **处理片段**。参见 [[#fragment-processing]]。

            收集一个 |fragments| 列表，该列表是由执行 [$process fragment$](|rasterPoint|, |descriptor|.{{GPURenderPipelineDescriptor/fragment}}, |state|) 产生的，其中 |rasterPoint| 在 |rasterizationList| 中。

        1. **处理深度/模板**。

            <p class="note editorial">Editorial: fill out the section, using |fragments|

        1. **写入像素**。

            <p class="note editorial">Editorial: fill out the section
</div>

### 解析索引 ### {#index-resolution}

在渲染的第一个阶段，管线为每个实例构建了一个要处理的顶点列表。

<div algorithm>
    <dfn abstract-op>resolve indices</dfn>(drawCall, state)

     **参数：**

    - |drawCall|: 绘制调用参数。
    - |state|: 在绘制调用时 {{GPURenderCommandsMixin}} 状态的快照。

    **返回：**整数索引列表。

    1. 让 |vertexIndexList| 成为一个空的索引列表。
    1. 如果 |drawCall| 是一个索引绘制调用：
        1. 用 |drawCall|.indexCount 整数初始化 |vertexIndexList|。
        1. 对于范围 0 .. |drawCall|.indexCount（非包含）中的 |i|：
            1. 让 |relativeVertexIndex| 成为 [$fetch index$](|i| + |drawCall|.`firstIndex`, |state|.{{GPURenderCommandsMixin/[[index_buffer]]}})。
            1. 如果 |relativeVertexIndex| 有特殊值 `"out of bounds"`，停止并返回空列表。

                注意：实现可以选择在发生这种情况时显示警告，特别是在很容易检测到时（例如在非间接索引绘制调用中）。
            1. 将 |drawCall|.`baseVertex` + |relativeVertexIndex| 添加到 |vertexIndexList|。
    1. 否则：
        1. 用 |drawCall|.vertexCount 整数初始化 |vertexIndexList|。
        1. 将每个 |vertexIndexList| 项 |i| 设置为值 |drawCall|.firstVertex + |i|。
    1. 返回 |vertexIndexList|。

    注意：在间接绘制调用的情况下，将从间接缓冲区而不是绘制命令本身读取 |drawCall| 的 `indexCount`、`vertexCount` 和其他属性。

    <p class="note editorial">Editorial: specify indirect commands better.
</div>

<div algorithm>
    <dfn abstract-op>fetch index</dfn>(i, buffer, offset, format)

    **参数：**

    - |i|: 要获取的顶点索引的索引。
    - |state|: 在绘制调用时 {{GPURenderCommandsMixin}} 状态的快照。

    **返回：**无符号整数或 `"out of bounds"`

    1. 让 |indexSize| 由 |state|.{{GPURenderCommandsMixin/[[index_format]]}} 定义：

        <dl class=switch>
            : {{GPUIndexFormat/"uint16"}}
            :: 2
            : {{GPUIndexFormat/"uint32"}}
            :: 4
        </dl>
    1. 如果 |state|.{{GPURenderCommandsMixin/[[index_buffer_offset]]}} + |i + 1| &times; |indexSize| &gt; |state|.{{GPURenderCommandsMixin/[[index_buffer_size]]}}，返回特殊值 `"out of bounds"`。
    1. 解释 |state|.{{GPURenderCommandsMixin/[[index_buffer]]}} 中的数据，从偏移量 |state|.{{GPURenderCommandsMixin/[[index_buffer_offset]]}} + |i| &times; |indexSize| 开始，大小为 |indexSize| 字节，作为无符号整数并返回它。
</div>

### 顶点处理 ### {#vertex-processing}

顶点处理阶段是渲染 [=pipeline=] 的可编程阶段，它处理顶点属性数据，并为 [[#primitive-clipping]] 生成裁剪空间位置，以及其他 [[#fragment-processing]] 的数据。

<div algorithm>
    <dfn abstract-op>process vertices</dfn>(vertexIndexList, drawCall, desc, state)

    **参数：**

    - |vertexIndexList|: 要处理的顶点索引列表（可变的，通过引用传递）。
    - |drawCall|: 绘制调用参数。
    - |desc|: 类型为 {{GPUVertexState}} 的描述符。
    - |state|: 在绘制调用时 {{GPURenderCommandsMixin}} 状态的快照。

    在 |vertexIndexList| 中的每个顶点 |vertexIndex|，在每个索引 |rawInstanceIndex| 的实例中，都是独立处理的。|rawInstanceIndex| 的范围是从 0 到 |drawCall|.instanceCount - 1，包括两端。这个处理是并行的，任何副作用，比如写入 {{GPUBufferBindingType/"storage"|GPUBufferBindingType."storage"}} 绑定，都可能以任何顺序发生。

    1. 让 |instanceIndex| 为 |rawInstanceIndex| + |drawCall|.firstInstance。
    1. 对于 |desc|.{{GPUVertexState/buffers}} 列表中的每个非 `null` |vertexBufferLayout|：
        1. 让 |i| 为此列表中缓冲区布局的索引。
        1. 让 |vertexBuffer|、|vertexBufferOffset| 和 |vertexBufferBindingSize| 为 |state|.{{GPURenderCommandsMixin/[[vertex_buffers]]}} 的槽 |i| 处的缓冲区、偏移量和大小。
        1. 让 |vertexElementIndex| 依赖于 |vertexBufferLayout|.{{GPUVertexBufferLayout/stepMode}}：

            <dl class=switch>
                : {{GPUVertexStepMode/"vertex"}}
                :: |vertexIndex|
                : {{GPUVertexStepMode/"instance"}}
                :: |instanceIndex|
            </dl>
        1. 对于 |vertexBufferLayout|.{{GPUVertexBufferLayout/attributes}} 中的每个 |attributeDesc|：
            1. 让 |attributeOffset| 为 |vertexBufferOffset| + |vertexElementIndex| * |vertexBufferLayout|.{{GPUVertexBufferLayout/arrayStride}} + |attributeDesc|.{{GPUVertexAttribute/offset}}。
            1. 从 |vertexBuffer| 的偏移量 |attributeOffset| 开始，以格式 |attributeDesc|.{{GPUVertexAttribute/format}} 加载属性 |data|。组件从缓冲区内存中的 `x`、`y`、`z`、`w` 的顺序加载。

                如果这导致越界访问，则根据 WGSL 的 [=invalid memory reference=] 行为确定结果值。
            1. **可选（实现定义）：** 如果 |attributeOffset| + sizeof(|attributeDesc|.{{GPUVertexAttribute/format}}) &gt; |vertexBufferOffset| + |vertexBufferBindingSize|，则 [=list/empty=] |vertexIndexList| 并停止，取消绘制调用。

                注意：这允许实现在发出绘制调用之前检测索引缓冲区中的越界值，而不是使用 [=invalid memory reference=] 行为。
            1. 根据 [=channel formats=] 规则，将 |data| 转换为着色器可见格式。

                <div class=example>
                    一个类型为 {{GPUVertexFormat/"snorm8x2"}} 和字节值为 `[0x70, 0xD0]` 的属性将在 WGSL 中转换为 `vec2<f32>(0.88, -0.38)`。
                </div>
            1. 调整 |data| 的大小以适应着色器类型：
                - 如果两者都是标量，或者都是相同维度的向量，则不需要调整。
                - 如果 |data| 是向量，但着色器类型是标量，则只提取第一个分量。
                - 如果两者都是向量，并且 |data| 具有更高的维度，则会丢弃额外的分量。

                    <div class=example>
                        如果期望的是 2 维向量，一个类型为 {{GPUVertexFormat/"float32x3"}} 和值为 `vec3<f32>(1.0, 2.0, 3.0)` 的属性将在着色器中显示为 `vec2<f32>(1.0, 2.0)`。
                    </div>
                - 如果着色器类型是更高维度的向量，或者 |data| 是标量，则缺少的分量将从 `vec4<*>(0, 0, 0, 1)` 值中填充。

                    <div class=example>
                        如果期望的是 4 维向量，一个类型为 {{GPUVertexFormat/"sint32"}} 和值为 `5` 的属性将在着色器中显示为 `vec4<i32>(5, 0, 0, 1)`。
                    </div>
            1. 将 |data| 绑定到顶点着色器输入位置 |attributeDesc|.{{GPUVertexAttribute/shaderLocation}}。
    1. 对于 |state|.{{GPUBindingCommandsMixin/[[bind_groups]]}} 中 |index| 处的每个 {{GPUBindGroup}} 组：
        1. 对于绑定组中的每个资源 {{GPUBindingResource}}：
            1. 让 |entry| 成为此资源的相应 {{GPUBindGroupLayoutEntry}}。
            1. 如果 |entry|.{{GPUBindGroupLayoutEntry/visibility}} 包括 {{GPUShaderStage/VERTEX}}：
                - 将资源绑定到着色器组 |index| 和绑定 {{GPUBindGroupLayoutEntry/binding|GPUBindGroupLayoutEntry.binding}} 下。
    1. 设置着色器 [=builtins=]：
        - 如果有的话，将 `vertex_index` builtin 设置为 |vertexIndex|。
        - 如果有的话，将 `instance_index` builtin 设置为 |instanceIndex|.
    1. 调用 |desc| 描述的顶点着色器入口点。

        注意：目标平台缓存顶点着色器调用的结果。不能保证任何重复超过一次的 |vertexIndex| 将导致多次调用。同样，不能保证单个 |vertexIndex| 只会被处理一次。

        如果着色器没有在合理的时间内 [=shader execution end|执行完毕=]，由用户代理决定，那么 [=device=] 可能会 [=lose the device|丢失设备=]。
</div>

### 基本体部件 ### {#primitive-assembly}

基本体由 GPU 的固定功能状态构成。

<div algorithm>
    <dfn abstract-op>assemble primitives</dfn>(vertexIndexList, drawCall, desc)

     **参数：**

    - |vertexIndexList|：要处理的顶点索引列表。
    - |drawCall|：绘制调用参数。
    - |desc|：类型为 {{GPUPrimitiveState}} 的描述符。

    对于每个实例，基于 |vertexIndexList|，从已由着色器处理的顶点中组装基本体。

    1. 首先，如果基本体拓扑是条带（这意味着 |desc|.{{GPUPrimitiveState/stripIndexFormat}} 不是 undefined），并且 |drawCall| 是索引的，则使用 |desc|.{{GPUPrimitiveState/stripIndexFormat}} 的最大值作为分隔符将 |vertexIndexList| 分成子列表。


        例如：类型为 {{GPUIndexFormat/"uint16"}} 的值为 `[1, 2, 65535, 4, 5, 6]` 的 |vertexIndexList| 将被分割为子列表 `[1, 2]` 和 `[4, 5, 6]`。

    1. 对于子列表 |vl|，基本体生成根据 |desc|.{{GPUPrimitiveState/topology}} 进行：

        <dl class=switch>
            : {{GPUPrimitiveTopology/"line-list"}}
            ::
                线基本体由 (|vl|.0, |vl|.1)，然后 (|vl|.2, |vl|.3)，然后 (|vl|.4 到 |vl|.5)，等等组成。每个后续基本体占用 2 个顶点。

            : {{GPUPrimitiveTopology/"line-strip"}}
            ::
                线基本体由 (|vl|.0, |vl|.1)，然后 (|vl|.1, |vl|.2)，然后 (|vl|.2, |vl|.3)，等等组成。每个后续基本体占用 1 个顶点。

            : {{GPUPrimitiveTopology/"triangle-list"}}
            ::
                三角形基本体由 (|vl|.0, |vl|.1, |vl|.2)，然后 (|vl|.3, |vl|.4, |vl|.5)，然后 (|vl|.6, |vl|.7, |vl|.8)，等等组成。每个后续基本体占用 3 个顶点。

            : {{GPUPrimitiveTopology/"triangle-strip"}}
            ::
                三角形基本体由 (|vl|.0, |vl|.1, |vl|.2)，然后 (|vl|.2, |vl|.1, |vl|.3)，然后 (|vl|.2, |vl|.3, |vl|.4)，然后 (|vl|.4, |vl|.3, |vl|.5)，等等组成。每个后续基本体占用 1 个顶点。
        </dl>

        <p class="note editorial">Editorial: should this be defined more formally?

        任何不完整的基本体都将被丢弃。
</div>

### 基本体剪裁 ### {#primitive-clipping}

顶点着色器必须生成内置的 "position"（类型为 `vec4<f32>`），它表示顶点的 <dfn dfn>clip position</dfn>。

<p class="note editorial">Editorial: link to WGSL built-ins

基本体被剪裁到 <dfn dfn>clip volume</dfn>，对于任何基本体内部的 [=clip position=] |p|，由以下不等式定义：

- &minus;|p|.w &le; |p|.x &le; |p|.w
- &minus;|p|.w &le; |p|.y &le; |p|.w
- 0 &le; |p|.z &le; |p|.w (<dfn dfn>depth clipping</dfn>)

如果 |descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/unclippedDepth}} 为 `true`，则不应用 [=depth clipping=]：[=clip volume=] 在 z 维度上没有边界。

如果基本体的每条边都完全位于 [=clip volume=] 内，则基本体不会改变。
如果基本体的边与 [=clip volume=] 的边界相交，则相交的边通过沿 [=clip volume=] 的边界的新边重新连接。
对于三角形基本体（|descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/topology}} 是 {{GPUPrimitiveTopology/"triangle-list"}} 或 {{GPUPrimitiveTopology/"triangle-strip"}}），这种重新连接可能会导致将新顶点引入到多边形中。

如果基本体与 [=clip volume=] 的边界的边相交，则剪裁的多边形必须包含此边界边上的一个点。

如果顶点着色器输出其他浮点值（标量和向量），并带有 "perspective" 插值限定符，则它们也会被剪裁。
基本体内的顶点关联的输出值不受剪裁的影响。
但是，如果基本体被剪裁，则剪裁产生的顶点分配的输出值将被剪裁。

考虑一个在顶点 |a| 和 |b| 之间的边被剪裁，导致顶点 |c|，让我们定义 |t| 为边顶点之间的比率：
|c|.p = |t| &times; |a|.p &plus; (1 &minus; |t|) &times; |b|.p,
其中 |x|.p 是顶点 |x| 的输出 [=clip position=]。

对于每个具有相应片段输入的顶点输出值 "v"，|a|.v 和 |b|.v 分别是顶点 |a| 和 |b| 的输出。
剪裁的着色器输出 |c|.v 是基于插值限定符生成的：
<dl class=switch>
    : "flat"
    ::
        平面插值不受影响，基于 <dfn dfn>provoking vertex</dfn>，它是基本体中的第一个顶点。输出值对整个基本体都是相同的，并且与 [=provoking vertex=] 的顶点输出相匹配：|c|.v = [=provoking vertex=].v

    : "linear"
    ::
        插值比率根据 [=clip position=] 的透视坐标进行调整，以便插值的结果在屏幕空间中是线性的。

        <p class="note editorial">Editorial: provide more specifics here, if possible

    : "perspective"
    ::
        在剪裁空间中线性插值该值，从而产生透视正确的值：

        |c|.v = |t| &times; |a|.v &plus; (1 &minus; |t|) &times; |b|.v

</dl>

<p class="note editorial">Editorial: link to interpolation qualifiers in WGSL

基本体剪裁的结果是一组新的基本体，这些基本体包含在 [=clip volume=] 内。

### 光栅化 ### {#rasterization}

光栅化是将生成的基本体映射到 <dfn dfn>framebuffer</dfn> 的 2 维渲染区域的硬件处理阶段 - 当前 {{GPURenderPassEncoder}} 中的渲染附件集。
此渲染区域被分割成一个均匀的像素网格。

[=framebuffer=] 坐标从渲染目标的左上角开始。每个单位都对应一个像素。有关更多信息，请参见 [[#coordinate-systems]]。

光栅化确定基本体影响的像素集。在多采样的情况下，每个像素进一步分成 |descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}} 个样本。
<dfn dfn noexport>standard sample patterns</dfn> 如下，其中的位置以像素的左上角为原点，以 framebuffer 坐标表示，使得像素范围从 (0, 0) 到 (1, 1)：

<table class=data>
    <thead>
        <tr><th>{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}}<th>Sample positions
    <tbody>
        <tr><td>1<td>
            Sample 0: (0.5, 0.5)
        <tr><td>4<td>
            Sample 0: (0.375, 0.125)<br>
            Sample 1: (0.875, 0.375)<br>
            Sample 2: (0.125, 0.625)<br>
            Sample 3: (0.625, 0.875)
</table>

让我们定义一个 <dfn dfn>FragmentDestination</dfn> 来包含：
<dl dfn-for=FragmentDestination>
    : <dfn dfn>position</dfn>
    :: [=framebuffer=] 空间中的 2D 像素位置
    : <dfn dfn>sampleIndex</dfn>
    :: 如果 [[#sample-frequency-shading]] 处于活动状态，则为整数，否则为 `null`
</dl>

我们还将使用 <dfn dfn>NDC</dfn> 的概念 - 规范化设备坐标。
在此坐标系中，视口边界在 X 和 Y 中的范围为 -1 到 1，在 Z 中的范围为 0 到 1。

光栅化产生一个 <dfn dfn>RasterizationPoint</dfn> 列表，每个列表包含以下数据：
<dl dfn-for=RasterizationPoint>
    : <dfn dfn>destination</dfn>
    :: 指的是 [=FragmentDestination=]
    : <dfn dfn>coverageMask</dfn>
    :: 指的是多采样覆盖掩码（参见 [[#sample-masking]]）
    : <dfn dfn>frontFacing</dfn>
    :: 如果是基本体正面的点，则为 true
    : <dfn dfn>perspectiveDivisor</dfn>
    :: 指的是基本体上插值的 1.0 &divide; W
    : <dfn dfn>depth</dfn>
    :: 指的是视口坐标中的深度，
        即 {{RenderState/[[viewport]]}} `minDepth` 和 `maxDepth` 之间。
    : <dfn dfn>primitiveVertices</dfn>
    :: 指的是形成基本体的顶点输出列表
    : <dfn dfn>barycentricCoordinates</dfn>
    :: 指的是 [[#barycentric-coordinates]]
</dl>

<p class="note editorial">Editorial: define the depth computation algorithm

<div algorithm>
    <dfn abstract-op>rasterize</dfn>(primitiveList, state)

    **参数：**

    - |primitiveList|: 要光栅化的基本体列表。
    - |state|: 活动的 [=RenderState=]。

    **返回：** [=RasterizationPoint=] 列表。

    每个基本体在 |primitiveList| 中独立处理。

    1. 首先，剪切的顶点被转换为 [=NDC=] - 规范化设备坐标。对于输出位置 |p|，计算 [=NDC=] 坐标如下：

        divisor(|p|) = 1.0 &divide; |p|.w

        ndc(|p|) = vector(|p|.x &divide; |p|.w, |p|.y &divide; |p|.w, |p|.z &divide; |p|.w)

    1. 让 |vp| 为 |state|.{{RenderState/[[viewport]]}}。将 [=NDC=] 坐标 |n| 映射到视口空间：
        * 从渲染目标偏移和大小计算 [=framebuffer=] 坐标：

            framebufferCoords(|n|) = vector(|vp|.`x` &plus; 0.5 &times; (|n|.x &plus; 1) &times; |vp|.`width`, |vp|.`y` &plus; .5 &times; (|n|.y &plus; 1) &times; |vp|.`height`)

        * 通过线性映射 [0,1] 到视口深度范围来计算深度：

            depth(|n|) = |vp|.`minDepth` &plus; |n|.`z` &times; ( |vp|.`maxDepth` - |vp|.`minDepth` )

    1. 让 |rasterizationPoints| 为空列表。

        <p class="note editorial">Editorial: specify that each rasterization point gets assigned an interpolated `divisor(p)`,
        `framebufferCoords(n)`, `depth(n)`, as well as the other attributes.

    1. 根据 {{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/topology}}，使用特定的光栅化算法继续：

        <dl class=switch>
            : {{GPUPrimitiveTopology/"point-list"}}
            :: 如果没有被 [[#primitive-clipping]] 过滤，则该点进入 [[#point-rasterization]]。
            : {{GPUPrimitiveTopology/"line-list"}} or {{GPUPrimitiveTopology/"line-strip"}}
            :: 被 [[#primitive-clipping]] 切割的线进入 [[#line-rasterization]]。
            : {{GPUPrimitiveTopology/"triangle-list"}} or {{GPUPrimitiveTopology/"triangle-strip"}}
            :: 在 [[#primitive-clipping]] 中产生的多边形进入 [[#polygon-rasterization]]。
        </dl>

    1. 从 |rasterizationPoints| 中删除所有点 |rp|，这些点具有 |rp|.[=RasterizationPoint/destination=].[=FragmentDestination/position=] 在 |state|.{{RenderState/[[scissorRect]]}} 之外。

    1. 返回 |rasterizationPoints|。
</div>

#### 点光栅化 #### {#point-rasterization}

在包含点的 [=framebuffer=] 坐标的像素中选择一个 [=FragmentDestination=]。

覆盖掩码取决于多采样模式：
<dl class=switch>
    : 采样频率
    :: coverageMask = 1 &Lt; `sampleIndex`
    : 像素频率多采样
    :: coverageMask = 1 &Lt; |descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}} &minus; 1
    : 无多采样
    :: coverageMask = 1
</dl>

#### 线光栅化 #### {#line-rasterization}

<p class="note editorial">Editorial: fill out this section

#### 重心坐标 #### {#barycentric-coordinates}

重心坐标是一个 |n| 个数字 |b|<sub>|i|</sub> 的列表，定义为在 [=framebuffer=] 空间中具有 |n| 个顶点 |v|<sub>|i|</sub> 的凸多边形内的点 |p|。
每个 |b|<sub>|i|</sub> 在 0 到 1 的范围内，包括 0 和 1，表示到顶点 |v|<sub>|i|</sub> 的接近程度。
它们的总和始终是恒定的：

&sum; (|b|<sub>|i|</sub>) = 1

这些坐标唯一地指定了多边形内（或在其边界上）的任何点 |p|：

|p| = &sum; (|b|<sub>|i|</sub> &times; |p|<sub>|i|</sub>)

对于具有 3 个顶点的多边形 - 三角形，任何点 |p| 的重心坐标可以计算如下：

|A|<sub>polygon</sub> = A(|v|<sub>|1|</sub>, |v|<sub>|2|</sub>, |v|<sub>|3|</sub>)
|b|<sub>|1|</sub> = A(|p|, |b|<sub>|2|</sub>, |b|<sub>|3|</sub>) &divide; |A|<sub>polygon</sub>
|b|<sub>|2|</sub> = A(|b|<sub>|1|</sub>, |p|, |b|<sub>|3|</sub>) &divide; |A|<sub>polygon</sub>
|b|<sub>|3|</sub> = A(|b|<sub>|1|</sub>, |b|<sub>|2|</sub>, |p|) &divide; |A|<sub>polygon</sub>

其中 A(点列表) 是具有给定顶点集的多边形的面积。

对于具有多于 3 个顶点的多边形，确切的算法取决于实现。可能的实现之一是将多边形三角化，并根据其所在的三角形计算点的重心坐标。

#### 多边形光栅化 #### {#polygon-rasterization}

如果多边形朝向投影，则多边形是 <dfn dfn>front-facing</dfn> 的。
否则，多边形是 <dfn dfn>back-facing</dfn> 的。

<div algorithm>
    <dfn abstract-op>rasterize polygon</dfn>()

    **参数：**

    **返回：** [=RasterizationPoint=] 列表。

    1. 让 |rasterizationPoints| 成为空列表。
    1. 让 |v|(|i|) 成为 |n| 个顶点的光栅化多边形中被裁剪的顶点编号 |i|（从 1 开始）的 [=framebuffer=] 坐标。

        注意：本节使用术语“多边形”而不是“三角形”，因为 [[#primitive-clipping]] 阶段可能引入了额外的顶点。 这对应用程序是不可观察的。

    1. 确定多边形是否是 front-facing 的，这取决于多边形在 [=framebuffer=] 坐标中占用的 |area| 的符号：

        |area| = 0.5 &times; ((|v|<sub>1</sub>.x &times; |v|<sub>|n|</sub>.y &minus; |v|<sub>|n|</sub>.x &times; |v|<sub>1</sub>.y) &plus; &sum; (|v|<sub>|i|&plus;1</sub>.x &times; |v|<sub>|i|</sub>.y &minus; |v|<sub>|i|</sub>.x &times; |v|<sub>|i|&plus;1</sub>.y))

        |area| 的符号根据 {{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/frontFace}} 进行解释：

        <dl class=switch>
            : {{GPUFrontFace/"ccw"}}
            :: |area| &gt; 0 被认为是 [=front-facing=]，否则是 [=back-facing=]
            : {{GPUFrontFace/"cw"}}
            :: |area| &lt; 0 被认为是 [=front-facing=]，否则是 [=back-facing=]
        </dl>

    1. 根据 {{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/cullMode}} 进行剔除：

        <dl class=switch>
            : {{GPUCullMode/"none"}}
            :: 所有多边形都通过此测试。

            : {{GPUCullMode/"front"}}
            :: [=front-facing=] 多边形被丢弃，并且不在渲染管线的后续阶段中处理。
            : {{GPUCullMode/"back"}}
            :: [=back-facing=] 多边形被丢弃。
        </dl>

    1. 确定 [=framebuffer=] 空间中多边形内的 [=fragments=] 集合 - 这些是计划进行的每个片段操作的位置。
        此操作称为“点采样”。
        逻辑基于 |descriptor|.{{GPURenderPipelineDescriptor/multisample}}：

        <dl class=switch>
            : disabled
            :: [=Fragment=]s 与像素中心相关联。 也就是说，所有坐标为 |C| 的点，其中 fract(|C|) = vector2(0.5, 0.5) 在 [=framebuffer=] 空间中，被包含在多边形中，都被包含在内。
                如果像素中心在多边形的边缘上，是否包含在内是未定义的。

                注意：这成为光栅化器的精度主题。

            : enabled
            :: 每个像素与 |descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}} 相关联，这是实现定义的。
                这些位置是有序的，并且对于 [=framebuffer=] 的每个像素，列表都是相同的。
                每个位置对应于多采样 [=framebuffer=] 中的一个片段。

                光栅化器在每个像素内构建被击中的位置的掩码，并将其作为“sample-mask”内置于片段着色器中。
        </dl>

    1. 对于每个类型为 [=FragmentDestination=] 的产生的片段：

        1. 让 |rp| 成为一个新的 [=RasterizationPoint=] 对象
        1. 计算列表 |b| 作为该片段的 [[#barycentric-coordinates]]。 将 |rp|.[=RasterizationPoint/barycentricCoordinates=] 设置为 |b|。

        1. 让 |d|<sub>|i|</sub> 成为 |v|<sub>|i|</sub> 的深度值。

            <p class="note editorial">Editorial: define how this value is constructed.
        1. 将 |rp|.[=RasterizationPoint/depth=] 设置为 &sum; (|b|<sub>|i|</sub> &times; |d|<sub>|i|</sub>)
        1. 将 |rp| 追加到 |rasterizationPoints|。

    1. 返回 |rasterizationPoints|。
</div>

### 片段处理 ### {#fragment-processing}

片段处理阶段是渲染 [=pipeline=] 的可编程阶段，用于计算要写入渲染目标的片段数据（通常是颜色）。

此阶段为每个 [=RasterizationPoint=] 生成一个 <dfn dfn>Fragment</dfn>：
<div algorithm="Fragment accessors" dfn-for=Fragment>
    - <dfn dfn>destination</dfn> 指的是 [=FragmentDestination=]。
    - <dfn dfn>coverageMask</dfn> 指的是多采样覆盖掩码（请参阅 [[#sample-masking]]）。
    - <dfn dfn>depth</dfn> 指的是视口坐标中的深度，
        即 {{RenderState/[[viewport]]}} `minDepth` 和 `maxDepth` 之间。
    - <dfn dfn>colors</dfn> 指的是颜色值列表，每个目标一个 {{GPURenderPassDescriptor/colorAttachments}}。
</div>

<div algorithm>
    <dfn abstract-op>process fragment</dfn>(rp, desc, state)

    **参数：**

    - |rp|: 由 [[#rasterization]] 产生的 [=RasterizationPoint=]。
    - |desc|: 类型为 {{GPUFragmentState}} 的描述符。
    - |state|: 活动的 [=RenderState=]。

    **返回：** [=Fragment=] 或 `null`。

    1. 让 |fragment| 成为一个新的 [=Fragment=] 对象。
    1. 将 |fragment|.[=Fragment/destination=] 设置为 |rp|.[=RasterizationPoint/destination=]。
    1. 将 |fragment|.[=Fragment/coverageMask=] 设置为 |rp|.[=RasterizationPoint/coverageMask=]。
    1. 将 |fragment|.[=Fragment/depth=] 设置为 |rp|.[=RasterizationPoint/depth=]。
    1. 如果 |desc| 不是 `null`：
        1. 设置着色器输入 [=builtins=]。 对于入口点的每个非复合参数，标记为 [=builtin=]，根据注释设置其值：

            <dl class=switch>
                : `position`
                :: `vec4<f32>`(|rp|.[=RasterizationPoint/destination=].[=FragmentDestination/position=], |rp|.[=RasterizationPoint/depth=], |rp|.[=RasterizationPoint/perspectiveDivisor=])

                : `front_facing`
                :: |rp|.[=RasterizationPoint/frontFacing=]

                : `sample_index`
                :: |rp|.[=RasterizationPoint/destination=].[=FragmentDestination/sampleIndex=]

                : `sample_mask`
                :: |rp|.[=RasterizationPoint/coverageMask=]
            </dl>
        1. 对于片段阶段的每个用户指定的 [=shader stage input=]：
            1. 让 |value| 成为基于 |rp|.[=RasterizationPoint/barycentricCoordinates=]、|rp|.[=RasterizationPoint/primitiveVertices=] 和输入上的 [=interpolation=] 限定符的插值片段输入。

                <p class="note editorial">Editorial: describe the exact equations.
            1. 将相应的片段着色器 [=location=] 输入设置为 |value|。
        1. 调用由 |desc| 描述的片段着色器入口点。

            如果 [=shader execution end|shader execution does not end=] 在合理的时间内，由用户代理确定，[=device=] 可能会变成 [=lose the device|lost=]。

        1. 如果片段发出了 `discard`，则返回 `null`。
        1. 将 |fragment|.[=Fragment/colors=] 设置为来自着色器的用户指定的 [=shader stage output=] 值。
        1. 取出着色器输出 [=builtins=]：
            1. 如果 `frag_depth` [=builtin=] 由着色器产生为 |value|：
                1. 让 |vp| 成为 |state|.{{RenderState/[[viewport]]}}。
                1. 将 |fragment|.[=Fragment/depth=] 设置为 clamp(|value|, |vp|.`minDepth`, |vp|.`maxDepth`)。
        1. 如果 `sample_mask` [=builtin=] 由着色器产生为 |value|：
            1. 将 |fragment|.[=Fragment/coverageMask=] 设置为 |fragment|.[=Fragment/coverageMask=] &and; |value|.

        否则，我们处于 [[#no-color-output]] 模式，|fragment|.[=Fragment/colors=] 为空。
    1. 返回 |fragment|。
</div>

片段的处理是并行的，而任何副作用，例如写入 {{GPUBufferBindingType/"storage"|GPUBufferBindingType."storage"}} 绑定，可能以任何顺序发生。

### 输出合并 ### {#output-merging}

<p class="note editorial">Editorial: fill out this section

此阶段的深度输入（如果有）将被截断到当前 {{RenderState/[[viewport]]}} 深度范围（无论片段着色器阶段是否写入 `frag_depth` builtin）。

### 无颜色输出 ### {#no-color-output}

在无颜色输出模式下，[=pipeline=] 不会产生任何颜色附件输出。

[=pipeline=] 仍然执行光栅化并基于顶点位置输出产生深度值。深度测试和模板操作仍然可以使用。

### Alpha覆盖 ### {#alpha-to-coverage}

在 alpha-to-coverage 模式下，基于片段着色器输出值在 `@location(0)` 处的 |alpha| 分量，生成 MSAA 样本的额外 <dfn dfn>alpha-to-coverage mask</dfn>。

生成额外 mask 的算法取决于平台，对于不同的像素可能会有所不同。
它保证：

 - 如果 |alpha| &le; 0.0，则结果为 0x0
- 如果 |alpha| &ge; 1.0，则结果为 0xFFFFFFFF
- 如果 |alpha| 大于某个其他 |alpha1|，则产生的样本 mask 至少有与 |alpha1| 的 mask 一样多的位设置为 1

### 采样频率着色 ### {#sample-frequency-shading}

<p class="note editorial">Editorial: fill out the section

### 采样遮掩 ### {#sample-masking}

像素的 <dfn dfn>final sample mask</dfn> 计算为 [=rasterization mask=] & {{GPUMultisampleState/mask}} & [=shader-output mask=]。

只考虑 mask 的较低 {{GPUMultisampleState/count}} 位。

如果 [=final sample mask=] 的位置 |N| 的最低有效位的值为 "0"，则片段着色器的所有附件的样本颜色输出（对应于样本 |N|）都将被丢弃。此外，深度测试或模板操作也不会在深度模板附件的相关样本上执行。

注意：样本 |N| 的颜色输出是由片段着色器执行产生的，对于当前像素，SV_SampleIndex == |N|。如果片段着色器不使用此语义，则每个像素只执行一次。

<dfn dfn>rasterization mask</dfn> 是由光栅化阶段产生的，基于光栅化多边形的形状。包含在形状中的样本在 mask 中获得相关位 1。

<dfn dfn>shader-output mask</dfn> 获取片段着色器中 "sample_mask" [=builtin=] 的输出值。如果 builtin 不是从片段着色器输出的，并且 {{GPUMultisampleState/alphaToCoverageEnabled}} 已启用，则 [=shader-output mask=] 变为 [=alpha-to-coverage mask=]。否则，默认为 0xFFFFFFFF。

# 类型定义 # {#type-definitions}

<script type=idl>
typedef [EnforceRange] unsigned long GPUBufferDynamicOffset;
typedef [EnforceRange] unsigned long GPUStencilValue;
typedef [EnforceRange] unsigned long GPUSampleMask;
typedef [EnforceRange] long GPUDepthBias;

typedef [EnforceRange] unsigned long long GPUSize64;
typedef [EnforceRange] unsigned long GPUIntegerCoordinate;
typedef [EnforceRange] unsigned long GPUIndex32;
typedef [EnforceRange] unsigned long GPUSize32;
typedef [EnforceRange] long GPUSignedOffset32;

typedef unsigned long GPUFlagsConstant;
</script>

## 颜色 &amp; 向量 ## {#colors-and-vectors}

<script type=idl>
dictionary GPUColorDict {
    required double r;
    required double g;
    required double b;
    required double a;
};
typedef (sequence<double> or GPUColorDict) GPUColor;
</script>

注意：`double` 足够大，可以精确地保存 32 位有符号/无符号整数和单精度浮点数。

<dl dfn-type=dict-member dfn-for=GPUColorDict>
    : <dfn>r</dfn>
    ::
        红色通道值。

    : <dfn>g</dfn>
    ::
        绿色通道值。

    : <dfn>b</dfn>
    ::
        蓝色通道值。

    : <dfn>a</dfn>
    ::
        透明通道值。
</dl>

<div algorithm="GPUColor accessors" dfn-for=GPUColor>
    对于给定的 {{GPUColor}} 值 |color|，根据其类型，语法为：

    - |color|.<dfn dfn noexport>r</dfn> 指的是
        {{GPUColorDict}}.{{GPUColorDict/r}}
        或序列的第一项（[=assert|断言=] 存在这样的项）。    
    - |color|.<dfn dfn noexport>g</dfn> 指的是
        {{GPUColorDict}}.{{GPUColorDict/g}}
        或序列的第二项（[=assert|断言=] 存在这样的项）。
    - |color|.<dfn dfn noexport>b</dfn> 指的是
        {{GPUColorDict}}.{{GPUColorDict/b}}
        或序列的第三项（[=assert|断言=] 存在这样的项）。
    - |color|.<dfn dfn noexport>a</dfn> 指的是
        {{GPUColorDict}}.{{GPUColorDict/a}}
        或序列的第四项（[=assert|断言=] 存在这样的项）。
</div>
<div algorithm>
    <dfn abstract-op>validate GPUColor shape</dfn>(color)

    **参数：**

    - |color|：要验证的 {{GPUColor}}。

    **返回：** {{undefined}}

    1. 如果 |color| 是一个序列且 |color|.length &ne; 4，则抛出 {{TypeError}}。
</div>

<script type=idl>
dictionary GPUOrigin2DDict {
    GPUIntegerCoordinate x = 0;
    GPUIntegerCoordinate y = 0;
};
typedef (sequence<GPUIntegerCoordinate> or GPUOrigin2DDict) GPUOrigin2D;
</script>

<div algorithm="GPUOrigin2D accessors" dfn-for=GPUOrigin2D>
    对于给定的 {{GPUOrigin2D}} 值 |origin|，根据其类型，语法为：

    - |origin|.<dfn dfn noexport>x</dfn> 指的是
        {{GPUOrigin2DDict}}.{{GPUOrigin2DDict/x}}
        或序列的第一项（如果不存在，则为 0）。
    - |origin|.<dfn dfn noexport>y</dfn> 指的是
        {{GPUOrigin2DDict}}.{{GPUOrigin2DDict/y}}
        或序列的第二项（如果不存在，则为 0）。
</div>
<div algorithm>
    <dfn abstract-op>validate GPUOrigin2D shape</dfn>(origin)

    **参数：**

    - |origin|：要验证的 {{GPUOrigin2D}}。

   **返回：** {{undefined}}

    1. 如果 |origin| 是一个序列且 |origin|.length &gt; 2，则抛出 {{TypeError}}。
</div>

<script type=idl>
dictionary GPUOrigin3DDict {
    GPUIntegerCoordinate x = 0;
    GPUIntegerCoordinate y = 0;
    GPUIntegerCoordinate z = 0;
};
typedef (sequence<GPUIntegerCoordinate> or GPUOrigin3DDict) GPUOrigin3D;
</script>

<div algorithm="GPUOrigin3D accessors" dfn-for=GPUOrigin3D>
    对于给定的 {{GPUOrigin3D}} 值 |origin|，根据其类型，语法为：

    - |origin|.<dfn dfn>x</dfn> 指的是
        {{GPUOrigin3DDict}}.{{GPUOrigin3DDict/x}}
        或序列的第一项（如果不存在，则为 0）。
    - |origin|.<dfn dfn>y</dfn> 指的是
        {{GPUOrigin3DDict}}.{{GPUOrigin3DDict/y}}
        或序列的第二项（如果不存在，则为 0）。
    - |origin|.<dfn dfn>z</dfn> 指的是
        {{GPUOrigin3DDict}}.{{GPUOrigin3DDict/z}}
        或序列的第三项（如果不存在，则为 0）。
</div>
<div algorithm>
    <dfn abstract-op>validate GPUOrigin3D shape</dfn>(origin)

    **参数：**

    - |origin|：要验证的 {{GPUOrigin3D}}。

    **返回：** {{undefined}}

    1. 如果 |origin| 是一个序列且 |origin|.length &gt; 3，则抛出 {{TypeError}}。
</div>

<script type=idl>
dictionary GPUExtent3DDict {
    required GPUIntegerCoordinate width;
    GPUIntegerCoordinate height = 1;
    GPUIntegerCoordinate depthOrArrayLayers = 1;
};
typedef (sequence<GPUIntegerCoordinate> or GPUExtent3DDict) GPUExtent3D;
</script>

<dl dfn-type=dict-member dfn-for=GPUExtent3DDict>
    : <dfn>width</dfn>
    ::
        范围的宽度。

    : <dfn>height</dfn>
    ::
        范围的高度。

    : <dfn>depthOrArrayLayers</dfn>
    ::
        范围的深度或其包含的数组层数。
        如果与 {{GPUTexture}} 一起使用，其 {{GPUTextureDimension}} 为 {{GPUTextureDimension/"3d"}}，定义了纹理的深度。如果与 {{GPUTexture}} 一起使用，其 {{GPUTextureDimension}} 为 {{GPUTextureDimension/"2d"}}，定义了纹理中的数组层数。
</dl>

<div algorithm="GPUExtent3D accessors" dfn-for=GPUExtent3D>
    对于给定的 {{GPUExtent3D}} 值 |extent|，根据其类型，语法为：

    - |extent|.<dfn dfn>width</dfn> 指的是
        {{GPUExtent3DDict}}.{{GPUExtent3DDict/width}}
        或序列的第一项（如果存在该项，则 [=assert|asserting=]）。
    - |extent|.<dfn dfn>height</dfn> 指的是
        {{GPUExtent3DDict}}.{{GPUExtent3DDict/height}}
        或序列的第二项（如果不存在，则为 1）。
    - |extent|.<dfn dfn>depthOrArrayLayers</dfn> 指的是
        {{GPUExtent3DDict}}.{{GPUExtent3DDict/depthOrArrayLayers}}
        或序列的第三项（如果不存在，则为 1）。
</div>
<div algorithm>
    <dfn abstract-op>validate GPUExtent3D shape</dfn>(extent)

    **参数：**

    - |extent|：要验证的 {{GPUExtent3D}}。

   **返回：** {{undefined}}

    1. 抛出 {{TypeError}}，如果：

       - |extent| is a sequence, and
       - |extent|.length &lt; 1 or |extent|.length &gt; > 3.
</div>

# 功能索引 # {#feature-index}

<h3 id=depth-clip-control data-dfn-type=enum-value data-dfn-for=GPUFeatureName>`"depth-clip-control"`
<span id=dom-gpufeaturename-depth-clip-control></span>
</h3>

允许禁用 [=depth clipping=]。

此功能添加了以下 [=optional API surfaces=]：

- 新的 {{GPUPrimitiveState}} 字典成员：
    - {{GPUPrimitiveState/unclippedDepth}}

<h3 id=depth32float-stencil8 data-dfn-type=enum-value data-dfn-for=GPUFeatureName>`"depth32float-stencil8"`
<span id=dom-gpufeaturename-depth32float-stencil8></span>
</h3>

允许显式创建格式为 {{GPUTextureFormat/"depth32float-stencil8"}} 的纹理。

此功能添加了以下 [=optional API surfaces=]：

- 新的 {{GPUTextureFormat}} 枚举值：
    - {{GPUTextureFormat/"depth32float-stencil8"}}

<h3 id=texture-compression-bc data-dfn-type=enum-value data-dfn-for=GPUFeatureName>`"texture-compression-bc"`
<span id=dom-gpufeaturename-texture-compression-bc></span>
</h3>

允许显式创建 BC 压缩格式的纹理。

此功能添加了以下 [=optional API surfaces=]：

- 新的 {{GPUTextureFormat}} 枚举值：
    - {{GPUTextureFormat/"bc1-rgba-unorm"}}
    - {{GPUTextureFormat/"bc1-rgba-unorm-srgb"}}
    - {{GPUTextureFormat/"bc2-rgba-unorm"}}
    - {{GPUTextureFormat/"bc2-rgba-unorm-srgb"}}
    - {{GPUTextureFormat/"bc3-rgba-unorm"}}
    - {{GPUTextureFormat/"bc3-rgba-unorm-srgb"}}
    - {{GPUTextureFormat/"bc4-r-unorm"}}
    - {{GPUTextureFormat/"bc4-r-snorm"}}
    - {{GPUTextureFormat/"bc5-rg-unorm"}}
    - {{GPUTextureFormat/"bc5-rg-snorm"}}
    - {{GPUTextureFormat/"bc6h-rgb-ufloat"}}
    - {{GPUTextureFormat/"bc6h-rgb-float"}}
    - {{GPUTextureFormat/"bc7-rgba-unorm"}}
    - {{GPUTextureFormat/"bc7-rgba-unorm-srgb"}}

<h3 id=texture-compression-etc2 data-dfn-type=enum-value data-dfn-for=GPUFeatureName>`"texture-compression-etc2"`
<span id=texture-compression-etc></span>
<span id=dom-gpufeaturename-texture-compression-etc2></span>
</h3>

允许显式创建 ETC2 压缩格式的纹理。

此功能添加了以下 [=optional API surfaces=]：

- 新的 {{GPUTextureFormat}} 枚举值：
    - {{GPUTextureFormat/"etc2-rgb8unorm"}}
    - {{GPUTextureFormat/"etc2-rgb8unorm-srgb"}}
    - {{GPUTextureFormat/"etc2-rgb8a1unorm"}}
    - {{GPUTextureFormat/"etc2-rgb8a1unorm-srgb"}}
    - {{GPUTextureFormat/"etc2-rgba8unorm"}}
    - {{GPUTextureFormat/"etc2-rgba8unorm-srgb"}}
    - {{GPUTextureFormat/"eac-r11unorm"}}
    - {{GPUTextureFormat/"eac-r11snorm"}}
    - {{GPUTextureFormat/"eac-rg11unorm"}}
    - {{GPUTextureFormat/"eac-rg11snorm"}}

<h3 id=texture-compression-astc data-dfn-type=enum-value data-dfn-for=GPUFeatureName>`"texture-compression-astc"`
<span id=dom-gpufeaturename-texture-compression-astc></span>
</h3>

允许显式创建 ASTC 压缩格式的纹理。

此功能添加了以下 [=optional API surfaces=]：

- 新的 {{GPUTextureFormat}} 枚举值：
    - {{GPUTextureFormat/"astc-4x4-unorm"}}
    - {{GPUTextureFormat/"astc-4x4-unorm-srgb"}}
    - {{GPUTextureFormat/"astc-5x4-unorm"}}
    - {{GPUTextureFormat/"astc-5x4-unorm-srgb"}}
    - {{GPUTextureFormat/"astc-5x5-unorm"}}
    - {{GPUTextureFormat/"astc-5x5-unorm-srgb"}}
    - {{GPUTextureFormat/"astc-6x5-unorm"}}
    - {{GPUTextureFormat/"astc-6x5-unorm-srgb"}}
    - {{GPUTextureFormat/"astc-6x6-unorm"}}
    - {{GPUTextureFormat/"astc-6x6-unorm-srgb"}}
    - {{GPUTextureFormat/"astc-8x5-unorm"}}
    - {{GPUTextureFormat/"astc-8x5-unorm-srgb"}}
    - {{GPUTextureFormat/"astc-8x6-unorm"}}
    - {{GPUTextureFormat/"astc-8x6-unorm-srgb"}}
    - {{GPUTextureFormat/"astc-8x8-unorm"}}
    - {{GPUTextureFormat/"astc-8x8-unorm-srgb"}}
    - {{GPUTextureFormat/"astc-10x5-unorm"}}
    - {{GPUTextureFormat/"astc-10x5-unorm-srgb"}}
    - {{GPUTextureFormat/"astc-10x6-unorm"}}
    - {{GPUTextureFormat/"astc-10x6-unorm-srgb"}}
    - {{GPUTextureFormat/"astc-10x8-unorm"}}
    - {{GPUTextureFormat/"astc-10x8-unorm-srgb"}}
    - {{GPUTextureFormat/"astc-10x10-unorm"}}
    - {{GPUTextureFormat/"astc-10x10-unorm-srgb"}}
    - {{GPUTextureFormat/"astc-12x10-unorm"}}
    - {{GPUTextureFormat/"astc-12x10-unorm-srgb"}}
    - {{GPUTextureFormat/"astc-12x12-unorm"}}
    - {{GPUTextureFormat/"astc-12x12-unorm-srgb"}}

<h3 id=timestamp-query data-dfn-type=enum-value data-dfn-for=GPUFeatureName>`"timestamp-query"`
<span id=dom-gpufeaturename-timestamp-query></span>
</h3>

添加了从 GPU 命令缓冲区查询时间戳的能力。参见 [[#timestamp]]。

此功能添加了以下 [=optional API surfaces=]：

- 新的 {{GPUQueryType}} 值：
    - {{GPUQueryType/"timestamp"}}
- 新的 {{GPUCommandEncoder}} 方法：
    - {{GPUCommandEncoder/writeTimestamp()}}
- 新的 {{GPUComputePassDescriptor}} 成员：
    - {{GPUComputePassDescriptor/timestampWrites}}
- 新的 {{GPURenderPassDescriptor}} 成员：
    - {{GPURenderPassDescriptor/timestampWrites}}

<h3 id=indirect-first-instance data-dfn-type=enum-value data-dfn-for=GPUFeatureName>`"indirect-first-instance"`
<span id=dom-gpufeaturename-indirect-first-instance></span>
</h3>

允许在 [=indirect draw parameters=] 和 [=indirect drawIndexed parameters=] 中使用非零的 `firstInstance` 值。

此功能不添加 [=optional API surfaces=]。

<h3 id=shader-f16 data-dfn-type=enum-value data-dfn-for=GPUFeatureName>`"shader-f16"`
<span id=dom-gpufeaturename-shader-f16></span>
</h3>

允许在 WGSL 中使用半精度浮点类型 [=f16=]。

此功能添加了以下 [=optional API surfaces=]：

- 新的 WGSL 扩展：
    - [=extension/f16=]

<h3 id=rg11b10ufloat-renderable data-dfn-type=enum-value data-dfn-for=GPUFeatureName>`"rg11b10ufloat-renderable"`
<span id=dom-gpufeaturename-rg11b10ufloat-renderable></span>
</h3>

允许在格式为 {{GPUTextureFormat/"rg11b10ufloat"}} 的纹理上使用 {{GPUTextureUsage/RENDER_ATTACHMENT}}，

此功能不添加 [=optional API surfaces=]。

<h3 id=bgra8unorm-storage data-dfn-type=enum-value data-dfn-for=GPUFeatureName>`"bgra8unorm-storage"`
</h3>

允许在格式为 {{GPUTextureFormat/"bgra8unorm"}} 的纹理上使用 {{GPUTextureUsage/STORAGE_BINDING}}。

此功能不添加 [=optional API surfaces=]。

<h3 id=float32-filterable data-dfn-type=enum-value data-dfn-for=GPUFeatureName>`"float32-filterable"`
</h3>

使格式为 {{GPUTextureFormat/"r32float"}}、{{GPUTextureFormat/"rg32float"}} 和 {{GPUTextureFormat/"rgba32float"}} 的纹理 [=filterable=]。

# 附录 # {#appendices}

## 纹理格式功能 ## {#texture-format-caps}

### 纯彩色格式 ### {#plain-color-formats}

所有纯彩色格式都支持 {{GPUTextureUsage/COPY_SRC}}、{{GPUTextureUsage/COPY_DST}} 和 {{GPUTextureUsage/TEXTURE_BINDING}} 用法。

{{GPUTextureUsage/RENDER_ATTACHMENT}} 和 {{GPUTextureUsage/STORAGE_BINDING}} 列分别指定对 {{GPUTextureUsage/RENDER_ATTACHMENT|GPUTextureUsage.RENDER_ATTACHMENT}} 和 {{GPUTextureUsage/STORAGE_BINDING|GPUTextureUsage.STORAGE_BINDING}} 用法的支持。

<dfn dfn>render target pixel byte cost</dfn> 和 <dfn dfn>render target component alignment</dfn> 用于验证 {{supported limits/maxColorAttachmentBytesPerSample}} 限制。

注意：
这些格式的 [=texel block memory cost=] 与其 [=texel block copy footprint=] 相同。

<table class=data>
    <thead class=stickyheader>
        <tr>
            <th>Format
            <th>{{GPUTextureSampleType}}
            <th><span class=vertical>{{GPUTextureUsage/RENDER_ATTACHMENT}}</span>
            <th><span class=vertical>[=blendable=]</span>
            <th><span class=vertical>multisampling</span>
            <th><span class=vertical>resolve</span>
            <th><span class=vertical>{{GPUTextureUsage/STORAGE_BINDING}}</span>
            <th>[=Texel block copy footprint=] (Bytes)
            <th>[=Render target pixel byte cost=] (Bytes)
    </thead>
    <tr><th colspan=9>8 bits per component (1-byte [=render target component alignment=])
    <tr>
        <td>{{GPUTextureFormat/r8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>
        <td colspan=2>1
    <tr>
        <td>{{GPUTextureFormat/r8snorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td><!-- Vulkan -->
        <td>
        <td><!-- no multisampling without RENDER_ATTACHMENT (gpuweb/gpuweb#2465) -->
        <td>
        <td><!-- Vulkan -->
        <td>1
        <td>&ndash; <!-- no render target -->
    <tr>
        <td>{{GPUTextureFormat/r8uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td colspan=2>1
    <tr>
        <td>{{GPUTextureFormat/r8sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td colspan=2>1
    <tr>
        <td>{{GPUTextureFormat/rg8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Vulkan -->
        <td colspan=2>2
    <tr>
        <td>{{GPUTextureFormat/rg8snorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td><!-- Vulkan -->
        <td>
        <td><!-- no multisampling without RENDER_ATTACHMENT (gpuweb/gpuweb#2465) -->
        <td>
        <td><!-- Vulkan -->
        <td>2
        <td>&ndash; <!-- no render target -->
    <tr>
        <td>{{GPUTextureFormat/rg8uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td colspan=2>2
    <tr>
        <td>{{GPUTextureFormat/rg8sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td colspan=2>2
    <tr>
        <td>{{GPUTextureFormat/rgba8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>4
        <td>8
    <tr>
        <td>{{GPUTextureFormat/rgba8unorm-srgb}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>
        <td>4
        <td>8
    <tr>
        <td>{{GPUTextureFormat/rgba8snorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td><!-- Vulkan -->
        <td>
        <td><!-- no multisampling without RENDER_ATTACHMENT (gpuweb/gpuweb#2465) -->
        <td>
        <td>&checkmark;
        <td>4
        <td>&ndash; <!-- no render target --> <!-- If we add render target support for this in the future, rgba8snorm has to be a special case where the render target pixel byte cost = 8 -->
    <tr>
        <td>{{GPUTextureFormat/rgba8uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
        <td>&checkmark;
        <td><!-- Metal -->
        <td>&checkmark;
        <td colspan=2>4
    <tr>
        <td>{{GPUTextureFormat/rgba8sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
        <td>&checkmark;
        <td><!-- Metal -->
        <td>&checkmark;
        <td colspan=2>4
    <tr>
        <td>{{GPUTextureFormat/bgra8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>If {{GPUFeatureName/"bgra8unorm-storage"}} is enabled
        <td>4
        <td>8
    <tr>
        <td>{{GPUTextureFormat/bgra8unorm-srgb}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>
        <td>4
        <td>8
    <tr><th colspan=9>16 bits per component (2-byte [=render target component alignment=])
    <tr>
        <td>{{GPUTextureFormat/r16uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td colspan=2>2
    <tr>
        <td>{{GPUTextureFormat/r16sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td colspan=2>2
    <tr>
        <td>{{GPUTextureFormat/r16float}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>
        <td colspan=2>2
    <tr>
        <td>{{GPUTextureFormat/rg16uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td colspan=2>4
    <tr>
        <td>{{GPUTextureFormat/rg16sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td colspan=2>4
    <tr>
        <td>{{GPUTextureFormat/rg16float}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Vulkan -->
        <td colspan=2>4
    <tr>
        <td>{{GPUTextureFormat/rgba16uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
        <td>&checkmark;
        <td><!-- Metal -->
        <td>&checkmark;
        <td colspan=2>8
    <tr>
        <td>{{GPUTextureFormat/rgba16sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
        <td>&checkmark;
        <td><!-- Metal -->
        <td>&checkmark;
        <td colspan=2>8
    <tr>
        <td>{{GPUTextureFormat/rgba16float}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td colspan=2>8
    <tr><th colspan=9>32 bits per component (4-byte [=render target component alignment=])
    <tr>
        <td>{{GPUTextureFormat/r32uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
        <td colspan=2>4
    <tr>
        <td>{{GPUTextureFormat/r32sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
        <td colspan=2>4
    <tr>
        <td>{{GPUTextureFormat/r32float}}
        <td>{{GPUTextureSampleType/"unfilterable-float"}}

            - {{GPUTextureSampleType/"float"}} if {{GPUFeatureName/"float32-filterable"}} is enabled
        <td>&checkmark;
        <td>
        <td>&checkmark;
        <td><!-- Metal -->
        <td>&checkmark;
        <td colspan=2>4
    <tr>
        <td>{{GPUTextureFormat/rg32uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
        <td colspan=2>8
    <tr>
        <td>{{GPUTextureFormat/rg32sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
        <td colspan=2>8
    <tr>
        <td>{{GPUTextureFormat/rg32float}}
        <td>{{GPUTextureSampleType/"unfilterable-float"}}

            - {{GPUTextureSampleType/"float"}} if {{GPUFeatureName/"float32-filterable"}} is enabled
        <td>&checkmark;
        <td>
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
        <td colspan=2>8
    <tr>
        <td>{{GPUTextureFormat/rgba32uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
        <td colspan=2>16
    <tr>
        <td>{{GPUTextureFormat/rgba32sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
        <td colspan=2>16
    <tr>
        <td>{{GPUTextureFormat/rgba32float}}
        <td>{{GPUTextureSampleType/"unfilterable-float"}}

            - {{GPUTextureSampleType/"float"}} if {{GPUFeatureName/"float32-filterable"}} is enabled
        <td>&checkmark;
        <td>
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
        <td colspan=2>16
    <tr><th colspan=9>mixed component width, 32 bits per texel (4-byte [=render target component alignment=])
    <tr>
        <td>{{GPUTextureFormat/rgb10a2unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>
        <td>4
        <td>8
    <tr>
        <td>{{GPUTextureFormat/rg11b10ufloat}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td colspan=4>If {{GPUFeatureName/"rg11b10ufloat-renderable"}} is enabled
        <td><!-- Vulkan -->
        <td>4
        <td>8
</table>

### 深度模具格式 ### {#depth-formats}

<dfn dfn>depth-or-stencil format</dfn> 是任意带有深度和/或模具方面的格式。
<dfn dfn>combined depth-stencil format</dfn> 是一个既有深度又有模具方面的 [=depth-or-stencil format=]。

所有的 [=depth-or-stencil formats=] 都支持 {{GPUTextureUsage/COPY_SRC}}、{{GPUTextureUsage/COPY_DST}}、{{GPUTextureUsage/TEXTURE_BINDING}} 和 {{GPUTextureUsage/RENDER_ATTACHMENT}} 用法。
所有这些格式都支持多重采样。然而某些复制操作也限制了源和目标格式。

深度纹理不能使用 {{GPUSamplerBindingType/"filtering"}} 采样器，但总是可以使用 {{GPUSamplerBindingType/"comparison"}} 采样器（它们可以使用过滤）。

<table class=data>
    <thead>
        <tr>
            <th>Format
            <th class=note>[=Texel block memory cost=] (Bytes)
            <th>Aspect
            <th>{{GPUTextureSampleType}}
            <th>Valid [=image copy=] source
            <th>Valid [=image copy=] destination
            <th>[=Texel block copy footprint=] (Bytes)
            <th><dfn dfn>Aspect-specific format</dfn>
    </thead>
    <tr>
        <td>{{GPUTextureFormat/stencil8}}
        <td>1 &minus; 4
        <td>stencil
        <td>{{GPUTextureSampleType/"uint"}}
        <td colspan=2>&checkmark;
        <td>1
        <td>{{GPUTextureFormat/stencil8}}
    <tr>
        <td>{{GPUTextureFormat/depth16unorm}}
        <td>2
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}, {{GPUTextureSampleType/"unfilterable-float"}}
        <td colspan=2>&checkmark;
        <td>2
        <td>{{GPUTextureFormat/depth16unorm}}
    <tr>
        <td>{{GPUTextureFormat/depth24plus}}
        <td>4
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}, {{GPUTextureSampleType/"unfilterable-float"}}
        <td colspan=2>&cross;
        <td>&ndash;
        <td>{{GPUTextureFormat/depth24plus}}
    <tr>
        <td rowspan=2 style="white-space: nowrap">{{GPUTextureFormat/depth24plus-stencil8}}
        <td rowspan=2>4 &minus; 8
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}, {{GPUTextureSampleType/"unfilterable-float"}}
        <td colspan=2>&cross;
        <td>&ndash;
        <td>{{GPUTextureFormat/depth24plus}}
    <tr>
        <td>stencil
        <td>{{GPUTextureSampleType/"uint"}}
        <td colspan=2>&checkmark;
        <td>1
        <td>{{GPUTextureFormat/stencil8}}
    <tr>
        <td>{{GPUTextureFormat/depth32float}}
        <td>4
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}, {{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&cross;
        <td>4
        <td>{{GPUTextureFormat/depth32float}}
    <tr>
        <td rowspan=2 style="white-space: nowrap">{{GPUTextureFormat/depth32float-stencil8}}
        <td rowspan=2>5 &minus; 8
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}, {{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&cross;
        <td>4
        <td>{{GPUTextureFormat/depth32float}}
    <tr>
        <td>stencil
        <td>{{GPUTextureSampleType/"uint"}}
        <td colspan=2>&checkmark;
        <td>1
        <td>{{GPUTextureFormat/stencil8}}
</table>

<dfn dfn>24-bit depth</dfn> 指的是一个 24 位无符号归一化深度格式，其范围从 0.0 到 1.0，如果暴露出来，它将被拼写为 "depth24unorm"。

#### 读取和采样深度/模具纹理 #### {#reading-depth-stencil}

绑定深度方面 {{GPUTextureView}} 到 `texture_depth_*` 绑定或其他非深度 2d/cube 纹理类型的绑定是 [$validating shader binding|possible$] 的。

模具方面 {{GPUTextureView}} 必须绑定到普通纹理绑定类型。{{GPUBindGroupLayout}} 中的 {{GPUTextureBindingLayout/sampleType}} 必须是 {{GPUTextureSampleType/"uint"}}。

读取或采样纹理的深度或模具方面的行为就像纹理包含值 `(V, X, X, X)`，其中 V 是实际的深度或模具值，每个 X 是实现定义的未指定值。

对于深度方面绑定，未指定的值在具有 `texture_depth_*` 类型的绑定中不可见。

<div class=example>
    If a depth texture is bound to `tex` with type `texture_2d<f32>`:

    - `textureSample(tex, ...)` will return `vec4<f32>(D, X, X, X)`.
    - `textureGather(0, tex, ...)` will return `vec4<f32>(D1, D2, D3, D4)`.
    - `textureGather(2, tex, ...)` will return `vec4<f32>(X1, X2, X3, X4)` (a completely unspecified value).
</div>

注意：
除了添加一个新的更受限制的模具采样器类型（如深度）之外，实现无法有效地掩盖深度/模具读取的驱动程序差异。由于这不是 WebGL 的可移植性痛点，因此不希望在 WebGPU 中出现问题。实际上，根据硬件的不同，期望是 `(V, V, V, V)` 或 `(V, 0, 0, 1)`（其中 `V` 是深度或模具值）。

#### 复制深度/模具纹理 #### {#copying-depth-stencil}

深度方面的深度32float格式（{{GPUTextureFormat/"depth32float"}} 和 {{GPUTextureFormat/"depth32float-stencil8"}}）具有有限的范围。
因此，从相同格式的其他纹理复制到此类纹理是有效的。
<!-- POSTV1(unrestricted-depth): unless unrestricted depth is enabled -->

深度方面的深度24plus格式（{{GPUTextureFormat/"depth24plus"}} 和 {{GPUTextureFormat/"depth24plus-stencil8"}}）具有不透明的表示（实现为 [=24-bit depth=] 或 {{GPUTextureFormat/"depth32float"}}）。
因此，不允许使用这些格式进行深度方面的 [=image copies=]。

<div class=note>
     注意：
    可以模仿这些不允许的复制：

    - 所有这些格式都可以使用通过 `frag_depth` 输出输出深度值的片段着色器在渲染通道中写入。
    - 具有 "depth24plus" 格式的纹理可以作为着色器纹理读取，并写入纹理（作为渲染通道附件）或缓冲区（通过计算着色器中的存储缓冲区绑定）。
</div>

### 压缩格式 ### {#packed-formats}

所有的压缩纹理格式都支持{{GPUTextureUsage/COPY_SRC}}，{{GPUTextureUsage/COPY_DST}}和{{GPUTextureUsage/TEXTURE_BINDING}}用法。
所有这些格式都是可过滤的。
这些格式都不是可渲染的，也不支持多重采样。

<dfn dfn>compressed format</dfn>是任何块大小大于1&times;1的格式。

 注意：
每个这些格式的[=texel block memory cost=]与其[=texel block copy footprint=]相同。


<table class=data>
    <thead class=stickyheader>
        <tr>
            <th>Format
            <th>[=Texel block copy footprint=] (Bytes)
            <th>{{GPUTextureSampleType}}
            <th>Texel block [=texel block width|width=]/[=texel block height|height=]
            <th>[=Feature=]
    </thead>
    <tr>
        <td>{{GPUTextureFormat/rgb9e5ufloat}}
        <td>4
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>1 &times; 1
        <td>
    <tr>
        <td>{{GPUTextureFormat/bc1-rgba-unorm}}
        <td rowspan=2>8
        <td rowspan=14>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td rowspan=14>4 &times; 4
        <td rowspan=14>{{GPUFeatureName/texture-compression-bc}}
    <tr>
        <td>{{GPUTextureFormat/bc1-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/bc2-rgba-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc2-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/bc3-rgba-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc3-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/bc4-r-unorm}}
        <td rowspan=2>8
    <tr>
        <td>{{GPUTextureFormat/bc4-r-snorm}}
    <tr>
        <td>{{GPUTextureFormat/bc5-rg-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc5-rg-snorm}}
    <tr>
        <td>{{GPUTextureFormat/bc6h-rgb-ufloat}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc6h-rgb-float}}
    <tr>
        <td>{{GPUTextureFormat/bc7-rgba-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc7-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8unorm}}
        <td rowspan=2>8
        <td rowspan=10>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td rowspan=10>4 &times; 4
        <td rowspan=10>{{GPUFeatureName/texture-compression-etc2}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8a1unorm}}
        <td rowspan=2>8
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8a1unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgba8unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/etc2-rgba8unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/eac-r11unorm}}
        <td rowspan=2>8
    <tr>
        <td>{{GPUTextureFormat/eac-r11snorm}}
    <tr>
        <td>{{GPUTextureFormat/eac-rg11unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/eac-rg11snorm}}
    <tr>
        <td>{{GPUTextureFormat/astc-4x4-unorm}}
        <td rowspan=2>16
        <td rowspan=28>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td rowspan=2>4 &times; 4
        <td rowspan=28>{{GPUFeatureName/texture-compression-astc}}
    <tr>
        <td>{{GPUTextureFormat/astc-4x4-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-5x4-unorm}}
        <td rowspan=2>16
        <td rowspan=2>5 &times; 4
    <tr>
        <td>{{GPUTextureFormat/astc-5x4-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-5x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>5 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-5x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-6x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>6 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-6x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-6x6-unorm}}
        <td rowspan=2>16
        <td rowspan=2>6 &times; 6
    <tr>
        <td>{{GPUTextureFormat/astc-6x6-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-8x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>8 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-8x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-8x6-unorm}}
        <td rowspan=2>16
        <td rowspan=2>8 &times; 6
    <tr>
        <td>{{GPUTextureFormat/astc-8x6-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-8x8-unorm}}
        <td rowspan=2>16
        <td rowspan=2>8 &times; 8
    <tr>
        <td>{{GPUTextureFormat/astc-8x8-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-10x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x6-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 6
    <tr>
        <td>{{GPUTextureFormat/astc-10x6-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x8-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 8
    <tr>
        <td>{{GPUTextureFormat/astc-10x8-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x10-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 10
    <tr>
        <td>{{GPUTextureFormat/astc-10x10-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-12x10-unorm}}
        <td rowspan=2>16
        <td rowspan=2>12 &times; 10
    <tr>
        <td>{{GPUTextureFormat/astc-12x10-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-12x12-unorm}}
        <td rowspan=2>16
        <td rowspan=2>12 &times; 12
    <tr>
        <td>{{GPUTextureFormat/astc-12x12-unorm-srgb}}
</table>

<script>
// Small script to collect all xrefs that refer to different timelines and highlight
// them with an appropriate style.

const dataLinks = document.querySelectorAll("[data-link-type='abstract-op'], [data-link-type='dfn'], [data-link-type='idl'], [data-link-type='attribute']");
for (const dataLink of dataLinks) {
    const linkUrl = dataLink.getAttribute('href');
    if (linkUrl && linkUrl.startsWith('#')) {
      const dataLinkTarget = document.getElementById(linkUrl.substring(1));
      if (dataLinkTarget) {
          // Find the closest ancestor of the target (including the target itself)
          // that contains a data-timeline.
          const timelineElement = dataLinkTarget.closest('[data-timeline]');
          if (timelineElement) {
            // If we found a timeline, apply an appropriate style the link.
            const timeline = timelineElement.getAttribute('data-timeline');
            dataLink.setAttribute('data-timeline', timeline);
          }
      }
    }
}
</script>
